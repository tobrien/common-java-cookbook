<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.discursive.com/docbook/xml/4.5/docbookx.dtd">
<chapter id="guava-io">
  <title>Google Guava: I/O</title>

  <sect1 id="guava-io-sect-intro">
    <title>Introduction</title>

    <sect2>
      <title>What is Guava?</title>

      <para>Google Guava is a collection of simple core Java libraries used at
      Google. It is a collection of utility classes and static methods
      reminiscent of the Apache Commons components discussed in previous
      chapters.</para>
    </sect2>
  </sect1>

  <sect1 id="guava-io-sect-obtaining" role="Recipe">
    <title>Obtaining Google Guava</title>

    <sect2>
      <title>Problem</title>

      <para>You need to use Google Guava in a project.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>To use Google Guava in a Maven 2 project, add the following
      dependency to your project's <filename>pom.xml</filename>:</para>

      <example id="guava-io-ex-depend">
        <title>Adding a Dependency on Google Guava</title>

        <programlisting language="xml">&lt;dependency&gt;
  &lt;groupId&gt;com.google.guava&lt;/groupId&gt;
  &lt;artifactId&gt;guava&lt;/artifactId&gt;
  &lt;version&gt;${googleguava.version}&lt;/version&gt;
&lt;/dependency&gt;
</programlisting>
      </example>

      <para>If you are not sure what this means, I'd suggest reading <ulink
      url="http://www.sonatype.com/books/maven-book">Maven: The Complete
      Reference</ulink>. When you depend on a library in Maven 2, all you need
      to do is add the dependency <varname>groupId</varname>,
      <varname>artifactId</varname>, and <varname>version</varname> to your
      project's dependencies. Once you do this, Maven 2 will download the
      dependency and make it available on your project's classpath.</para>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>For more information about the Google Guava project, see the
      project page at <ulink
      url="http://code.google.com/p/guava-libraries/">http://code.google.com/p/guava-libraries/</ulink>.</para>
    </sect2>
  </sect1>

  <sect1 id="guava-io-sect-copying-inout">
    <title>Copying and InputStream to an OutputStream</title>

    <sect2>
      <title>Problem</title>

      <para>You need to copy the contents of an
      <classname>InputStream</classname> to the contents of an
      <classname>OutputStream</classname>.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use the static copy method on <classname>ByteStreams</classname>
      as shown in <xref linkend="guava-io-ex-copy" />.</para>

      <example id="guava-io-ex-copy">
        <title>Copying the Contents of an InputStream to an
        OutputStream</title>

        <programlisting language="java">package com.discursive.cjcook.guava.io;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

import com.google.common.io.ByteStreams;

public class CopyStreams {

  public static void main(String[] args) throws IOException {
    InputStream is = CopyStreams.class.getResourceAsStream("test.data");
    OutputStream os = System.out;

    ByteStreams.copy(is, os);
  }

}
</programlisting>
      </example>
    </sect2>
  </sect1>

  <sect1 id="guava-io-sect-calc-sum-stream">
    <title>Calculating a Checksum for a Byte Array</title>

    <sect2>
      <title>Problem</title>

      <para>You need to calculate the checksum for an array of bytes.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use the <methodname>ByteStreams.getChecksum()</methodname> method
      and pass the method a <classname>Checksum</classname> object as shown in
      the following example.</para>

      <example id="guava-io-ex-checksum">
        <title>Calculating the Checksum of a Byte Array</title>

        <programlisting language="java">package com.discursive.cjcook.guava.io;

import java.io.InputStream;
import java.util.zip.CRC32;
import java.util.zip.Checksum;

import com.google.common.io.ByteArrayDataInput;
import com.google.common.io.ByteStreams;

public class ChecksumStream {
  public static void main(String[] args) throws Exception {
    InputStream test = ChecksumStream.class
        .getResourceAsStream("test.data");
    byte[] byteArray = ByteStreams.toByteArray(test);

    CRC32 crc32 = new CRC32();
    long checksum = ByteStreams.getChecksum(ByteStreams
        .newInputStreamSupplier(byteArray), crc32);
    System.out.printf("Checksum: %d", checksum);
  }
}</programlisting>
      </example>

      <para>This produces the following output:</para>

      <screen>Checksum: 3946081184</screen>
    </sect2>
  </sect1>

  <sect1 id="guava-io-sect-calc-dig-stream">
    <title>Calculating a Message Digest for a Byte Array</title>

    <sect2>
      <title>Problem</title>

      <para>You need to calculate a message digest for an array of
      bytes.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use the <methodname>ByteStreams.getDigest()</methodname> method
      and pass the method a <classname>MessageDigest</classname> object as
      shown in the following example.</para>

      <example id="guava-io-ex-digest">
        <title>Calculating the MessageDigest of a Byte Array</title>

        <programlisting language="java">package com.discursive.cjcook.guava.io;

import java.io.InputStream;
import java.security.MessageDigest;
import java.util.zip.CRC32;
import java.util.zip.Checksum;

import org.apache.commons.codec.binary.Hex;

import com.google.common.io.ByteArrayDataInput;
import com.google.common.io.ByteStreams;

public class DigestBytes {
  public static void main(String[] args) throws Exception {
    InputStream test = DigestBytes.class.getResourceAsStream("test.data");
    byte[] byteArray = ByteStreams.toByteArray(test);

    MessageDigest sha = MessageDigest.getInstance("SHA-256");
    byte[] digest = ByteStreams.getDigest(ByteStreams
        .newInputStreamSupplier(byteArray), sha);
    for (byte b : digest)
      System.out.printf("%02x:", 0xFF &amp; b);
  }
}
</programlisting>
      </example>

      <para>This produces the following output:</para>

      <screen>c3:de:3a:a1:9f:7d:8f:7c:e2:87:ef:8e:2c:19:73:62:47:2b:
95:dd:f0:3f:39:51:a5:02:04:24:e5:6e:a7:a0:</screen>
    </sect2>
  </sect1>

  <sect1 id="guava-io-sect-concat-streams">
    <title>Concatenating Multiple Files</title>

    <sect2>
      <title>Problem</title>

      <para>You want to combine multiple InputStreams into a single
      InputStream.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Create new InputSuppliers from files using
      Files.newInputStreamSupplier(), create an OutputSupplier using
      Files.newOutputStreamSupplier, join the InputSupplier instances using
      ByteStreams.join(), and then copy the combined InputSupplier to the
      OutputSupplier using ByteStreams.copy().</para>

      <example id="guava-io-ex-join">
        <title>Joining Two Files using ByteStreams.join() and
        ByteStreams.copy()</title>

        <programlisting language="java">package com.discursive.cjcook.guava.io;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.nio.charset.Charset;

import com.google.common.io.ByteStreams;
import com.google.common.io.CharStreams;
import com.google.common.io.Files;
import com.google.common.io.InputSupplier;
import com.google.common.io.OutputSupplier;

public class JoinFiles {
  public static void main(String[] args) throws Exception {
  
    InputSupplier&lt;FileInputStream&gt; is = 
        Files.newInputStreamSupplier( new File("data", "test1.txt" ) );
    InputSupplier&lt;FileInputStream&gt; is2 = 
        Files.newInputStreamSupplier( new File("data", "test2.txt" ) );

    InputSupplier&lt;InputStream&gt; combined = ByteStreams.join( is, is2 );
    OutputSupplier&lt;FileOutputStream&gt; os = 
        Files.newOutputStreamSupplier(new File("output1.data"), false );
    ByteStreams.copy(combined, os );
  }
}
</programlisting>
      </example>
    </sect2>
  </sect1>

  <sect1 id="guava-io-sect-concat-readers">
    <title>Concatenating Multiple Readers</title>

    <sect2>
      <title>Problem</title>

      <para>You need to concatenate the contents of one or more Readers. In
      this case, you need to append the contents of two files, and you want to
      use Readers and Writers to take into account the character sets of the
      files.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use Files.newReaderSupplier() to create two InputSuppliers. Pass
      these InputSuppliers to CharStreams.join(). Create an OutputSupplier
      using Files.newWriterSupplier(), and then use CharStreams.copy() to copy
      the InputSupplier to the OutputSupplier.</para>

      <example id="guava-io-ex-join-readers">
        <title>Joining Two Readers using CharStreams.join() and
        CharStreams.copy()</title>

        <programlisting language="java">package com.discursive.cjcook.guava.io;

import java.io.File;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.Reader;
import java.nio.charset.Charset;

import com.google.common.io.CharStreams;
import com.google.common.io.Files;
import com.google.common.io.InputSupplier;
import com.google.common.io.OutputSupplier;

public class JoinReaders {
  public static void main(String[] args) throws Exception {
    Charset utf8 = Charset.forName("UTF-8");

    InputSupplier&lt;InputStreamReader&gt; rs1 = Files.newReaderSupplier(
        new File("data", "test1.txt"), utf8);
    InputSupplier&lt;InputStreamReader&gt; rs2 = Files.newReaderSupplier(
        new File("data", "test2.txt"), utf8);

    InputSupplier&lt;Reader&gt; combined = CharStreams.join(rs1, rs2);

    OutputSupplier&lt;OutputStreamWriter&gt; ws = Files.newWriterSupplier(
        new File("output.txt"), utf8, false);

    CharStreams.copy(combined, ws);
  }
}
</programlisting>
      </example>
    </sect2>
  </sect1>

  <sect1 id="guava-io-sect-byte-mem">
    <title>Reading and Writing Byte Arrays to and from Memory</title>

    <sect2>
      <title>Problem</title>

      <para>You are going to be reading and writing byte arrays to and from
      memory, and you are looking for an alternative to the
      ByteArrayInputStream and ByteArrayOutputStream that doesn't force you to
      catch IOException.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>If you are working with in-memory byte arrays, having to deal with
      IOException is a distraction. Use the ByteArrayDataInput and
      ByteArrayDataOutput classes instead:</para>

      <example id="guava-io-ex-datainout">
        <title>Using ByteArrayDataOutput and ByteArrayDataInput</title>

        <programlisting language="java">package com.discursive.cjcook.guava.io;

import java.util.Date;

import org.apache.commons.lang.math.RandomUtils;

import com.discursive.cjcook.proto.Checkin.PositionData;
import com.google.common.io.ByteArrayDataInput;
import com.google.common.io.ByteArrayDataOutput;
import com.google.common.io.ByteStreams;

public class ByteArrayExample {
  public static void main(String[] args) throws Exception {
    int size = 10000;
    ByteArrayDataOutput byteOut = ByteStreams.newDataOutput();

    for( int i = 0; i &lt; size; i++ ) {
      byteOut.writeDouble( RandomUtils.nextDouble() );
      byteOut.writeInt( RandomUtils.nextInt() );
    }

    ByteArrayDataInput input = 
        ByteStreams.newDataInput( byteOut.toByteArray() );
    for( int i = 0; i &lt; size; i++ ) {
      input.readInt();
      input.readDouble();
    }
  }
}</programlisting>
      </example>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>Here's an example of using a ByteArrayOutputStream to write data
      encoded with Google's Protocol Buffers to an in-memory byte
      array.</para>

      <example id="guava-io-ex-writing-proto">
        <title>Writing Data with the ByteArrayDataOutput Class</title>

        <programlisting language="java">package com.discursive.cjcook.guava.io;

import java.util.Date;

import org.apache.commons.lang.math.RandomUtils;

import com.discursive.cjcook.proto.Checkin.PositionData;
import com.google.common.io.ByteArrayDataOutput;
import com.google.common.io.ByteStreams;

public class ByteArrayInputExample {
  public static void main(String[] args) throws Exception {
    int size = 10000;
    ByteArrayDataOutput byteOut = ByteStreams.newDataOutput();

    for (int i = 0; i &lt; size; i++) {
      PositionData pData = PositionData.newBuilder().setVehicleId(1)
          .setTimestamp((new Date()).getTime()).setAltitude(
              RandomUtils.nextFloat()).setLatitude(1.0f)
          .setLongitude(1.0f).setSpeed(RandomUtils.nextInt(100))
          .build();
      byteOut.write(pData.toByteArray());
    }

    byte[] encodedData = byteOut.toByteArray();
    System.out.printf("%d PositionData objects encoded into %d bytes",
        size, encodedData.length);
  }
}</programlisting>
      </example>

      <para>This produces the following output:</para>

      <screen>10000 PositionData objects encoded into 260000 bytes</screen>

      <para>If we were to write the same class without the benefit of the
      ByteArrayDataOutput class, we would have used a ByteArrayOutputStream
      wrapped with a DataOutputStream. As you can see in the example shown
      below, this would have called for some exception handling around the
      call to the write() method.</para>

      <example id="guava-io-ex-writing-proto2">
        <title>Writing Data without the ByteArrayDataOutput Class</title>

        <programlisting language="java">package com.discursive.cjcook.guava.io;

import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.util.Date;

import org.apache.commons.lang.math.RandomUtils;

import com.discursive.cjcook.proto.Checkin.PositionData;

public class ByteArrayInputExampleAlt {
  public static void main(String[] args) {
    int size = 10000;
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    DataOutputStream dos = new DataOutputStream(baos);

    for (int i = 0; i &lt; size; i++) {
      PositionData pData = PositionData.newBuilder().setVehicleId(1)
          .setTimestamp((new Date()).getTime()).setAltitude(
             RandomUtils.nextFloat()).setLatitude(1.0f)
          .setLongitude(1.0f).setSpeed(RandomUtils.nextInt(100))
          .build();
      try {
        dos.write(pData.toByteArray());
      } catch (IOException e) {
        // Please this is a PITA
        // Use the ByteArrayDataOutput
      }
    }

    byte[] encodedData = baos.toByteArray();
    System.out.printf("%d PositionData objects encoded into %d bytes",
        size, encodedData.length);
  }
}
</programlisting>
      </example>

      <para>While the savings in lines of code for this example are minimal,
      if you are going to be throwing data into and out of in-memory byte
      arrays, these classes can help minimize the amount of unnecessary
      exception handling.</para>
    </sect2>
  </sect1>

  <sect1 id="guava-io-sect-slicing">
    <title>Slicing (and Dicing) an InputStream</title>

    <sect2>
      <title>Problem</title>

      <para>You need to read a particular region of an InputStream. Maybe you
      have an in-memory byte array and you only need to read a particular
      portion of this array, or maybe you need to read information from a
      binary file, skipping an unimportant preamble.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use ByteStreams.slice() to slice an InputSupplier. When you slice
      an InputSupplier, you create a new InputSupplier which will return an
      InputStream that contains a specified portion of the underlying
      stream.</para>

      <example id="guava-io-ex-slicing">
        <title>Slicing Data from an InputStream</title>

        <programlisting language="java">package com.discursive.cjcook.guava.io;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;

import com.google.common.io.ByteStreams;
import com.google.common.io.Files;
import com.google.common.io.InputSupplier;

public class SliceExample {
  public static void main(String[] args) throws IOException {
    InputSupplier&lt;FileInputStream&gt; fileIn = Files
        .newInputStreamSupplier(new File("data", "large.txt"));
    InputSupplier&lt;InputStream&gt; slicedStream = 
        ByteStreams.slice( fileIn, 10, 1000 );
    byte[] data = ByteStreams.toByteArray( slicedStream );
  }
}
</programlisting>
      </example>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>The last two arguments to the slice method are: offset, the number
      of bytes into the underlying stream to start the newly sliced stream and
      the maximum number of bytes to return from this newly sliced
      stream.</para>
    </sect2>
  </sect1>

  <sect1 id="guava-io-sect-flush-close">
    <title>Flushing and Closing Stream, Writer, or Reader (without the
    Headache of Exception Handling)</title>

    <sect2>
      <title>Problem</title>

      <para>You are constantly having to close and flush streams and you would
      like to avoid having to catch IOException.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use Closeables and Flushables. Here's an example of opening and
      writing a single byte to a file without the help of any convenience
      methods from a library like Google Guava or Apache Commons.</para>

      <example id="guava-io-ex-closefluse-no-help">
        <title>One of the Reasons Java Gets a Bad Rap</title>

        <programlisting language="java">package com.discursive.cjcook.guava.io;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;

public class CloseFlushExample {
  public static void main(String[] args) {
    OutputStream os = null;
    try {
      os = new FileOutputStream(new File("data", "output.txt"));

      // Do something fantastic with this file!!!
      // etc.
      byte magnificentByte = 1;
      os.write( magnificentByte );
    } catch (FileNotFoundException fnfe) {
      // Do something about this file not being found.
    } catch(IOException ioe) {
      // Egad, there's been an exception! Do something!!!
    } finally {
      try {
        if (os != null) {
          os.flush();
          os.close();
        }
      } catch (IOException e) {
        // Ok, what are you going to do now?
      }
    }
  }
}
</programlisting>
      </example>

      <para>Forget the exception handling outside of the finally block (which
      is already distracting). If you trying to flush and close the
      OutputStream in a finally block you are in for a surprise. Since flush()
      and close() throw an IOException, your finally block has to have a
      nested try/catch block. While there may be someone, somewhere who is
      appreciative of the fact that flush() throws an IOException, most
      systems don't need this much exception handling, and the previous
      example is exactly the sort of thing that makes your friends who write
      Ruby code snicker and say somethng like: "Java 10% real code, 90%
      exception handling".</para>

      <para>The example shown below, uses Closeables and Flushables to quietly
      flush() and close() the OutputStream. If there is an IOException on
      flush() or close(), your application won't be bothered.</para>

      <example id="guava-io-ex-closeables-flushables">
        <title>Using Closeables and Flushables in a finally block</title>

        <programlisting language="java">package com.discursive.cjcook.guava.io;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;

import com.google.common.io.Closeables;
import com.google.common.io.Flushables;

public class CloseFlushExample {
  public static void main(String[] args) {
    OutputStream os = null;
    try {
      os = new FileOutputStream(new File("data", "output.txt"));

      // Do something fantastic with this file!!!
      // etc.
      byte magnificentByte = 1;
      os.write( magnificentByte );
    } catch (FileNotFoundException fnfe) {
      // Do something about this file not being found.
    } catch(IOException ioe) {
      // Egad, there's been an exception! Do something!!!
    } finally {
      Flushables.flushQuietly( os );
      Closeables.closeQuietly( os );
    }
  }
}
</programlisting>
      </example>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>While using Closeables and Flushables improves the exception
      handling situation, is it really that much better? Barely.</para>

      <para>Instead of dealing directly with an OutputStream, you can just use
      the Files class to create a new OutputSupplier. Then, use the
      ByteStreams class to write a byte array to this OutputSupplier. If you
      use ByteStreams, you will only have to catch a single occurence of
      IOException for your call to write(), and ByteStreams will take care of
      calling close() on the OutputStream.</para>

      <example id="guava-io-ex-avoid-ex">
        <title>Avoid Most Exception Handling with ByteStreams.write()</title>

        <programlisting language="java">package com.discursive.cjcook.guava.io;

import java.io.Closeable;
import java.io.File;
import java.io.Flushable;
import java.io.IOException;

import com.google.common.io.ByteStreams;
import com.google.common.io.Closeables;
import com.google.common.io.Files;
import com.google.common.io.Flushables;
import com.google.common.io.OutputSupplier;

public class CloseFlushExample3 {
  public static void main(String[] args) {
    OutputSupplier os = Files.newOutputStreamSupplier(
        new File("data", "output.txt"));
    byte magnificentByte = 1;
    try {
      ByteStreams.write(new byte[] { magnificentByte }, os);
    } catch (IOException e) {
      // Problem writing to file.
    }
  }
}</programlisting>

        <para>Now, isn't that much easier?</para>
      </example>
    </sect2>
  </sect1>

  <sect1 id="guava-io-sect-measuring">
    <title>Measuring Amount of Data Written To and Read From a Stream</title>

    <sect2>
      <title>Problem</title>

      <para>You need to meter a stream and measure the amount of data read
      from or written to an <classname>InputStream</classname> or an
      <classname>OutputStream</classname>.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use a <classname>CountingInputStream</classname> or a
      <classname>CountingOutputStream</classname> to wrap an
      <classname>InputStream</classname> and
      <classname>OutputStream</classname> and measure the number of bytes read
      from or written to the underlying stream.</para>

      <example id="guava-io-ex-counting">
        <title>Using a CountingInputStream and CountingOutputStream</title>

        <programlisting language="java">package com.discursive.cjcook.guava.io;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.charset.Charset;

import com.google.common.io.CountingInputStream;
import com.google.common.io.CountingOutputStream;

public class MeteredExample {

  public static void main(String[] args) throws Exception {
    InputStream fis = new FileInputStream( new File("data", "large.txt") );
    CountingInputStream cis = new CountingInputStream( fis );

    while( cis.read() != -1 ) {
      long bytesRead = cis.getCount();
      if( bytesRead % 50 == 0 ) {
        System.out.printf( "Read %d bytes...\n", bytesRead );
      }
    }

    OutputStream fos = new FileOutputStream( new File("output.dat" ) );
    CountingOutputStream cos = new CountingOutputStream( fos );
    String testString = "TEST STRING";
    cos.write( testString.getBytes( Charset.defaultCharset() ) );
    System.out.printf( "Just wrote %d bytes to output.dat", cos.getCount() );

  }
}
</programlisting>
      </example>

      <para>This example produces the following output:</para>

      <screen>Read 50 bytes...
Read 100 bytes...
Read 150 bytes...
Read 200 bytes...
Read 250 bytes...
Just wrote 11 bytes to output.dat</screen>
    </sect2>
  </sect1>

  <sect1 id="guava-io-sect-buffering-file">
    <title>Buffering Data to a File As Needed</title>

    <sect2>
      <title>Problem</title>

      <para>You need to accept a stream of data and you want to cache this
      data in memory if the data doesn't exceed a certain size. </para>

      <para>Assume that you are operating a service that allows users to
      upload images which will ultimately be processed into a standard format
      and stored in some distributed file system. Because there is a wide
      variety of image sizes, you want to be able to cache the majority of
      user-supplied images in memory falling back to a file buffer only if the
      image exceeds a certain size.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use the <classname>FileBackedOutputStream</classname> to create an
      <classname>OutputStream</classname> with a defined threshold. If you do
      not exceed the threshold, the
      <classname>FileBackedOutputStream</classname> stores all data in memory.
      If you exceed this threshold, the
      <classname>FileBackedOutputStream</classname> copies the data buffered
      in memory to a temporary file and then writes all additional data to a
      file.</para>

      <programlisting>// Threshold is 3 MB
int THRESHOLD = 3 * 1024 * 1024;

byte[] data = retrieveData();
FileBackedOutputStream os = new FileBackedOutputStream( THRESHOLD );
os.write( data );

// Once you are ready to use the data buffered in either memory or a file
InputStream is = os.getSupplier().getInput();


// Reading from this InputStream will read from an in-memory byte array 
// or from a temporary file</programlisting>

      <para>The behavior of the FileBackedOutputStream is illustrated in <xref
      linkend="guava-io-fig-filebacked" />.</para>

      <figure id="guava-io-fig-filebacked">
        <title>Using a FilebackedOutputStream to Store Data in Memory (or a
        File) Depending on Data Size</title>

        <mediaobject>
          <imageobject role="print">
            <imagedata align="center"
                       fileref="figs/print/guava-io-file-backed.pdf"
                       format="PDF" scalefit="0" width="100%" />
          </imageobject>

          <imageobject role="web">
            <imagedata fileref="figs/web/guava-io-file-backed.png"
                       format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>When the <classname>FileBackedOutputStream</classname> is
      constructed, you supply a threshold to the object which defines the
      number of bytes that can be stored in memory. Writing to the
      <classname>FileBackedOutputStream</classname> (1) will store memory in
      an in-memory byte array up until the threshold has been reached. When
      this threshold is exceeded, the
      <classname>FileBackedOutputStream</classname> will then create a
      temporary file (3), swap the contents of the in-memory byte array to
      this temporary file, and send all subsequent writes to the temporary
      file. </para>

      <para>Once you have finished writing to the
      <classname>FileBackedOutputStream</classname>, you can retrieve the data
      from either the in-memory byte array or the temporary file using the
      <methodname>getSupplier()</methodname> method which returns an
      <classname>InputSupplier&lt;InputStream&gt;</classname>.</para>

      <warning>
        <para><classname>FileBackedOutputStream</classname> is a misnomer,
        this <classname>OutputStream</classname> is only backed by a file once
        the in-memory storage threshold has been exceeded. This name suggests
        that there is a file associated with this stream by default, in
        reality this class should be named something like
        "<classname>PotentiallyFileBackedOutputStream</classname>", but, then
        again, who would want to type that?</para>
      </warning>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>Going back to the problem description, let's imagine that you are
      running an user-generated content site which needs to accept photo
      uploads. You want to use a solution which keeps the majority of
      user-supplied images in memory to speed up processing, but you also
      don't want to set an arbitrary size limit for user uploads. Through site
      metrics, you've found that your average user-generated image is 300 KB,
      and that if you used a threshold of 340 KB, you would be able to process
      95% of your user's images without ever having to write images to an
      expensive SAN filesystem. Since each node in your datacenter has a few
      GB of memory, storing a few hundred KB of image data in memory isn't
      going to present a problem.</para>

      <para>In the following example, we set the threshold for using a
      File-backed Output Stream to 340 KB and we define a system to simulate
      2000 user requests distributed over a normal curve which matches your
      site's performance numbers. In this example, we're trying to figure out
      just how much benefit you will gain from using the FileBackOutputStream.
      </para>

      <example id="guava-io-ex-filebacked">
        <title>Measuring the Performance of FileBackedOutputStream</title>

        <programlisting>package com.discursive.cjcook.guava.io;

import java.util.Random;

import org.apache.commons.math.stat.StatUtils;

import com.google.common.io.Closeables;
import com.google.common.io.FileBackedOutputStream;

public class ThrowingAroundData {

  // Define a 200 KB threshold
  private static int THRESHOLD = 340 * 1024;

  // Define the Mean for Image Size
  private static int MEAN = 300 * 1024;

  // Define the Standard Deviation (such that 95% fall below threshold)
  private static int STDEV = Math.round( ( THRESHOLD - MEAN ) / 1.645f);

  // Define the Sample Size
  private static int SAMPLE = 2000;

  public static void main(String[] args) throws Exception {

    double[] times = new double[SAMPLE];
    double[] sizes = new double[SAMPLE];

        //    File tempFile = File.createTempFile("tmp", "tmp");

    for (int i = 0; i &lt; SAMPLE; i++) {
      byte[] randomData = generateRandomData();

      long t1 = System.nanoTime();
      FileBackedOutputStream os = new FileBackedOutputStream(THRESHOLD);
      //OutputStream os = new FileOutputStream(tempFile);
      os.write(randomData);
      Closeables.closeQuietly(os);
      long t2 = System.nanoTime();
      times[i] = (double) (t2 - t1);
      sizes[i] = randomData.length;
    }

    System.out.printf("Time(ns) Mean: %.2f, StdDev: %.2f, Min: %.2f, Max: %.2f\n", 
                          StatUtils.mean(times) / 1.0E06,
                          Math.sqrt( StatUtils.variance( times) ) / 1.0E06,
                          StatUtils.min(times) / 1.0E06, 
                          StatUtils.max(times) / 1.0E06);

    System.out.printf("Data(KB) Mean: %.0f, StdDev: %.0f, Min: %.0f, Max: %.0f", 
                          StatUtils.mean(sizes) / 1024,
                          Math.sqrt( StatUtils.variance( sizes) ) / 1024,
                          StatUtils.min(sizes) / 1024, 
                          StatUtils.max(sizes) / 1024);

  }

  private static byte[] generateRandomData() {
    double guassian = new Random().nextGaussian();
    int size = MEAN + (int) (guassian * STDEV);
    byte[] random = new byte[size];
    new Random().nextBytes(random);
         return random;
  }
}
</programlisting>
      </example>

      <para>When this example is executed using a FileBackedOutputStream that
      will only resort to a File-backed storage for 5% of requests, we get the
      following output which suggests a mean time to write data to the output
      stream of 0.71 ms. This means that the 2000 requests were processed in
      less than two seconds.</para>

      <screen>Time(ns) Mean: 0.71, StdDev: 6.52, Min: 0.11, Max: 177.96
Data(KB) Mean: 301, StdDev: 25, Min: 219, Max: 382</screen>

      <para>If we comment out the FileBackedOutputStream and we uncomment the
      lines that use a FileOutputStream to write data to a temporary output
      file, we get the following performance numbers which suggest a mean to
      write data to the output stream of 15.60 ms. This would translate to
      2000 requests being processed in about 31 seconds. </para>

      <screen>Time(ns) Mean: 15.60, StdDev: 52.11, Min: 0.49, Max: 560.65
Data(KB) Mean: 301, StdDev: 24, Min: 214, Max: 385</screen>

      <para>Now, wait, this is something of an unfair comparison. Much of this
      time is spent in the call to
      <methodname>File.createTempFile()</methodname>, and if you were going to
      implement such a system using files to store all of this data, you would
      likely reuse files to avoid paying the price creating a new file for
      each request. If you move the call to
      <methodname>createTimeFile()</methodname> out of the timing loop and
      reuse the same file for each of the 2000 operations, the performance
      numbers improve dramatically. We still pay almost 37% penalty versus the
      solution that uses the
      <classname>FileBackedOutputStream</classname>:</para>

      <screen>Time(ns) Mean: 1.12, StdDev: 4.47, Min: 0.34, Max: 136.99
Data(KB) Mean: 301, StdDev: 24, Min: 223, Max: 384</screen>

      <para>This is a simple, contrived example, but imagine that you are
      responsible for running a service that allows tens of millions of users
      to upload pictures to a web site at a rate of hundreds of images per
      second. This is exactly the sort of problem that this
      <classname>FileBackedOutputStream</classname> was designed to solve, and
      this example only measures a simple case involving a local disk. A more
      accurate test of the benefits of this class would also take into account
      the reduction in power consumption achieved by avoiding disk I/O and/or
      network I/O.</para>

      <note>
        <para>This is a contrived example which makes the assumption that
        image sizes would follow an ideal normal distribution. Given that most
        digital camera produce a set of discrete sizes, it is unlikely that
        images follow such a smooth distribution curve. Nevertheless, this
        example shows you how to measure and quantify the benefit of using a
        buffering OutputStream to store the majority of submissions in an
        in-memory byte array.</para>
      </note>
    </sect2>
  </sect1>

  <sect1 id="guava-io-sect-appending-text">
    <title>Appending Text to Files</title>

    <sect2>
      <title>Problem</title>

      <para>You need to append text to a file.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use <methodname>Files.append()</methodname> as shown in <xref
      linkend="guava-io-ex-appending" />. All you need to do to append text to
      a file is reference the file with an instance of File and pass in the
      <classname>CharSequence</classname> (in this case a
      <classname>String</classname>) to append and the character set to use to
      writing the text.</para>

      <example id="guava-io-ex-appending">
        <title>Appending Text to a File with Files.append()</title>

        <programlisting>package com.discursive.cjcook.guava.io;

import java.io.File;
import java.nio.charset.Charset;

import com.google.common.io.Files;

public class AppendingText {

  public static void main(String[] args) throws Exception {
    File outFile = new File("output2.txt");
    Files.append( "\nThis is a test", outFile, Charset.forName("UTF-8"));
  }
}
</programlisting>
      </example>

      <para>If you run the previous program twice, you should see a file named
      <filename>output2.txt</filename> containing two copies of the message
      appended above:</para>

      <screen>$ <command>cat output2.txt</command>

This is a test
This is a test</screen>
    </sect2>
  </sect1>

  <sect1 id="guava-io-sect-mkdir-p">
    <title>Create Parent Directories (mkdir -p for Java)</title>

    <sect2>
      <title>Problem</title>

      <para>Your applications need to create files nested within subdirectory
      which may or may not yet exist. </para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Create a <classname>File</classname> instance which references the
      full path of a file, and then pass that <classname>File</classname>
      object to <methodname>Files.createParentDirs()</methodname> as shown in
      <xref linkend="guava-io-ex-create-parent-dirs" />.</para>

      <example id="guava-io-ex-create-parent-dirs">
        <title>Creating Subdirectories with File.createParentDirs()</title>

        <programlisting>import java.io.File;
import com.google.common.io.Files;

File file = new File( "some/nested/directory/structure", "newFile.txt" );
Files.createParentDirs( file );</programlisting>
      </example>

      <para>The <methodname>createParentDirs()</methodname> method will then
      travserse these subdirectories and create new directories as needed.
      This feature has the same behavior as the unix command "mkdir
      -p".</para>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>If you've ever created a system which uses the file system to
      store data associated with a user request, you've probably learned about
      the limitations of various filesystems. Just because an ext3 file system
      can store up to 32000 subdirectories, it is rarely a good idea to store
      more than a few hundred files in a directory. Doing so often impacts
      performance of simple commands. To avoid these problems, you would
      usually store user data using a series of subdirectories to break up the
      data into smaller, more focused subdirectories.</para>

      <para>For example, if you were using the filesystem in a server-side
      system to store information about a user's profile, and each user were
      assigned a seven digit unique integer, you might use that identifier to
      create a series of subdirectories to store user data. Instead of storing
      all of your 150 million user accounts in the same directory, you would
      split them up into subdirectories. In other words, you wouldn't store
      some user data in /var/data/users/13243523.dat, you would likely take
      the first few digits and create subdirectories, using a path like
      /var/data/users/13/24/35/13243523.data which would limit each level to
      holding either one hundred subdirectories or one hundred files. Dealing
      with directories containing a hundred files is much easier than dealing
      with a directory which contains 150 millions files.</para>

      <para><xref linkend="guava-io-ex-scale-tmp-dirs" /> lists an example
      which can be used to create a series of directories to store data in a
      series of nested directories. In this example, the ability to call
      <methodname>Files.createParentDirs()</methodname> saves us from the
      effort of having to walk the directory tree and test for the presence of
      these subdirectories. </para>

      <example id="guava-io-ex-scale-tmp-dirs">
        <title>Creating Nested Subdirectories using Files.createParentDirs()
        </title>

        <programlisting>package com.discursive.cjcook.guava.io;

import java.io.File;
import java.util.Arrays;
import java.util.List;

import org.apache.commons.lang.RandomStringUtils;
import org.apache.commons.lang.StringUtils;

import com.google.common.io.Files;

public class ScaleableParentDirs {
  
  private static final Integer PATH_LENGTH = 5;
  private static final Integer NAME_LENGTH = 2;

  public static void main(String[] args) throws Exception {

    StringBuffer randomPath = new StringBuffer();
    for( int i = 0; i &lt; 5; i++) {
      randomPath.append( RandomStringUtils.randomAlphabetic(1).toLowerCase() );
      randomPath.append( File.separator );
    }
    String randomName = RandomStringUtils.randomAlphabetic(2).toLowerCase();
    File newFile = new File( randomPath.toString(), randomName + ".dat" );
    Files.createParentDirs( newFile );
    
    // Do whatever
  }

}
</programlisting>
      </example>
    </sect2>
  </sect1>

  <sect1 id="guava-io-sect-mktemp">
    <title>Make a Temporary Directory</title>

    <sect2>
      <title>Problem</title>

      <para></para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Files.createTempDir</para>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para></para>
    </sect2>
  </sect1>

  <sect1 id="guava-io-sect-del-contents">
    <title>Delete Everything in a Directory</title>

    <sect2>
      <title>Problem</title>

      <para></para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Files.deleteDirectoryContents</para>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para></para>
    </sect2>
  </sect1>

  <sect1 id="guava-io-sect-del-recurse">
    <title>Recursively Delete Everything in a Directory (including
    Subdirectories)</title>

    <sect2>
      <title>Problem</title>

      <para></para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Files.deleteRecursively</para>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para></para>
    </sect2>
  </sect1>

  <sect1 id="guava-io-sect-compare-files">
    <title>Compare Two Files for Equality</title>

    <sect2>
      <title>Problem</title>

      <para></para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Files.equal</para>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para></para>
    </sect2>
  </sect1>

  <sect1 id="guava-io-sect-sum-file">
    <title>Calculate the Checksum of a File</title>

    <sect2>
      <title>Problem</title>

      <para></para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Files.getChecksum</para>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para></para>
    </sect2>
  </sect1>

  <sect1 id="guava-io-sect-dig-file">
    <title>Calculate the Digest of a File</title>

    <sect2>
      <title>Problem</title>

      <para></para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Files.getDigest</para>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para></para>
    </sect2>
  </sect1>

  <sect1 id="guava-io-sect-map">
    <title>Map a File to Memory</title>

    <sect2>
      <title>Problem</title>

      <para></para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Files.map</para>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para></para>
    </sect2>
  </sect1>

  <sect1 id="guava-io-sect-move">
    <title>Move a File</title>

    <sect2>
      <title>Problem</title>

      <para></para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Files.move</para>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para></para>
    </sect2>
  </sect1>

  <sect1 id="guava-io-sect-create-streams">
    <title>Create New InputStreams and OutputStreams for a File</title>

    <sect2>
      <title>Problem</title>

      <para></para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Files.newInputStreamSupplier newOutputStreamSupplier</para>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para></para>
    </sect2>
  </sect1>

  <sect1 id="guava-io-sect-create-readers-writers">
    <title>Create New Readers and Writers for a File</title>

    <sect2>
      <title>Problem</title>

      <para></para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Files.newReader and Writer, ReaderSupplier and
      WriterSupplier</para>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para></para>
    </sect2>
  </sect1>

  <sect1 id="guava-io-sect-read-bytes">
    <title>Read Bytes from a File</title>

    <sect2>
      <title>Problem</title>

      <para></para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Files.readBytes</para>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para></para>
    </sect2>
  </sect1>

  <sect1 id="guava-io-sect-read-text">
    <title>Read Text from a File</title>

    <sect2>
      <title>Problem</title>

      <para></para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Files.readFirstLine, readLine</para>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para></para>
    </sect2>
  </sect1>

  <sect1 id="guava-io-sect-create-file">
    <title>Create a File</title>

    <sect2>
      <title>Problem</title>

      <para></para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Files.touch</para>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para></para>
    </sect2>
  </sect1>

  <sect1 id="guava-io-sect-overwrite-file">
    <title>Overwrite a File</title>

    <sect2>
      <title>Problem</title>

      <para></para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Files.write</para>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para></para>
    </sect2>
  </sect1>

  <sect1 id="guava-io-sect-convert-file-bytes">
    <title>Convert a File to a Byte Array</title>

    <sect2>
      <title>Problem</title>

      <para></para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Files.toByteArray</para>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para></para>
    </sect2>
  </sect1>

  <sect1 id="guava-io-sect-limit-stream">
    <title>Putting Limits on an InputStream</title>

    <sect2>
      <title>Problem</title>

      <para></para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>LimitInputStream</para>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para></para>
    </sect2>
  </sect1>

  <sect1 id="guava-io-sect-abyss">
    <title>Discarding Bytes into the Abyss</title>

    <sect2>
      <title>Problem</title>

      <para></para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>NullOutputStream</para>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para></para>
    </sect2>
  </sect1>

  <sect1 id="guava-io-sect-filter-regexp">
    <title>Filtering Files by Regular Expression</title>

    <sect2>
      <title>Problem</title>

      <para></para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>PatternFilenameFilter</para>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para></para>
    </sect2>
  </sect1>
</chapter>
