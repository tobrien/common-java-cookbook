<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<chapter id="functors" label="4">
  <title>Functors</title>

  <sect1 id="functors-sect-intro">
    <title>Introduction</title>

    <para>The American Heritage Dictionary defines a <filename
    moreinfo="none">functor</filename> <indexterm
        id="functors-ITERM-2290" significance="normal">
        <primary>functors</primary>
      </indexterm> as "one that performs an operation or a function," and, in
    the context of programming, a functor is an object that encapsulates
    "functional logic"—a functional object. So with a definition as abstract
    as "something that does stuff," you won't find a lot of satisfying,
    concise explanations of what a functor can do; in the abstract, anything
    that performs an operation or function could be considered a functor, and
    the process of drawing divisions between what should and should not be
    implemented with functors becomes a matter of personal preference. I'm not
    going to attempt to give a well-polished, textbook definition of a
    functor; this chapter simply demonstrates the set of basic functors from
    Commons Collections. Functors are less of an impressive new technology and
    are more of an approach to programming. Even if you are unfamiliar with
    the term, you've likely used functors without realizing it; two functors
    in common usage are <literal moreinfo="none">Comparator</literal> and
    <literal moreinfo="none">Iterator</literal>.</para>

    <para>Both <literal moreinfo="none">Comparator</literal> and <literal
    moreinfo="none">Iterator</literal> serve to isolate an algorithm; <literal
    moreinfo="none">Comparator</literal> encapsulates logic to compare two
    objects, and <literal moreinfo="none">Iterator</literal> encapsulates
    logic used to iterate over a collection of objects. Functors often lead to
    more code reuse and a cleaner design because functional logic can be
    abstracted and extracted out of logic dealing with a specific data
    structure. For example, to compare two <literal
    moreinfo="none">Person</literal> beans, you could make the <literal
    moreinfo="none">Person</literal> class implement <literal
    moreinfo="none">Comparable</literal> and provide a <literal
    moreinfo="none">compareTo()</literal> method in the <literal
    moreinfo="none">Person</literal> class, or you could write a <literal
    moreinfo="none">PersonComparator</literal>, separating the comparison
    logic from the <literal moreinfo="none">Person</literal> class. It is this
    separation of functional logic and the ability to combine functors
    together that make functors an interesting solution to a number of
    problems, from the creation of a <literal
    moreinfo="none">Closure</literal> pipeline to a series of <literal
    moreinfo="none">Predicate</literal> objects used to model a digital logic
    circuit.</para>

    <para>Jakarta Commons Collections 3.0 introduces a set of functor
    interfaces in the <literal
    moreinfo="none">org.apache.commons.collections</literal> package: <literal
    moreinfo="none">Predicate</literal>, <literal
    moreinfo="none">Transformer</literal>, <literal
    moreinfo="none">Factory</literal>, and <literal
    moreinfo="none">Closure</literal> objects. <literal
    moreinfo="none">Predicate</literal> objects evaluate criteria or
    conditions, returning a <literal moreinfo="none">boolean</literal> result.
    <literal moreinfo="none">Transformer</literal> objects create a new object
    based on an input object, <literal moreinfo="none">Closure</literal>
    objects act on an input object, and <literal
    moreinfo="none">Factory</literal> objects create objects. The powerful
    part of functors isn't that Commons Collections has introduced a few new
    interfaces—the power is only evident once you realize how they can be used
    in concert with other Jakarta Commons utilities such as Commons BeanUtils
    and Commons Collections. <link linkend="collections">Chapter
    5</link> makes heavy use of the functors introduced in this chapter, and
    <link linkend="beans">Chapter 3</link> discusses a <literal
    moreinfo="none">BeanComparator</literal> and a <literal
    moreinfo="none">BeanPredicate</literal>.</para>

    <para>This chapter focuses on the functors introduced in Commons
    Collections 3.0 and also deals with improvements to the <literal
    moreinfo="none">Comparator</literal> interface. Commons Collections
    introduces some improvements to the <literal
    moreinfo="none">Iterator</literal> interface, but, since people usually
    use <literal moreinfo="none">Iterator</literal> objects with <literal
    moreinfo="none">Collections</literal>, recipes involving <literal
    moreinfo="none">Iterator</literal> objects are in the next chapter, which
    covers Java Collections. Functors, part of Commons Collections, are
    somewhat misplaced, and, even as this chapter is written, a Commons
    Functor project is being finalized in the Jakarta Commons Sandbox. By the
    time you read this chapter, the Commons Functor project may have been
    released. This book assumes that you are using the functors available in
    the 3.0 release of Commons Collections. The Commons Functor release
    contains a number of changes and improvements to the set of functors
    introduced in Commons Collections 3.0, and, when possible, the See Also
    sections in each recipe discuss the relevant class or interface in the
    fast-developing Commons Functor project.</para>
  </sect1>

  <sect1 id="functors-sect-obtaining" label="4.1" role="Recipe">
    <title>Obtaining Commons Collections</title>

    <sect2>
      <title>Problem</title>

      <para>You need to use Jakarta <indexterm
          id="functors-ITERM-2291" significance="normal">
          <primary>Commons Collections</primary>

          <secondary>downloading</secondary>
        </indexterm> <indexterm id="functors-ITERM-2292"
          significance="normal">
          <primary>downloading</primary>

          <secondary>Commons Collections</secondary>
        </indexterm> <indexterm id="functors-ITERM-2293"
          significance="normal">
          <primary>functors</primary>

          <secondary>Commons Collections</secondary>

          <tertiary>downloading</tertiary>
        </indexterm>Commons Collections because your system could benefit from
      the various functor interfaces and implementations provided by this
      component.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>You must download the latest version of Commons Collections and
      place the Commons Collections JAR<filename moreinfo="none">
      </filename>in your project's classpath. Following the steps outlined in
      <link linkend="lang-sect-obtaining">Recipe 1.1</link>, download
      Commons Collections 3.0 instead of Commons Lang.</para>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>Commons Collections was introduced as a series of utilities that
      augment the Java Collections API. Commons Collections contains functors
      such as <literal moreinfo="none">Predicate</literal> and <literal
      moreinfo="none">Closure</literal>, utilities for filtering and selecting
      elements in a collection, and some new collections: <literal
      moreinfo="none">Bag</literal> and <literal
      moreinfo="none">Buffer</literal>. Commons Collections is as widely used
      as Commons BeanUtils and Commons Lang, and with these two projects, it
      forms the core of the Jakarta Commons components.</para>

      <para>If you have a Maven project that needs to use Commons Collections,
      add a dependency on Commons Collections 3.0 with the following section
      in <filename moreinfo="none">project.xml</filename>:</para>

      <programlisting format="linespecific" id="I_4_tt158">&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;id&gt;commons-collections&lt;/id&gt;
    &lt;version&gt;3.0&lt;/version&gt;
  &lt;/dependency&gt;

  ....other dependencies...
&lt;/dependencies&gt;</programlisting>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>For more information about the Commons Collections project, see
      the project page at <systemitem moreinfo="none"
      role="url">http://jakarta.apache.org/commons/collections</systemitem>.
      If you have questions about using Commons Collections, feel free to join
      the <systemitem moreinfo="none"
      role="url">commons-user@jakarta.apache.org</systemitem> mailing list.
      Instructions for joining the user mailing list can be found in <link
      linkend="jakartackbk-CHP-1-SECT-2">Recipe 1.2</link>. For information on
      obtaining the source code for Commons Collections, see <link
      linkend="functors-SECT-2">Recipe 4.2</link>.</para>
    </sect2>
  </sect1>

  <sect1 id="functors-sect-sourcecode" label="4.2" role="Recipe">
    <title>Getting the Commons Collections Source Code</title>

    <sect2>
      <title>Problem</title>

      <para>You need the source code for the<indexterm
          id="functors-ITERM-2294" significance="normal">
          <primary>Commons Collections</primary>

          <secondary>source code</secondary>
        </indexterm> <indexterm id="functors-ITERM-2295"
          significance="normal">
          <primary>source code</primary>

          <secondary>Commons Collections</secondary>
        </indexterm> <indexterm id="functors-ITERM-2296"
          significance="normal">
          <primary>functors</primary>

          <secondary>Commons Collections</secondary>

          <tertiary>source code</tertiary>
        </indexterm> <indexterm id="functors-ITERM-2297"
          significance="normal">
          <primary>code</primary>

          <secondary>Commons Collections</secondary>
        </indexterm> <indexterm id="functors-ITERM-2298"
          significance="normal">
          <primary>programming</primary>

          <secondary>Commons Collections</secondary>
        </indexterm> Commons Collections project.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Download the source from <systemitem moreinfo="none"
      role="url">http://jakarta.apache.org/site/sourceindex.cgi</systemitem>.
      Following the same procedure outlined in <link
      linkend="jakartackbk-CHP-1-SECT-3">Recipe 1.3</link>, download a file
      named <filename
      moreinfo="none">commons-collections-3.0-src.zip</filename> (or <filename
      moreinfo="none">commons-collections-3.0-src.tar.gz</filename>); once you
      unzip this archive, you will have the source to Commons Collections in
      <filename
      moreinfo="none">./commons-collections-3.0-src/src</filename>.</para>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>Most Commons components follow a similar convention for the layout
      of binary and source distributions. For more information about the
      layout of the Collections source distribution, see <link
      linkend="jakartackbk-CHP-1-SECT-3">Recipe 1.3</link>. For information on
      obtaining the binary distribution for Commons Collections, see <link
      linkend="functors-SECT-1">Recipe 4.1</link>.</para>
    </sect2>
  </sect1>

  <sect1 id="functors-sect-reversing" label="4.3" role="Recipe">
    <title>Reversing a Comparator</title>

    <sect2>
      <title>Problem</title>

      <para>You need to reverse the effects <indexterm class="startofrange"
          id="functors-ITERM-2299" significance="normal">
          <primary>functors</primary>

          <secondary>Comparators</secondary>

          <tertiary>reversing</tertiary>
        </indexterm> <indexterm class="startofrange"
          id="functors-ITERM-2300" significance="normal">
          <primary>reversing</primary>

          <secondary>Comparators</secondary>
        </indexterm> <indexterm class="startofrange"
          id="functors-ITERM-2301" significance="normal">
          <primary>Comparators</primary>

          <secondary>reversing</secondary>
        </indexterm>of a <literal moreinfo="none">Comparator</literal>. You
      need to return less than when this <literal
      moreinfo="none">Comparator</literal> returns greater than, and greater
      than when it returns less than.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use <literal moreinfo="none">ReverseComparator</literal>
      <indexterm id="functors-ITERM-2302" significance="normal">
          <primary>ReverseComparator</primary>
        </indexterm> to reverse the effects of a <literal
      moreinfo="none">Comparator</literal>. Supply an existing <literal
      moreinfo="none">Comparator</literal> to the constructor of <literal
      moreinfo="none">ReverseComparator</literal>, and it reverses the effects
      of that <literal moreinfo="none">Comparator</literal>. The following
      example demonstrates the use of <literal
      moreinfo="none">ReverseComparator</literal> to reverse the result of a
      custom <literal moreinfo="none">MyComparator</literal> instance:</para>

      <programlisting format="linespecific" id="I_4_tt159">Comparator myComparator = new MyComparator( );

<userinput moreinfo="none">Comparator reverseComparator = new ReverseComparator( myComparator );</userinput>

Book book1 = new Book( );
Book book2 = new Book( );

int comparison = myComparator.compare( book1, book2 );
<userinput moreinfo="none">int reversedComparison = reverseComparator( book1, book2);</userinput>
            </programlisting>

      <para>The value of <literal moreinfo="none">reversedComparison</literal>
      is simply the negative of <literal moreinfo="none">comparison</literal>;
      if <literal moreinfo="none">MyComparator</literal> decides that <literal
      moreinfo="none">book1</literal> is less than <literal
      moreinfo="none">book2</literal>, the <literal
      moreinfo="none">ReverseComparator</literal> returns the opposite
      result—greater than. <literal
      moreinfo="none">ReverseComparator</literal> simply wraps the original
      <literal moreinfo="none">Comparator</literal> and multiplies the result
      by negative one.</para>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para><link linkend="functors-EX-1">Example 4-1</link> is an
      implementation of a <literal moreinfo="none">Comparator</literal> that
      is reversed using the <literal
      moreinfo="none">ReverseComparator</literal>. This <literal
      moreinfo="none">BookComparator</literal> compares two <literal
      moreinfo="none">Book</literal> objects by the <literal
      moreinfo="none">name</literal> and <literal
      moreinfo="none">author</literal> bean properties. Sorting a list of
      books using this <literal moreinfo="none">Comparator</literal> results
      in a list sorted alphabetically by book name and author name; if two
      books have the same name, they are sorted by author name.</para>

      <example id="functors-EX-1" label="4-1">
        <title>A Comparator that compares Book objects by name and
        author</title>

        <programlisting format="linespecific">package com.discursive.jccook.collections.compare;

import java.util.*;
import org.apache.commons.lang.StringUtils;
import org.apache.commons.collections.comparators.ReverseComparator;

public class BookComparator implements Comparator {
    
    public int compare(Object o1, Object o2) {
         int comparison = -1;

        if( o1 instanceof Book &amp;&amp; o2 instanceof Book ) {
            Book b1 = (Book) o1;
            Book b2 = (Book) o2;
        
             String b1Name = b1.getName( );
             String b2Name = b2.getName( );

             String b1Author = b1.getAuthor( );
             String b2Author = b2.getAuthor( );

            if( StringUtils.isNotEmpty( b1Name ) &amp;&amp;
                StringUtils.isNotEmpty( b2Name ) ) {
                comparison = b1Name.compareTo( b2Name );
            }

            if( comparison == 0 &amp;&amp;
                StringUtils.isNotEmpty( b1Author ) &amp;&amp;
                StringUtils.isNotEmpty( b2Author ) ) {
                comparison = b1Author.compareTo( b2Author );
            }   
        }
        return comparison;
    }
}</programlisting>
      </example>

      <para><link linkend="functors-EX-2">Example 4-2</link> sorts an
      array of <literal moreinfo="none">Book</literal> objects in reverse
      order.</para>

      <example id="functors-EX-2" label="4-2">
        <title>Using ReverseComparator to sort Book objects</title>

        <programlisting format="linespecific">package com.discursive.jccook.collections.compare;

import java.util.*;
import org.apache.commons.collections.comparators.ReverseComparator;

public class ReverseExample {

    public static void main(String[] args) throws Exception {
        ReverseExample example = new ReverseExample( );
        example.start( );
    }
    
    public void start( ) throws Exception {

<userinput moreinfo="none">        // Create a Reversed BookComparator</userinput>
                  <userinput moreinfo="none">        Comparator bookCompare = new BookComparator( );</userinput>
                  <userinput moreinfo="none">        Comparator reverseComparator = new ReverseComparator( bookComparator );</userinput>

        // Create a List of Book objects
        List books = new ArrayList( );

        Book book1 = new Book( );
        book1.setName( "TitleA" );
        book1.setAuthor( "John" );
        books.add( book1 );

        Book book2 = new Book( );
        book2.setName( "TitleB" );
        book2.setAuthor( "Donald" );
        books.add( book2 )

        Book book3 = new Book( );
        book3.setName( "TitleA" );
        book3.setAuthor( "Doug" );
        books.add( book3 );

<userinput moreinfo="none">        // Sort the List of Book objects with the Reversed BookComparator</userinput>
                  <userinput moreinfo="none">        Collections.sort( books, reverseComparator );</userinput>

    }    
}</programlisting>
      </example>

      <para>After <literal moreinfo="none">Collections.sort( )</literal>, the
      <literal moreinfo="none">books</literal> array is sorted in reverse
      alphabetical order by book name and author name: "TitleB by Donald"
      followed by "TitleA by John" followed by "TitleA by Doug."</para>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>If you were using a simple <literal
      moreinfo="none">Comparator</literal> to sort an array, you could sort
      and reverse the resulting array with <literal
      moreinfo="none">Arrays.reverse( )</literal>, or you could reverse a
      <literal moreinfo="none">List</literal> with <literal
      moreinfo="none">Collections.reverse( )</literal>. Wrapping a <literal
      moreinfo="none">Comparator</literal> in <literal
      moreinfo="none">ReverseComparator</literal> may help you avoid the call
      to <literal moreinfo="none">reverse( )</literal>, but the benefit is
      miniscule. <literal moreinfo="none">ReverseComparator</literal> makes
      more sense when used in the context of a <literal
      moreinfo="none">ChainedComparator</literal>; see <link
      linkend="functors-SECT-4">Recipe 4.4</link> for more
      information about the <literal
      moreinfo="none">ChainedComparator</literal>.</para>

      <para>Note that use of <literal moreinfo="none">StringUtils.isNotEmpty(
      )</literal> is used in <literal moreinfo="none">BookComparator</literal>
      to check if either of the bean properties are null or blank. This
      utility,<indexterm class="endofrange" id="functors-ITERM-2303"
      significance="normal"
      startref="functors-ITERM-2299"></indexterm> <indexterm
      class="endofrange" id="functors-ITERM-2304"
      significance="normal"
      startref="functors-ITERM-2300"></indexterm> <indexterm
      class="endofrange" id="functors-ITERM-2305"
      significance="normal"
      startref="functors-ITERM-2301"></indexterm> is from <literal
      moreinfo="none">StringUtils</literal>, and it is introduced in <link
      linkend="manipulate-text-SECT-2">Recipe 2.2</link>.</para>
    </sect2>
  </sect1>

  <sect1 id="functors-sect-chaining" label="4.4" role="Recipe">
    <title>Chaining Comparators</title>

    <sect2>
      <title>Problem</title>

      <para>You need to sort a collection of objects by more<indexterm
          class="startofrange" id="functors-ITERM-2306"
          significance="normal">
          <primary>functors</primary>

          <secondary>Comparators</secondary>

          <tertiary>chaining</tertiary>
        </indexterm> <indexterm class="startofrange"
          id="functors-ITERM-2307" significance="normal">
          <primary>chaining</primary>

          <secondary>Comparators</secondary>
        </indexterm> <indexterm class="startofrange"
          id="functors-ITERM-2308" significance="normal">
          <primary>Comparators</primary>

          <secondary>chaining</secondary>
        </indexterm> than one property.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use <literal moreinfo="none">ComparatorChain</literal> <indexterm
          id="functors-ITERM-2309" significance="normal">
          <primary>ComparatorChain</primary>
        </indexterm> to create a series of <literal
      moreinfo="none">Comparator</literal> objects that appear as a single
      <literal moreinfo="none">Comparator</literal>. A <literal
      moreinfo="none">ComparatorChain</literal> compares two objects with each
      <literal moreinfo="none">Comparator</literal> in the chain until a
      <literal moreinfo="none">Comparator</literal> returns a nonzero value.
      If a <literal moreinfo="none">Comparator</literal> returns equality
      (zero), the <literal moreinfo="none">ComparatorChain</literal> then
      moves to the next <literal moreinfo="none">Comparator</literal> to
      obtain another comparison. The following example demonstrates the use of
      chained <literal moreinfo="none">BeanComparators</literal>; if two
      <literal moreinfo="none">Person</literal> objects have the same <literal
      moreinfo="none">lastName</literal>, the chain created in this example
      tries to compare the objects by <literal
      moreinfo="none">firstName</literal>:</para>

      <programlisting format="linespecific" id="I_4_tt160">Person person1 = new Person( );
person1.setLastName( "Payne" );
person1.setFirstName( "James" );
person1.setAge( 21 );

Person person2 = new Person( );
person2.setLastName( "Payne" );
person2.setFirstName( "James" );
person2.setAge( 85 );

Person person3 = new Person( );
person3.setLastName( "Payne" );
person3.setFirstName( "Susan" );
person3.setAge( 29 );

Person[] persons = new Person[] { person1, person2, person3 };

ComparatorChain comparatorChain = new ComparatorChain( );
comparatorChain.addComparator( new BeanComparator( "lastName" ) );
comparatorChain.addComparator( new BeanComparator( "firstName" ) );
comparatorChain.addComparator( new BeanComparator( "age" ), true );

Arrays.sort( persons, comparatorChain );</programlisting>

      <para>This example sorts an array of <literal
      moreinfo="none">Person</literal> objects: by <literal
      moreinfo="none">lastName</literal> ascending, <literal
      moreinfo="none">firstName</literal> ascending, and <literal
      moreinfo="none">age</literal> descending. The sorted <literal
      moreinfo="none">persons</literal> array will be in the following order:
      the older James Payne, the younger James Payne, followed by Susan Payne.
      The <literal moreinfo="none">ChainedComparator</literal> successfully
      sorts two objects with the same first and last names—falling back to the
      age to provide the correct sort order.</para>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>A <literal moreinfo="none">ComparatorChain</literal> evaluates
      every <literal moreinfo="none">Comparator</literal> in the chain as
      needed. If the current <literal moreinfo="none">Comparator</literal>
      returns a zero, the next <literal moreinfo="none">Comparator</literal>
      is invoked until there are no more <literal
      moreinfo="none">Comparator</literal> objects left in the chain. If the
      final <literal moreinfo="none">Comparator</literal> returns a zero
      value, the <literal moreinfo="none">ComparatorChain</literal> returns a
      zero. The <literal moreinfo="none">ComparatorChain</literal> implements
      the <literal moreinfo="none">Comparator</literal> interface and is an
      aggregate of other <literal moreinfo="none">Comparator</literal>
      objects; it can be used wherever a <literal
      moreinfo="none">Comparator</literal> is used, including array sorting
      and as a <literal moreinfo="none">Comparator</literal> for a tree-based
      <literal moreinfo="none">Collection</literal> implementation.</para>

      <para>The <literal moreinfo="none">ReverseComparator</literal>
      (introduced in <link linkend="functors-SECT-3">Recipe
      4.3</link>) makes more sense in light of the <literal
      moreinfo="none">ComparatorChain</literal>. If you need to sort a
      collection of objects for display, you might want to reverse a
      particular <literal moreinfo="none">Comparator</literal> in a <literal
      moreinfo="none">ComparatorChain</literal>. In the previous example,
      there are two people named "James Payne": one is 21 and the other is 85.
      Your application respects age and you want to put the older James Payne
      in front of the younger James Payne in the sorted list. Sorting by
      <literal moreinfo="none">lastName</literal> ascending, <literal
      moreinfo="none">firstName</literal> ascending, and <literal
      moreinfo="none">age</literal> descending calls for the last <literal
      moreinfo="none">Comparator</literal> in the chain to be reversed; the
      following code calls <literal moreinfo="none">addComparator( )</literal>
      with a second parameter, <literal moreinfo="none">true</literal>,
      causing the <literal moreinfo="none">BeanComparator</literal> for
      <literal moreinfo="none">age</literal> to be reversed with <literal
      moreinfo="none">ReverseComparator</literal>:</para>

      <programlisting format="linespecific" id="I_4_tt161">comparatorChain.addComparator( new BeanComparator( "age" ), true );</programlisting>

      <para>The previous statement is equivalent to the following code:</para>

      <programlisting format="linespecific" id="I_4_tt162">
comparaterChain.addComparator( new ReverseComparator
                               (new BeanComparator("age") );</programlisting>

      <para>Using a <literal moreinfo="none">ComparatorChain</literal> may
      remind you of the way a result set is sorted in a SQL <literal
      moreinfo="none">SELECT</literal> statement. This recipe's Solution
      implements the following SQL statement in a <literal
      moreinfo="none">ComparatorChain</literal>:</para>

      <programlisting format="linespecific" id="I_4_tt163">SELECT * FROM person ORDER BY lastName ASC, firstName ASC, age DESC;</programlisting>

      <sidebar id="functors-SIDEBAR-1">
        <title>Where to Sort?</title>

        <para>In many organizations, there is a debate over<indexterm
            id="functors-ITERM-2310" significance="normal">
            <primary>sorting</primary>

            <secondary>Comparators</secondary>
          </indexterm> where to sort data in an application: should sorting be
        done in the database or in an application server? The answer depends
        on a number of factors, but, now that you have seen how a <literal
        moreinfo="none">ComparatorChain</literal> works, you can implement
        <emphasis>any</emphasis> complex sort in Java. The use of a <literal
        moreinfo="none">ComparatorChain</literal> is especially relevant if
        you are writing a web application that presents a sortable table and
        you have decided to implement sorting logic in your presentation
        layer. If you are sorting beans, load your data into a collection and
        use a <literal moreinfo="none">ComparatorChain</literal> made up of
        <literal moreinfo="none">BeanComparators</literal>.</para>
      </sidebar>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>The <literal moreinfo="none">BeanComparator</literal> was
      introduced in the previous chapter; for more information, see <link
      linkend="beans-SECT-10">Recipe 3.10</link>. The <literal
      moreinfo="none">ReverseComparator</literal> <indexterm
      class="endofrange" id="functors-ITERM-2311"
      significance="normal"
      startref="functors-ITERM-2306"></indexterm> <indexterm
      class="endofrange" id="functors-ITERM-2312"
      significance="normal"
      startref="functors-ITERM-2307"></indexterm> <indexterm
      class="endofrange" id="functors-ITERM-2313"
      significance="normal"
      startref="functors-ITERM-2308"></indexterm> was introduced in
      <link linkend="functors-SECT-3">Recipe 4.3</link>.</para>
    </sect2>
  </sect1>

  <sect1 id="functors-sect-comparing-nulls" label="4.5" role="Recipe">
    <title>Comparing Nulls</title>

    <sect2>
      <title>Problem</title>

      <para>You need to sort an object array <indexterm
          id="functors-ITERM-2314" significance="normal">
          <primary>functors</primary>

          <secondary>nulls, comparing</secondary>
        </indexterm> <indexterm id="functors-ITERM-2315"
          significance="normal">
          <primary>nulls</primary>

          <secondary>comparing</secondary>
        </indexterm> <indexterm id="functors-ITERM-2316"
          significance="normal">
          <primary>comparing</primary>

          <secondary>nulls</secondary>
        </indexterm>that contains <literal moreinfo="none">null</literal>
      elements, and you want to have control over whether the <literal
      moreinfo="none">null</literal> values are at the beginning or end of a
      sorted array.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Wrap your <literal moreinfo="none">Comparator</literal> in a
      <literal moreinfo="none">NullComparator</literal> <indexterm
          id="functors-ITERM-2317" significance="normal">
          <primary>NullComparator</primary>
        </indexterm> <indexterm id="functors-ITERM-2318"
          significance="normal">
          <primary>Comparators</primary>

          <secondary>NullComparator</secondary>
        </indexterm> from Commons Collections. The <literal
      moreinfo="none">NullComparator</literal> can sort <literal
      moreinfo="none">null</literal> values higher or lower than non-<literal
      moreinfo="none">null</literal> values, depending on options passed into
      the constructor. The following example shows a custom <literal
      moreinfo="none">BookComparator</literal> wrapped with a <literal
      moreinfo="none">NullComparator</literal>:</para>

      <programlisting format="linespecific" id="I_4_tt164">import org.apache.commons.collections.comparators.NullComparator;
import java.util.*;

<userinput moreinfo="none">Comparator bookComparator = new BookComparator( );</userinput>
               <userinput moreinfo="none">Comparator nullComparator = new NullComparator( BookComparator );</userinput>

Book[] bookArray = new Book[] { new Book( ), null, new Book( ) };

Arrays.sort( bookArray, nullComparator );</programlisting>

      <para>This example sorts an array of <literal
      moreinfo="none">Book</literal> objects, placing <literal
      moreinfo="none">null</literal> at the end of the sorted array; after the
      sort, <literal moreinfo="none">bookArray</literal> contains two <literal
      moreinfo="none">Book</literal> objects at index zero and index one and a
      <literal moreinfo="none">null</literal> reference at index two.</para>

      <tip id="functors-NOTE-56" role="ora">
        <para>If a <literal moreinfo="none">Comparator</literal> does not
        handle <literal moreinfo="none">null</literal> values gracefully, wrap
        it in a <literal moreinfo="none">NullComparator</literal> and avoid a
        <literal moreinfo="none">NullPointerException</literal>.</para>
      </tip>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>To<indexterm id="functors-ITERM-2319"
          significance="normal">
          <primary>configuration</primary>

          <secondary>NullComparator</secondary>
        </indexterm> <indexterm id="functors-ITERM-2320"
          significance="normal">
          <primary>NullComparator</primary>

          <secondary>configuration</secondary>
        </indexterm> configure <literal
      moreinfo="none">NullComparator</literal> to sort <literal
      moreinfo="none">null</literal> values as less than non-<literal
      moreinfo="none">null</literal> values, pass <literal
      moreinfo="none">false</literal> to the constructor of <literal
      moreinfo="none">NullComparator</literal>; to sort <literal
      moreinfo="none">null</literal> values as greater than non-<literal
      moreinfo="none">null</literal> values, pass <literal
      moreinfo="none">true</literal>. By default, <literal
      moreinfo="none">null</literal> values are sorted higher:</para>

      <programlisting format="linespecific" id="I_4_tt165">// null is less than non-null
Comparator nullComparator = new NullComparator( bookComparator, false );

// null is greater than non-null (default)
Comparator nullComparator = new NullComparator( bookComparator, true );</programlisting>

      <para>While the <literal moreinfo="none">NullComparator</literal>
      usually decorates another instance of <literal
      moreinfo="none">Comparator</literal>, the <literal
      moreinfo="none">NullComparator</literal> can also be used by itself to
      compare <literal moreinfo="none">null</literal> and non-<literal
      moreinfo="none">null</literal> objects, as in the following
      example:</para>

      <programlisting format="linespecific" id="I_4_tt166">Comparator nullHighComparator = new NullComparator( );
Comparator nullLowComparator = new NullComparator(false);

// Returns 1
nullHighComparator.compare( null, new Double(3.0) );

// Returns -1
nullLowComparator.compare( null, new Double(3.0) );

// Returns 0
nullLowComparator.compare( null, null );</programlisting>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>Both <literal moreinfo="none">ReverseComparator</literal> and
      <literal moreinfo="none">NullComparator</literal> are objects that
      decorate an existing <literal moreinfo="none">Comparator</literal>. Take
      note of the decorator pattern as it is a common pattern used throughout
      Commons Collections. For more information about the decorator design
      pattern, read <emphasis>Design Patterns: Elements of Reusable
      Object-Oriented Software</emphasis> (Addison Wesley).</para>
    </sect2>
  </sect1>

  <sect1 id="functors-sect-fixed-order" label="4.6" role="Recipe">
    <title>Fixed-Order Comparison</title>

    <sect2>
      <title>Problem</title>

      <para>You need to sort a collection <indexterm class="startofrange"
          id="functors-ITERM-2321" significance="normal">
          <primary>functors</primary>

          <secondary>fixed order comparisons</secondary>
        </indexterm> <indexterm class="startofrange"
          id="functors-ITERM-2322" significance="normal">
          <primary>fixed order comparisons</primary>
        </indexterm> <indexterm class="startofrange"
          id="functors-ITERM-2323" significance="normal">
          <primary>comparing</primary>

          <secondary>fixed order comparisons</secondary>
        </indexterm> <indexterm class="startofrange"
          id="functors-ITERM-2324" significance="normal">
          <primary>Commons Collections</primary>

          <secondary>FixedOrderComparator</secondary>
        </indexterm> <indexterm class="startofrange"
          id="functors-ITERM-2325" significance="normal">
          <primary>Comparators</primary>

          <secondary>FixedOrderComparator</secondary>
        </indexterm>of objects that have a preestablished order, such as the
      days of the week or the order of planets in the solar system.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use <literal moreinfo="none">FixedOrderComparator</literal> in
      Jakarta Commons Collections. When using <literal
      moreinfo="none">FixedOrderComparator</literal>, you supply an array of
      objects in a sorted order and the <literal
      moreinfo="none">Comparator</literal> returns comparison results based on
      the order of the objects in this array. The following example uses a
      fixed string array to compare different Olympic medals:</para>

      <programlisting format="linespecific" id="I_4_tt167">import java.util.*;
import org.apache.commons.beanutils.BeanComparator;
import org.apache.commons.collections.comparators.FixedOrderComparator;

String[] medalOrder = {"tin", "bronze", "silver", "gold", "platinum"};

Comparator medalComparator = new FixedOrderComparator( medalOrder );
Comparator athleteComparator = new BeanComparator( "medal", medalComparator );

Athlete athlete1 = new Athlete( );
Athlete athlete2 = new Athlete( );

int compare = medalComparator.compare( athlete1.getMedal( ), 
athlete2.getMedal( ) );</programlisting>

      <para>In this code, a <literal
      moreinfo="none">FixedOrderComparator</literal> compares two <literal
      moreinfo="none">Athletes</literal> by the value of the <literal
      moreinfo="none">medal</literal> property. The <literal
      moreinfo="none">medal</literal> property can be "tin," "bronze,"
      "silver," "gold," or "platinum," and a <literal
      moreinfo="none">FixedOrderComparator</literal> uses the order of the
      <literal moreinfo="none">medalOrder</literal> array to compare these
      values. The <literal moreinfo="none">medalOrder</literal> array
      establishes a fixed relationship between the three medal types; "bronze"
      is less than "silver," which is less than "gold."</para>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>Use <literal moreinfo="none">FixedOrderComparator</literal> when
      sorting an array or a collection that contains values that are ordered
      in a pre-determined fashion: days of the week, planets in the solar
      system, colors in the spectrum, or hands dealt in a poker game. One way
      to sort an array containing the days of the week would be to assign a
      numerical value to each day—"Monday" is one, "Tuesday" is two,
      "Wednesday" is three, etc. Then you could sort the array with a <literal
      moreinfo="none">Comparator</literal> that takes each day's name, sorting
      elements based on the numerical value corresponding to a day's name. An
      alternative is the use of <literal
      moreinfo="none">FixedOrderComparator</literal>, letting the comparator
      order objects based on the order of an array of day names.</para>

      <para>If a bean contains a property to be sorted according to a
      fixed-order array, you can use the <literal
      moreinfo="none">BeanComparator</literal> in conjunction with <literal
      moreinfo="none">FixedOrderComparator</literal>. The following example
      sorts cards by value and suit using a <literal
      moreinfo="none">FixedOrderComparator</literal> and a <literal
      moreinfo="none">BeanComparator</literal>; A <literal
      moreinfo="none">PlayingCard</literal> object, defined in <link
      linkend="functors-EX-3">Example 4-3</link>, is sorted according
      to the order of two arrays—one for the face value of the <literal
      moreinfo="none">PlayingCard</literal> and one for the suit of the
      <literal moreinfo="none">PlayingCard</literal>.</para>

      <example id="functors-EX-3" label="4-3">
        <title>A bean representing a playing card</title>

        <programlisting format="linespecific">package org.discursive.jccook.collections.compare;

public class PlayingCard( ) {

    public static String JOKER_VALUE = null;
    public static String JOKER_SUIT = null;

    private String value;
    private String suit;

    public PlayingCard( ) {}
    public PlayingCard(String value, String suit) {
        this.value = value;
        this.suit = suit;
    }

    public String getValue( ) { return value; }
    public void setValue(String value) { this.value = value; }

    public String getSuit( ) { return suit; }
    public void setSuit(String suit) { this.suit = suit; }

    public String toString( ) {
        String cardString = "JOKER";
        if( value != null &amp;&amp; suit != null ) {
            cardString = value + suit;
        }
        return cardString;
    }
}</programlisting>
      </example>

      <para><link linkend="functors-EX-4">Example 4-4</link> creates
      a <literal moreinfo="none">ComparatorChain</literal> of <literal
      moreinfo="none">BeanComparators</literal>, which compares the <literal
      moreinfo="none">value</literal> and <literal
      moreinfo="none">suit</literal> properties using a <literal
      moreinfo="none">FixedOrderComparator</literal>. Each card's suit is
      compared first, and, if two cards have the same suit, they are compared
      by face value. Jokers do not have suits or a face value, and this
      example handles jokers with a <literal
      moreinfo="none">null</literal>-valued <literal
      moreinfo="none">suit</literal> and <literal
      moreinfo="none">value</literal> property by wrapping each <literal
      moreinfo="none">FixedOrderComparator</literal> with a <literal
      moreinfo="none">NullComparator</literal>.</para>

      <example id="functors-EX-4" label="4-4">
        <title>Combining FixedOrderComparator with BeanComparator,
        NullComparator, and ComparatorChain</title>

        <programlisting format="linespecific">package com.discursive.jccook.collections.compare;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;

import org.apache.commons.beanutils.BeanComparator;

import org.apache.commons.collections.comparators.NullComparator;
import org.apache.commons.collections.comparators.FixedOrderComparator;
import org.apache.commons.collections.comparators.ComparatorChain;

public class FixedOrderExample {

    // Suit order "Spades", "Clubs", "Diamonds", "Hearts"
    private String[] suitOrder = { "S", "C", "D", "H" };

    private String[] valueOrder = { "2", "3", "4", "5", "6", "7", "8", 
                                    "9", "10", "J", "Q", "K", "A" };

    public static void main(String[] args) {
        FixedOrderExample example = new FixedOrderExample( );
        example.start( );
    }

    public void start( ) {

        List cards = new ArrayList( );
        cards.add( PlayingCard( "J", "C" ) );
        cards.add( PlayingCard( "2", "H" ) );
        cards.add( PlayingCard( PlayingCard.JOKER_VALUE, PlayingCard.
        JOKER_SUIT));
        cards.add( PlayingCard( "2", "S" ) );
        cards.add( PlayingCard( "Q", "S" ) );
        cards.add( PlayingCard( "4", "C" ) );
        cards.add( PlayingCard( "J", "D" ) );

         System.out.println( "Before sorting: " + printCards( cards ) );

        // Create a null-safe suit order comparator that will compare the
        // suit property of two Java beans
        Comparator suitComparator = new FixedOrderComparator( suitOrder );
        suitComparator = new NullComparator( suitComparator );
        suitComparator = new BeanComparator( "suit", suitComparator );

        // Create a null-safe value order comparator that will compare the
        // value property of two Java beans
        Comparator valueComparator = new FixedOrderComparator( valueOrder );
        valueComparator = new NullComparator( valueComparator );
        valueComparator = new BeanComparator( "value", valueComparator );

<userinput moreinfo="none">        // Create a chain of comparators to sort a deck of cards</userinput>
                  <userinput moreinfo="none">        Comparator cardComparator = new ComparatorChain( );</userinput>
                  <userinput moreinfo="none">        cardComparator.addComparator( suitComparator );</userinput>
                  <userinput moreinfo="none">        cardComparator.addComparator( valueComparator );</userinput>

                  <userinput moreinfo="none">        Collections.sort( cards, cardComparator );</userinput>

            System.out.println( "After sorting: " + printCards( cards ) );
    }

    private String printCards( List cards ) {
        StringBuffer resultBuffer = new StringBuffer( );
        Iterator cardIter = cards.iterator( );
        while( cardIter.hasNext( ) ) {
           PlayingCard card = (PlayingCard) cards.next( );
           resultBuffer.append( " " + card.toString( ) );
        }
        return resultBuffer.toString( );
    }
}</programlisting>
      </example>

      <para>This example sorts the <literal
      moreinfo="none">PlayingCard</literal> objects and produces the following
      output:</para>

      <programlisting format="linespecific" id="I_4_tt168">Before sorting: JC 2H JOKER 2S QS 4C JD
After sorting: 2S QS 4C JC JD 2H JOKER</programlisting>

      <para>The list is sorted such that all the cards of a similar suit are
      grouped together—spades are less than clubs, clubs are less than
      diamonds, and diamonds are less than hearts. A sorted collection of
      cards is grouped by suits, and, within each suit, cards are organized
      according to face value—2 is low and aces is high. The order used in the
      sorting is captured in two fixed-order arrays, <literal
      moreinfo="none">suitOrder</literal> and <literal
      moreinfo="none">faceOrder</literal>. If a shuffled deck were used in the
      example, it would end up as a perfectly sorted deck of cards.</para>

      <para><link linkend="functors-EX-4">Example 4-4</link> ties a
      number of simple <literal moreinfo="none">Comparators</literal> together
      to perform a fairly complex sort. A <literal
      moreinfo="none">FixedOrderComparator</literal> is wrapped in a <literal
      moreinfo="none">NullComparator</literal>, which is then wrapped with a
      <literal moreinfo="none">BeanComparator</literal>. These <literal
      moreinfo="none">BeanComparator</literal> instances are then combined in
      a <literal moreinfo="none">ComparatorChain</literal>. The use of
      <literal moreinfo="none">NullComparator</literal> with a <literal
      moreinfo="none">BeanComparator</literal> is recommended to avoid a
      <literal moreinfo="none">NullPointerException</literal> from <literal
      moreinfo="none">BeanComparator</literal>; <literal
      moreinfo="none">BeanComparator</literal> is not designed to handle
      <literal moreinfo="none">null</literal>-valued bean properties, and it
      throws an exception if you ask it to play nice with <literal
      moreinfo="none">null</literal>s.</para>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para><literal moreinfo="none">BeanComparator</literal> is discussed in
      <link linkend="beans-SECT-10">Recipe 3.10</link>. This
      helpful utility is indispensable if you are working with systems that
      need to sort JavaBeans.</para>

      <para>For more information about the <literal
      moreinfo="none">ComparatorChain</literal> <indexterm class="endofrange"
      id="functors-ITERM-2326" significance="normal"
      startref="functors-ITERM-2321"></indexterm> <indexterm
      class="endofrange" id="functors-ITERM-2327"
      significance="normal"
      startref="functors-ITERM-2322"></indexterm> <indexterm
      class="endofrange" id="functors-ITERM-2328"
      significance="normal"
      startref="functors-ITERM-2323"></indexterm> <indexterm
      class="endofrange" id="functors-ITERM-2329"
      significance="normal"
      startref="functors-ITERM-2324"></indexterm> <indexterm
      class="endofrange" id="functors-ITERM-2330"
      significance="normal"
      startref="functors-ITERM-2325"></indexterm>object, see <link
      linkend="functors-SECT-4">Recipe 4.4</link>. For more
      information on the <literal moreinfo="none">NullComparator</literal>,
      see <link linkend="functors-SECT-5">Recipe 4.5</link>.</para>
    </sect2>
  </sect1>

  <sect1 id="functors-sect-simple-pred" label="4.7" role="Recipe">
    <title>Using Simple Predicates</title>

    <sect2>
      <title>Problem</title>

      <para>You need to perform logic that is predicated <indexterm
          class="startofrange" id="functors-ITERM-2331"
          significance="normal">
          <primary>functors</primary>

          <secondary>predicates</secondary>
        </indexterm> <indexterm class="startofrange"
          id="functors-ITERM-2332" significance="normal">
          <primary>Commons Collections</primary>

          <secondary>predicates</secondary>
        </indexterm> <indexterm class="startofrange"
          id="functors-ITERM-2333" significance="normal">
          <primary>predicates</primary>

          <secondary>Commons Collections</secondary>
        </indexterm>on a certain condition being satisfied, and you want to
      encapsulate this condition in an object.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use a <literal moreinfo="none">Predicate</literal> to evaluate a
      criteria or a condition. A <literal moreinfo="none">Predicate</literal>
      is an object that evaluates another object and returns <literal
      moreinfo="none">true</literal> or <literal
      moreinfo="none">false</literal>; predicates are used throughout the
      Commons Collections packages for filtering, selecting, and validating
      the contents of collections. This code demonstrates the use of simple
      predicates to test the type and contents of an object:</para>

      <programlisting format="linespecific" id="I_4_tt169">import org.apache.commons.collection.Predicate;
import org.apache.commons.collection.functors.*;

String name = "Tim";

Predicate nameJohn = new EqualPredicate( "John" );
Predicate nameTim = new EqualPredicate( "Tim" );

Predicate instanceString = new InstanceofPredicate( String.class );
Predicate instanceDouble = new InstanceofPredicate( Double.class );

// Testing all predicates for "Tim"
System.out.println( "Is Name John?: " + nameJohn.evaluate( name ) );
System.out.println( "Is Name Tim?: " + nameTim.evaluate( name ) );
System.out.println( "Is this a String?: " + instanceString.evaluate( name ) );
System.out.println( "Is this a Double?: " + instanceDouble.evaluate( name ) );</programlisting>

      <para>The previous example tests the <literal
      moreinfo="none">name</literal> object against a few <literal
      moreinfo="none">Predicate</literal> implementations producing the
      following console output:</para>

      <programlisting format="linespecific" id="I_4_tt170">Is Name John?: false
Is Name Tim?: true
Is this a String?: true
Is this a Double?: false</programlisting>

      <para>The string "Tim" is subjected to various <literal
      moreinfo="none">Predicate</literal> tests. The first two <literal
      moreinfo="none">EqualPredicate</literal> objects test the contents of
      the string, returning <literal moreinfo="none">true</literal> if the
      object being evaluated is equal to the object passed into the <literal
      moreinfo="none">EqualPredicate</literal>'s constructor. The last two
      <literal moreinfo="none">Predicate</literal> objects are <literal
      moreinfo="none">InstanceofPredicate</literal> instances, which test the
      type of object being evaluated; if an <literal
      moreinfo="none">InstanceofPredicate</literal> constructor is passed to
      the <literal moreinfo="none">String</literal> class, it returns <literal
      moreinfo="none">true</literal> if the object being evaluated is a
      <literal moreinfo="none">java.lang.String</literal> type.</para>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>The simple <literal moreinfo="none">Predicate</literal> interface
      is central to a number of utilities introduced in this chapter. To
      implement <literal moreinfo="none">Predicate</literal>, define an
      <literal moreinfo="none">evaluate()</literal> method that returns a
      <literal moreinfo="none">boolean</literal>; a <literal
      moreinfo="none">Predicate</literal> is a function object (or functor)
      that captures a criteria in an object that can be created and altered at
      runtime. Creating and evaluating a <literal
      moreinfo="none">Predicate</literal> is just as valid as writing an
      <literal moreinfo="none">if</literal> statement; for example, the code
      in the Solution of this recipe could have been implemented as a series
      of <literal moreinfo="none">if</literal> statements:</para>

      <programlisting format="linespecific" id="I_4_tt171">String name = "Tim";

if( name.equals( "John" ) ) {
        System.out.println( "The name is John." );
}

if( name.equals( "Tim" ) ) {
        System.out.println( "The name is Tim." );
}

if( name instanceof String ) ) {
        System.out.println( "name is as String object" );
}

if( name instanceof Double ) ) {
        System.out.println( "name is as Double object" );
}</programlisting>

      <para><literal moreinfo="none">Predicate</literal> instances capture an
      <literal moreinfo="none">if</literal> statement in an object, and if you
      are going to constantly change the behavior of your application, you
      might want to consider placing conditional expressions in <literal
      moreinfo="none">Predicate</literal> instances. For example, if a system
      is designed to classify a storm as being a hurricane, you may want to
      capture all of your classification criteria in an XML file—parsing this
      file at runtime and creating a series of <literal
      moreinfo="none">Predicate</literal> objects. A storm is a hurricane when
      the winds exceed a certain value, and the barometric pressure falls
      below a certain point. But, in a few years those criteria might change
      to involve a new, or more complex, set of measurements. If your decision
      logic is encapsulated in a <literal moreinfo="none">Predicate</literal>
      object, it will be easier to upgrade the program to take new criteria
      into account; all of this logic will be encapsulated in an instance of
      <literal moreinfo="none">Predicate</literal>.</para>

      <para>Commons Collections provides a number of basic predicates for
      common situations, such as testing to see if an object equals another
      object (<literal moreinfo="none">EqualPredicate</literal>), or that an
      object is of a certain type (<literal
      moreinfo="none">InstanceofPredicate</literal>). <link
      linkend="functors-TABLE-1">Table 4-1</link> lists a number of
      simple <literal moreinfo="none">Predicate</literal>
      implementations.</para>

      <table id="functors-TABLE-1" label="4-1">
        <title>Predicate implementations</title>

        <indexterm id="functors-ITERM-2334" significance="normal">
          <primary>implementation</primary>

          <secondary>predicates</secondary>
        </indexterm>

        <tgroup cols="2">
          <colspec colname="col1" colnum="1" />

          <colspec colname="col2" colnum="2" />

          <thead>
            <row>
              <entry><para>Name</para></entry>

              <entry><para>Description</para></entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><para> <literal moreinfo="none">EqualPredicate</literal>
              </para></entry>

              <entry><para>Compares each object to an object passed via a
              constructor—returning true if the two are equal.</para></entry>
            </row>

            <row>
              <entry><para> <literal
              moreinfo="none">IdentityPredicate</literal> </para></entry>

              <entry><para>Returns true if the object being evaluated is the
              same object reference as the object passed to its constructor.
              The <literal moreinfo="none">IdentityPredicate</literal> uses
              the <literal moreinfo="none">==</literal> operator to compare
              two object references.</para></entry>
            </row>

            <row>
              <entry><para> <literal moreinfo="none">NotPredicate</literal>
              </para></entry>

              <entry><para>Wraps a <literal
              moreinfo="none">Predicate</literal> and returns the opposite
              result.</para></entry>
            </row>

            <row>
              <entry><para> <literal
              moreinfo="none">InstanceOfPredicate</literal> </para></entry>

              <entry><para>Returns <literal moreinfo="none">true</literal> if
              the object being evaluated matches the type passed into its
              constructor.</para></entry>
            </row>

            <row>
              <entry><para> <literal
              moreinfo="none">NullPredicateNullIsTruePredicate</literal>
              </para></entry>

              <entry><para>Returns true if the object being evaluated is
              <literal moreinfo="none">null</literal>.</para></entry>
            </row>

            <row>
              <entry><para> <literal
              moreinfo="none">NotNullPredicateNullIsFalsePredicate</literal>
              </para></entry>

              <entry><para>Returns true if the object being evaluated is not
              <literal moreinfo="none">null</literal>.</para></entry>
            </row>

            <row>
              <entry><para> <literal moreinfo="none">TruePredicate</literal>
              </para></entry>

              <entry><para>Always returns <literal
              moreinfo="none">true</literal>.</para></entry>
            </row>

            <row>
              <entry><para> <literal moreinfo="none">FalsePredicate</literal>
              </para></entry>

              <entry><para>Always returns <literal
              moreinfo="none">false</literal>.</para></entry>
            </row>

            <row>
              <entry><para> <literal moreinfo="none">UniquePredicate</literal>
              </para></entry>

              <entry><para>Returns <literal moreinfo="none">true</literal> if
              it is the first time a particular object has been evaluated. The
              <literal moreinfo="none">UniquePredicate</literal> maintains a
              <literal moreinfo="none">HashSet</literal> of objects it has
              evaluated; if an object is already in that <literal
              moreinfo="none">HashSet</literal>, this <literal
              moreinfo="none">Predicate</literal> returns <literal
              moreinfo="none">false</literal>. <literal
              moreinfo="none">UniquePredicate</literal> can be used to select
              distinct objects from a collection.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>The following example demonstrates simple<indexterm
          id="functors-ITERM-2335" significance="normal">
          <primary>objects</primary>

          <secondary>predicates</secondary>
        </indexterm> <literal moreinfo="none">Predicate</literal> objects with
      a test for equality, inequality, and equality by identity:</para>

      <programlisting format="linespecific" id="I_4_tt172">import org.apache.commons.collections.Predicate;
import org.apache.commons.collections.functors.*;
...

String testName = "Ben";

Predicate equals = new EqualPredicate( testName );
Predicate notEquals = new NotPredicate( equals );
Predicate identity = new IdentityPredicate( testName );

System.out.println( "Does name equal 'Ben'? " + equals.evaluate( "Ben" ) );
System.out.println( "Is object 'Ben'? " + identity.evaluate( testName ) );
System.out.println( "Does name equal 'Tim'? " + equals.evaluate( "Tim" ) );
System.out.println( "Does name not equal 'Tim'? " + notEquals.
evaluate( "Tim" ) );
System.out.println( "Is object 'Tim'? " + identity.evaluate( "Tim" ) );</programlisting>

      <para>This code demonstrates the use of <literal
      moreinfo="none">Predicate</literal> objects to determine if objects are
      equal or if two object references reference the same instance. When
      executed, the following is output to the console:</para>

      <programlisting format="linespecific" id="I_4_tt173">Does name equal 'Ben'? true
Is object 'Ben'? true
Does name equal 'Tim'? false
Does name not equal 'Tim'? true
Is object 'Tim'? false</programlisting>

      <para>The following code demonstrates simple predicates that test for
      the presence or absence of <literal moreinfo="none">null</literal> or if
      an object being evaluated is of a certain type. The example also
      demonstrates the use of a <literal
      moreinfo="none">UniquePredicate</literal> that returns <literal
      moreinfo="none">true</literal> when it encounters an object for the
      first time:</para>

      <programlisting format="linespecific" id="I_4_tt174">import org.apache.commons.collections.Predicate;
import org.apache.commons.collections.functors.*;

String nullString = null;
Double testDouble = new Double(3.4);

Predicate isString = new InstanceofPredicate( String.class );
Predicate isLong = new InstanceofPredicate( Long.class );
Predicate isNumber = new InstanceofPredicate( Number.class );

Predicate isNotNull = NotNullPredicate.INSTANCE;
Predicate isNull = NullPredicate.INSTANCE;

Predicate unique = new UniquePredicate( );

System.out.println("'nullString' not null?: " + isNotNull.
evaluate(nullString));
System.out.println("'nullString' null?: " + isNull.evaluate(nullString));

System.out.println("'testDouble' a String?: " + isString.
evaluate(testDouble));
System.out.println("'testDouble' a Long?: " + isLong.evaluate(testDouble));
System.out.println("'testDouble' a Number?: " + isNumber.
evaluate(testDouble));

System.out.println("'A' Unique?: " + unique.evaluate("A"));
System.out.println("'C' Unique?: " + unique.evaluate("C"));
System.out.println("'A' Unique?: " + unique.evaluate("A"));
System.out.println("'B' Unique?: " + unique.evaluate("B"));</programlisting>

      <para>The sample evaluates objects against the <literal
      moreinfo="none">InstanceofPredicate</literal>, the <literal
      moreinfo="none">NullPredicate</literal>, the <literal
      moreinfo="none">NotNullPredicate</literal>, and the <literal
      moreinfo="none">UniquePredicate</literal>, and the following is output
      to the console:</para>

      <programlisting format="linespecific" id="I_4_tt175">'nullString' not null?: false
'nullString' null?: true

'testDouble' a String?: false
'testDouble' a Long?: false
'testDouble' a Number?: true

'A' Unique?: true
'C' Unique?: true
'A' Unique?: false
'B' Unique?: true</programlisting>

      <para>The <literal moreinfo="none">UniquePredicate</literal> returns
      <literal moreinfo="none">false</literal> the second time it encounters
      "A." The <literal moreinfo="none">Double</literal> object <literal
      moreinfo="none">testDouble</literal> is shown to be a <literal
      moreinfo="none">Number</literal> object, and the <literal
      moreinfo="none">nullString</literal> is evaluated as non-<literal
      moreinfo="none">null</literal>.</para>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>This recipe mentions function pointers in C and C++. Function
      pointers are pointers to the address of a function, and they allow for
      some interesting logical acrobatics. For more information about function
      pointers in C and C++, see <systemitem moreinfo="none"
      role="url">http://www.function-pointer.org/</systemitem>.</para>

      <para><literal moreinfo="none">Predicate</literal>, <literal
      moreinfo="none">Closure</literal>, and <literal
      moreinfo="none">Transformer</literal> are all functor objects that are
      used throughout the Commons Collections component. You may be familiar
      with functors if you have used the Standard Template Library (STL) in
      C++. STL documentation contains rigorous definitions for function
      objects and<indexterm class="endofrange"
      id="functors-ITERM-2336" significance="normal"
      startref="functors-ITERM-2331"></indexterm> <indexterm
      class="endofrange" id="functors-ITERM-2337"
      significance="normal"
      startref="functors-ITERM-2332"></indexterm> <indexterm
      class="endofrange" id="functors-ITERM-2338"
      significance="normal"
      startref="functors-ITERM-2333"></indexterm> predicates. For
      more information about functors in STL, see <systemitem moreinfo="none"
      role="url">http://www.sgi.com/tech/stl/functors.html</systemitem>.</para>
    </sect2>
  </sect1>

  <sect1 id="functors-sect-writing-custom-pred" label="4.8" role="Recipe">
    <title>Writing a Custom Predicate</title>

    <sect2>
      <title>Problem</title>

      <para>You need to evaluate an<indexterm class="startofrange"
          id="functors-ITERM-2339" significance="normal">
          <primary>functors</primary>

          <secondary>predicates</secondary>

          <tertiary>customization</tertiary>
        </indexterm> <indexterm class="startofrange"
          id="functors-ITERM-2340" significance="normal">
          <primary>Commons Collections</primary>

          <secondary>predicates</secondary>

          <tertiary>customization</tertiary>
        </indexterm> <indexterm class="startofrange"
          id="functors-ITERM-2341" significance="normal">
          <primary>predicates</primary>

          <secondary>Commons Collections</secondary>

          <tertiary>customization</tertiary>
        </indexterm> <indexterm class="startofrange"
          id="functors-ITERM-2342" significance="normal">
          <primary>customization</primary>

          <secondary>predicates</secondary>
        </indexterm> <indexterm class="startofrange"
          id="functors-ITERM-2343" significance="normal">
          <primary>interfaces</primary>

          <secondary>Predicate</secondary>
        </indexterm> <indexterm class="startofrange"
          id="functors-ITERM-2344" significance="normal">
          <primary>implementation</primary>

          <secondary>Predicate interface</secondary>
        </indexterm> object to see if it meets criteria, and you want to
      capture these criteria in a custom <literal
      moreinfo="none">Predicate</literal>.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Implement the <literal moreinfo="none">Predicate</literal>
      interface and capture your logic in an <literal
      moreinfo="none">evaluate( )</literal> <indexterm
          id="functors-ITERM-2345" significance="normal">
          <primary>evaluate( ) method</primary>
        </indexterm> <indexterm id="functors-ITERM-2346"
          significance="normal">
          <primary>methods</primary>

          <secondary>evaluate( )</secondary>
        </indexterm> method. <link linkend="functors-EX-5">Example
      4-5</link> is a simple <literal moreinfo="none">Predicate</literal>
      implementation that always returns <literal
      moreinfo="none">true</literal>; it is intended as a basic example of how
      to implement the <literal moreinfo="none">Predicate</literal>
      interface.</para>

      <example id="functors-EX-5" label="4-5">
        <title>A simple Predicate implementation</title>

        <programlisting format="linespecific">import org.apache.commons.collections.Predicate;

public class SimplePredicate implements Predicate {
    public boolean evaluate(Object object) {
        // do something.
        boolean result = true;
        return result;
    }
}</programlisting>
      </example>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para><literal moreinfo="none">Predicates</literal> can be used in any
      number of situations, such as validating user input, filtering a
      <literal moreinfo="none">Collection</literal>, or just as a replacement
      for complex conditional logic. A <literal
      moreinfo="none">Predicate</literal> can be as simple or as complex as
      you need it to be; the only contract it must satisfy is the production
      of a <literal moreinfo="none">boolean</literal> result from an <literal
      moreinfo="none">evaluate( )</literal> method.</para>

      <para>To demonstrate the process of writing a fairly complex
      implementation of the <literal moreinfo="none">Predicate</literal>
      interface, a contrived example is developed in <link
      linkend="functors-EX-6">Example 4-6</link>. Your application
      evaluates the condition of the space shuttle and makes a determination
      for launch—go or no go. Some of the criteria include the temperature of
      the launch pad, the status of the crew, and the presence (or absence) of
      fuel. In the end, your boss is looking for thumbs up or thumbs down, and
      you decide to write a program that returns a <literal
      moreinfo="none">boolean</literal> decision. This decision is implemented
      in the <literal moreinfo="none">LaunchPredicate</literal> class.</para>

      <example id="functors-EX-6" label="4-6">
        <title>Implementing the Predicate interface</title>

        <programlisting format="linespecific">package com.discursive.jccook.collections.predicate;

import org.apache.commons.collections.Predicate;

public class LaunchPredicate implements Predicate {

    public LaunchPredicate( ) {}

    public boolean evaluate(Object object) {
        boolean launchGo = false;

        LaunchStats stats = (LaunchStats) object;

        boolean crewReady = stats.isCrewPresent( ) &amp;&amp; stats.isCrewHealthy( );
        boolean fueled = stats.isShuttleFueled( ) &amp;&amp; stats.
        isFuelIgnitionReady( );
        boolean withinLaunchWindow = stats.isLaunchWindowOpen( );

        boolean properWeather = 
                ( stats.temperature( ) &gt; 35 ) &amp;&amp; 
              ( !stats.isLightningDangerPresent( ) );

        // Check the crew, fuel, and launch time
            if( crewReady &amp;&amp; fueled &amp;&amp; withinLaunchWindow ) {
            launchGo = true;
        }

        // Override a GO decision if the weather is bad
        if( !properWeather ) {
            launchGo = false;
        }

        return launchGo;
    }
}</programlisting>
      </example>

      <para>A shuttle launch is predicated on the presence and health of the
      crew, the state of the fuel, and the time of the launch event. A final
      weather check is performed to ensure that the temperature of the shuttle
      is not below 35 degrees Fahrenheit. If this critical temperature limit
      is not met, the <literal moreinfo="none">Predicate</literal> overrides
      the previous decision to launch. Using a <literal
      moreinfo="none">LaunchPredicate</literal> encapsulates your decision
      logic in one object, making it easier to upgrade, maintain, and test
      this decision process. Your unit tests can pass a mock object to this
      predicate, testing every possible permutation of possible inputs. The
      following example demonstrates the use of the <literal
      moreinfo="none">LaunchPredicate</literal>:</para>

      <programlisting format="linespecific" id="I_4_tt176">LaunchPredicate launchDecision = new LaunchPredicate( );

LaunchStats stats = measureLaunchStatistics( );

if( launchDecision.evaluate( stats ) ) {
    System.out.println( "We are Go for Ignition." );
} else {
    System.out.println( "Abort mission." );
}</programlisting>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>The real Space Shuttle Launch Team has the outrageously complex
      job of monitoring and controlling every aspect of launching a
      spacecraft, and I'm sure that NASA doesn't implement the <literal
      moreinfo="none">Predicate</literal> interface from Jakarta Commons
      Collections. While it isn't related to the topic of open source Java
      programming, it is a fascinatingly complex piece of software that
      maintains a shuttle launch. It is written in something called high-order
      assembly language/shuttle (HAL/S). If you are interested in learning
      more about one of the most complex pieces of software, take a look at
      NASA's Space Shuttle Launch Team website at <systemitem moreinfo="none"
      role="url">http://science.ksc.nasa.gov/shuttle/countdown/launch-team.html</systemitem>.
      (Besides, I'm sure you are amused that NASA controls spacecraft with an
      assembly language known as HAL.)</para>

      <para>This recipe mentions the use of a mock object to test a <literal
      moreinfo="none">Predicate</literal>. One of the attractions of using a
      <literal moreinfo="none">Predicate</literal> to encapsulate any complex
      condition is the ability to write a test for this condition logic;
      <filename moreinfo="none">mock objects</filename> are a method of unit
      testing that involves passing a mock implementation of an object to a
      class i<indexterm class="endofrange" id="functors-ITERM-2347"
      significance="normal"
      startref="functors-ITERM-2339"></indexterm> <indexterm
      class="endofrange" id="functors-ITERM-2348"
      significance="normal"
      startref="functors-ITERM-2340"></indexterm> <indexterm
      class="endofrange" id="functors-ITERM-2349"
      significance="normal"
      startref="functors-ITERM-2341"></indexterm> <indexterm
      class="endofrange" id="functors-ITERM-2350"
      significance="normal"
      startref="functors-ITERM-2342"></indexterm> <indexterm
      class="endofrange" id="functors-ITERM-2351"
      significance="normal"
      startref="functors-ITERM-2343"></indexterm> <indexterm
      class="endofrange" id="functors-ITERM-2352"
      significance="normal"
      startref="functors-ITERM-2344"></indexterm>n a test. For more
      information about mock objects, see <systemitem moreinfo="none"
      role="url">http://www.mockobjects.com/</systemitem>.</para>
    </sect2>
  </sect1>

  <sect1 id="functors-sect-creating-custom-pred" label="4.9" role="Recipe">
    <title>Creating Composite Predicates</title>

    <sect2>
      <title>Problem</title>

      <para>You need to perform complex<indexterm class="startofrange"
          id="functors-ITERM-2353" significance="normal">
          <primary>functors</primary>

          <secondary>predicates</secondary>

          <tertiary>combining</tertiary>
        </indexterm> <indexterm class="startofrange"
          id="functors-ITERM-2354" significance="normal">
          <primary>Commons Collections</primary>

          <secondary>predicates</secondary>

          <tertiary>combining</tertiary>
        </indexterm> <indexterm class="startofrange"
          id="functors-ITERM-2355" significance="normal">
          <primary>predicates</primary>

          <secondary>Commons Collections</secondary>

          <tertiary>combining</tertiary>
        </indexterm> <indexterm class="startofrange"
          id="functors-ITERM-2356" significance="normal">
          <primary>combining predicates</primary>
        </indexterm> <indexterm class="startofrange"
          id="functors-ITERM-2357" significance="normal">
          <primary>multiple predicates, combining</primary>
        </indexterm> <indexterm class="startofrange"
          id="functors-ITERM-2358" significance="normal">
          <primary>conditions, combining predicates</primary>
        </indexterm> conditional logic using multiple <literal
      moreinfo="none">Predicate</literal> objects, and you need to combine and
      expose multiple criteria as one <literal
      moreinfo="none">Predicate</literal>.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>To combine several <literal moreinfo="none">Predicate</literal>
      instances, create a <literal moreinfo="none">Predicate</literal> to
      capture each portion of a compound condition, and combine each condition
      with <literal moreinfo="none">AndPredicate</literal>, <literal
      moreinfo="none">OrPredicate</literal>, <literal
      moreinfo="none">AllPredicate</literal>, <literal
      moreinfo="none">OnePredicate</literal>, <literal
      moreinfo="none">AnyPredicate</literal>, or <literal
      moreinfo="none">NonePredicate</literal>. All of these predicate
      implementations are used to combine the results of multiple
      predicates—creating a compound predicate. The following code
      demonstrates the use of the <literal
      moreinfo="none">AndPredicate</literal>, <literal
      moreinfo="none">OrPredicate</literal>, <literal
      moreinfo="none">AllPredicate</literal>, and <literal
      moreinfo="none">OnePredicate</literal>:</para>

      <programlisting format="linespecific" id="I_4_tt177">import org.apache.commons.collections.Predicate;
import org.apache.commons.collections.functors.*;

// Create Base Predicates
Predicate isTim = new EqualsPredicate("Tim");
Predicate isDouble = new InstanceOfPredicate( Double.class );
Predicate isNotNull = NotNullPredicate.INSTANCE;

Predicate[] predicates = new Predicate[] { isTim, isDouble, isNotNull };

<userinput moreinfo="none">// Create 2 argument logical predicate composites</userinput>
               <userinput moreinfo="none">Predicate andPredicate = new AndPredicate( isTim, isNotNull );</userinput>
               <userinput moreinfo="none">Predicate orPredicate = new OrPredicate( isTim, isNotNull );</userinput>

               <userinput moreinfo="none">// Create n-argument logical predicate composites</userinput>
               <userinput moreinfo="none">Predicate allPredicate = new AllPredicate( predicates );</userinput>
               <userinput moreinfo="none">Predicate onePredicate = new OnePredicate( predicates );</userinput>

System.out.println( "'Tim' and not null?: " + andPredicate.
evalute( "Tim" ) );
System.out.println( "'Tim' or not null?: " + andPredicate.
evalute(new Long(3))); 

System.out.println( "'Tim', not null, and Double?: " 
                        + allPredicate.evaluate( "Impossible" ) );
System.out.println( "XOR ('Tim', not null, or Double?): " 
                        + allPredicate.evaluate( "Impossible" ) );</programlisting>

      <para>This example creates the following output:</para>

      <programlisting format="linespecific" id="I_4_tt178">'Tim' and not null?: true
'Tim' or not null?: true

'Tim', not null, and Double?: false
XOR('Tim', not null, or Double?): true</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>An <literal moreinfo="none">AndPredicate</literal> returns
      <literal moreinfo="none">true</literal> if both predicates supplied to
      its constructor return <literal moreinfo="none">true</literal>, and an
      <literal moreinfo="none">OrPredicate</literal> returns <literal
      moreinfo="none">true</literal> if at least one of the two predicates
      passed to its constructor returns <literal
      moreinfo="none">true</literal>. An <literal
      moreinfo="none">AllPredicate</literal> takes an array of predicates,
      only returning <literal moreinfo="none">true</literal> if every
      predicate evaluates to <literal moreinfo="none">true</literal>. The
      <literal moreinfo="none">OnePredicate</literal> also takes an array of
      predicates, only returning <literal moreinfo="none">true</literal> if
      exactly one predicate evaluates to <literal
      moreinfo="none">true</literal>.</para>

      <para>In the code sample, the use of the second to last predicate,
      <literal moreinfo="none">AllPredicate</literal>, is impossible to
      satisfy; an object can never be a <literal
      moreinfo="none">String</literal> and a <literal
      moreinfo="none">Double</literal> at the same time. This example fails to
      demonstrate <literal moreinfo="none">AnyPredicate</literal> and <literal
      moreinfo="none">NonePredicate</literal>—both take an array of
      predicates. <literal moreinfo="none">AnyPredicate</literal> returns
      <literal moreinfo="none">true</literal> if any of the predicates
      evaluate to <literal moreinfo="none">true</literal>, and <literal
      moreinfo="none">NonePredicate</literal> returns <literal
      moreinfo="none">true</literal> only if none of the predicates evaluate
      to <literal moreinfo="none">true</literal>. The behavior of these
      objects is easily inferred from the names: And, Or, All, One, Any, or
      None.</para>

      <para>Any logical expression can be modeled by connecting <literal
      moreinfo="none">Predicate</literal> objects together— similar to the way
      that simple logic gates are connected to create complex digital logic.
      Logical inputs (1 and 0) are routed to logic gates (AND, OR, NOR, NAND,
      XOR, etc.), and the outputs of a logic circuit are a result of stages
      that perform the same function as the <literal
      moreinfo="none">Predicate</literal> objects introduced in this recipe.
      In the next example, a logic circuit will be used to demonstrate a
      complex hierarchy of <literal moreinfo="none">Predicate</literal>
      objects; a circuit diagram is drawn, and a series of predicates are
      developed to model this circuit. <link
      linkend="functors-FIG-1">Figure 4-1</link> contains a logical
      expression that is implemented with digital logic and <literal
      moreinfo="none">Predicate</literal> objects.</para>

      <figure float="0" id="functors-FIG-1" label="4-1">
        <title>Logical expression to be modeled with Predicate</title>

        <mediaobject id="I_4_tt179">
          <imageobject role="print">
            <imagedata depth="17" fileref="figs/print/jccb_0401.pdf"
                       format="PDF" width="46" />
          </imageobject>

          <imageobject role="web">
            <imagedata depth="17" fileref="figs/web/jccb_0401.png"
                       format="PNG" width="46" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>Assuming that every letter corresponds to a <literal
      moreinfo="none">boolean</literal> variable, this expression corresponds
      to the circuit diagram in <link linkend="functors-FIG-2">Figure
      4-2</link>. Each gate can be modeled as a composite <literal
      moreinfo="none">Predicate</literal>, and from <link
      linkend="functors-FIG-2">Figure 4-2</link> it is clear that
      this example will include two <literal
      moreinfo="none">AndPredicates</literal>, an <literal
      moreinfo="none">OrPredicate</literal>, and a <literal
      moreinfo="none">NotPredicate</literal>. The "AND" gate is modeled with
      an <literal moreinfo="none">AndPredicate</literal>, and an "OR" gate
      with an <literal moreinfo="none">OrPredicate</literal>. The "NAND" gate
      is transformed into a three-input "AND" gate followed by an inverter
      that is modeled with an <literal moreinfo="none">AllPredicate</literal>
      wrapped in a <literal moreinfo="none">NotPredicate</literal>.</para>

      <figure float="0" id="functors-FIG-2" label="4-2">
        <title>Circuit representing logical expression</title>

        <mediaobject id="I_4_tt180">
          <imageobject role="print">
            <imagedata depth="84" fileref="figs/print/jccb_0402.pdf"
                       format="PDF" width="127" />
          </imageobject>

          <imageobject role="web">
            <imagedata depth="84" fileref="figs/web/jccb_0402.png"
                       format="PNG" width="127" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>The system has five inputs, which will be stored in a <literal
      moreinfo="none">Map</literal> with five keys: A, B, C, D, and E. A
      simple <literal moreinfo="none">InputPredicate</literal> is developed to
      handle the inputs to the system—a map of <literal
      moreinfo="none">Boolean</literal> input objects is passed to the
      top-level <literal moreinfo="none">Predicate</literal>. An <literal
      moreinfo="none">InputPredicate</literal> is configured to evaluate the
      input <literal moreinfo="none">Map</literal> and return the <literal
      moreinfo="none">boolean</literal> value of one of the inputs; in other
      words, an <literal moreinfo="none">InputPredicate</literal> <indexterm
          id="functors-ITERM-2362" significance="normal">
          <primary>InputPredicate</primary>
        </indexterm> selects a <literal moreinfo="none">boolean</literal>
      value from a <literal moreinfo="none">Map</literal>, always returning
      the value of that input from the <literal moreinfo="none">Map</literal>
      it evaluates. (See <link linkend="functors-EX-7">Example
      4-7</link>.)</para>

      <example id="functors-EX-7" label="4-7">
        <title>InputPredicate: a predicate that selects an input from a
        Map</title>

        <indexterm id="functors-ITERM-2363" significance="normal">
          <primary>mapping</primary>

          <secondary>InputPredicate</secondary>
        </indexterm>

        <programlisting format="linespecific">package com.discursive.jccook.collections.predicate;

import org.apache.commons.collections.Predicate;

public class InputPredicate implements Predicate {

    private String inputKey;

    public BooleanPredicate(String inputKey) {
        this.inputKey = inputKey;
    }

    public boolean evaluate(Object object) {
        boolean satisfies = false;

            Map inputMap = (Map) object;
        Boolean input = (Boolean) inputMap.get( inputKey );
        if( input != null ) {
            satisfies = input.booleanValue( );
        }

        return satisfies;
    }
}</programlisting>
      </example>

      <para>The entire circuit is modeled by one top-level <literal
      moreinfo="none">Predicate</literal> and a <literal
      moreinfo="none">Map</literal> of <literal
      moreinfo="none">Boolean</literal> input signals is passed down a
      hierarchy of predicates as needed. Unlike a real circuit, where inputs
      would cause gates to fire sequentially, the predicate hierarchy is
      evaluated from the final stage backward—the example evaluates the
      <literal moreinfo="none">Predicate</literal> variable <literal
      moreinfo="none">circuit</literal>. The input map is passed to the
      top-most <literal moreinfo="none">Predicate</literal>, which, in turn,
      passes this same map to the <literal moreinfo="none">Predicate</literal>
      that precedes it in <indexterm id="functors-ITERM-2364"
          significance="normal">
          <primary>implementation</primary>

          <seealso>configuration</seealso>
        </indexterm>the circuit. <link
      linkend="functors-EX-8">Example 4-8</link> ties everything
      together, and the logic to create our circuit-modeling predicate has
      been confined to the <literal
      moreinfo="none">createPredicate()</literal> <indexterm
          id="functors-ITERM-2365" significance="normal">
          <primary>createPredicate( ) method</primary>
        </indexterm> <indexterm id="functors-ITERM-2366"
          significance="normal">
          <primary>methods</primary>

          <secondary>createPredicate( )</secondary>
        </indexterm> method.</para>

      <example id="functors-EX-8" label="4-8">
        <title>Implementing a multilevel composite Predicate</title>

        <indexterm id="functors-ITERM-2367" significance="normal">
          <primary>multilevel composite predicate implementation</primary>
        </indexterm>

        <indexterm id="functors-ITERM-2368" significance="normal">
          <primary>implementation</primary>

          <secondary>multilevel composite predicates</secondary>
        </indexterm>

        <programlisting format="linespecific">package com.discursive.jccook.collections.predicate;

import org.apache.commons.collections.Predicate;
import org.apache.commons.collections.functors.*;

public class CompoundPredicateExample {

    public static void main(String[] args) {
        CompoundPredicateExample example = new CompoundPredicateExample( );
        example.start( );
    }

    public void start( ) {

<userinput moreinfo="none">        Predicate circuit = createPredicate( );</userinput>
                  <userinput moreinfo="none">       Object[] inputsArray = </userinput>
                  <userinput moreinfo="none">           new Object[][] { {"A", Boolean.TRUE},</userinput>
                  <userinput moreinfo="none">                            {"B", Boolean.FALSE},</userinput>
                  <userinput moreinfo="none">                            {"C", Boolean.TRUE},</userinput>
                  <userinput moreinfo="none">                            {"D", Boolean.FALSE},</userinput>
                  <userinput moreinfo="none">                            {"E", Boolean.FALSE} };</userinput>
                  <userinput moreinfo="none">        Map inputs = ArrayUtils.toMap( inputsArray );</userinput>
                  <userinput moreinfo="none">        boolean result = circuit.evaluate( inputs ); </userinput>

                  <userinput moreinfo="none">         System.out.println( "The circuit fired?: " + result );</userinput>
                  <userinput moreinfo="none">    }</userinput>

    public Predicate createPredicate( ) {
        Predicate aPredicate = new InputPredicate("A");
        Predicate bPredicate = new InputPredicate("B");
        Predicate cPredicate = new InputPredicate("C");
        Predicate dPredicate = new InputPredicate("D");
        Predicate ePredicate = new InputPredicate("E");

        Predicate expression1 = new AndPredicate( aPredicate, bPredicate );
        Predicate expression2 = new OrPredicate( cPredicate, dPredicate );

       Predicate[] secondLevel = 
           new Predicate( ) { expression1, expression2, ePredicate };

       Predicate topLevel = new NotPredicate( secondLevel );
       return topLevel;
    }
}</programlisting>
      </example>

      <para>This code prints <literal moreinfo="none">The</literal> <literal
      moreinfo="none">circuit</literal> <literal
      moreinfo="none">fired?</literal>: <literal
      moreinfo="none">true</literal>. This complex example has demonstrated
      the process of modeling composite, multistage logic with a hierarchy of
      predicates. A <literal moreinfo="none">Predicate</literal> is the most
      basic functor and when combined with other <literal
      moreinfo="none">Predicate</literal> instances, there is no limit to the
      level of complexity that can be achieved. Logic circuits were used in
      this example because a logic gate is <indexterm class="endofrange"
      id="functors-ITERM-2369" significance="normal"
      startref="functors-ITERM-2353"></indexterm> <indexterm
      class="endofrange" id="functors-ITERM-2370"
      significance="normal"
      startref="functors-ITERM-2354"></indexterm> <indexterm
      class="endofrange" id="functors-ITERM-2371"
      significance="normal"
      startref="functors-ITERM-2355"></indexterm> <indexterm
      class="endofrange" id="functors-ITERM-2372"
      significance="normal"
      startref="functors-ITERM-2356"></indexterm> <indexterm
      class="endofrange" id="functors-ITERM-2373"
      significance="normal"
      startref="functors-ITERM-2357"></indexterm> <indexterm
      class="endofrange" id="functors-ITERM-2374"
      significance="normal"
      startref="functors-ITERM-2358"></indexterm>a great analogy for
      a <literal moreinfo="none">Predicate</literal>. Think of a <literal
      moreinfo="none">Predicate</literal> as a component—a gate in a logic
      circuit.</para>
    </sect2>
  </sect1>

  <sect1 id="functors-sect-transforming-objects" label="4.10" role="Recipe">
    <title>Transforming Objects</title>

    <sect2>
      <title>Problem</title>

      <para>You need to perform a<indexterm id="functors-ITERM-2375"
          significance="normal">
          <primary>functors</primary>

          <secondary>objects</secondary>

          <tertiary>transformation</tertiary>
        </indexterm> <indexterm id="functors-ITERM-2376"
          significance="normal">
          <primary>objects</primary>

          <secondary>transformation</secondary>
        </indexterm> <indexterm id="functors-ITERM-2377"
          significance="normal">
          <primary>transformation</primary>

          <secondary>objects</secondary>
        </indexterm> transformation, taking an object and creating a new
      object.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Implement the <literal moreinfo="none">Transformer</literal>
      interface. A <literal moreinfo="none">Transformer</literal> takes an
      object and returns a new object instance. The following example
      demonstrates the <literal moreinfo="none">joinArmy</literal> <literal
      moreinfo="none">Transformer</literal>; the <literal
      moreinfo="none">transform( )</literal> method takes a <literal
      moreinfo="none">Recruit</literal> object instance and returns a <literal
      moreinfo="none">Soldier</literal> object:</para>

      <programlisting format="linespecific" id="I_4_tt181">import org.apache.commons.collections.Transformer;

Transformer joinArmy = new Transformer( ) {
    public Object transform(Object input) {
                Recruit recruit = (Recruit) input;
         BootCamp.obstacleCourse( recruit );
                Soldier soldier = BootCamp.graduate( recruit );
        }
}

Recruit recruit1 = new Recruit("Pat T.");
System.out.println( "Status before transformation: " + recruit );

Soldier soldier1 = (Soldier) joinArmy.transform( recruit1 );
System.out.println( "Status after transformation: " + soldier );</programlisting>

      <para>A <literal moreinfo="none">Recruit</literal> object is passed to
      the <literal moreinfo="none">joinArmy.transform( )</literal> method, and
      a <literal moreinfo="none">Soldier</literal> object is returned. The
      state of the <literal moreinfo="none">recruit</literal> and <literal
      moreinfo="none">soldier</literal> instances are printed before and after
      the transformation:</para>

      <programlisting format="linespecific" id="I_4_tt182">Status before transformation: Pat T., Recruit
Status after transformation: Pat T., Soldier</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>This object isolates and encapsulates a transition; a system that
      needs to translate between two domain models or two object types should
      encapsulate such a transition in a <literal
      moreinfo="none">Transformer</literal>. <literal
      moreinfo="none">Transformer</literal> may be something of a misnomer.
      When an object undergoes a transformation, it is common to think of an
      object being modified or acted upon, but this is contrary to the design
      of the <literal moreinfo="none">Transformer</literal> interface. The
      Javadoc for <literal moreinfo="none">Transformer</literal> expressly
      states, "The original object is left unchanged." <link
      linkend="functors-FIG-3">Figure 4-3</link> illustrates the
      simple <literal moreinfo="none">joinArmy</literal> <literal
      moreinfo="none">Transformer</literal>.</para>

      <figure float="0" id="functors-FIG-3" label="4-3">
        <title>Diagram of the joinArmy Transformer</title>

        <mediaobject id="I_4_tt183">
          <imageobject role="print">
            <imagedata depth="30" fileref="figs/print/jccb_0403.pdf"
                       format="PDF" width="139" />
          </imageobject>

          <imageobject role="web">
            <imagedata depth="30" fileref="figs/web/jccb_0403.png"
                       format="PNG" width="139" />
          </imageobject>
        </mediaobject>
      </figure>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>Jakarta Commons Functor in the Commons Sandbox expands on the
      initial functors introduced in Commons Collections, introducing a
      <literal moreinfo="none">UnaryFunction</literal> object that provides a
      simple interface equivalent to <literal
      moreinfo="none">Transformer</literal>. For more information about
      <literal moreinfo="none">UnaryFunction</literal>, see the Commons
      Functor page at <systemitem moreinfo="none"
      role="url">http://jakarta.apache.org/commons/sandbox/functor</systemitem>.</para>
    </sect2>
  </sect1>

  <sect1 id="functors-sect-create-chain" label="4.11" role="Recipe">
    <title>Creating a Chain of Transformations</title>

    <sect2>
      <title>Problem</title>

      <para>You have a series of transformations and <indexterm
          id="functors-ITERM-2378" significance="normal">
          <primary>functors</primary>

          <secondary>objects</secondary>

          <tertiary>chaining transformations</tertiary>
        </indexterm> <indexterm id="functors-ITERM-2379"
          significance="normal">
          <primary>objects</primary>

          <secondary>transformation</secondary>

          <tertiary>chaining</tertiary>
        </indexterm> <indexterm id="functors-ITERM-2380"
          significance="normal">
          <primary>transformation</primary>

          <secondary>objects</secondary>

          <tertiary>chaining</tertiary>
        </indexterm> <indexterm id="functors-ITERM-2381"
          significance="normal">
          <primary>chaining</primary>

          <secondary>transformations</secondary>
        </indexterm>you need to chain them together, passing the output of one
      stage to the input of the next.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Create multiple implementations of <literal
      moreinfo="none">Transformer</literal>, and chain them together with
      <literal moreinfo="none">ChainedTransformer</literal>. A <literal
      moreinfo="none">ChainedTransformer</literal> <indexterm
          id="functors-ITERM-2382" significance="normal">
          <primary>ChainedTransformer</primary>
        </indexterm> takes an array of <literal
      moreinfo="none">Transformer</literal> objects, passing the output of
      each <literal moreinfo="none">Transformer</literal> to the next <literal
      moreinfo="none">Transformer</literal> in the chain. The following
      example demonstrates a <literal
      moreinfo="none">ChainedTransformer</literal> with two <literal
      moreinfo="none">Transformer</literal> stages. The first stage, <literal
      moreinfo="none">multiply</literal>, multiplies a number by 100, and the
      second stage, <literal moreinfo="none">increment</literal>, adds one to
      the result from the first stage:</para>

      <programlisting format="linespecific" id="I_4_tt184">import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;

Transformer multiply = new Transformer( ) {
    public Object transform(Object input) {
                Long number = (Long) input;
         return( new Long( number.longValue( ) * 100 ) );
        }
}

Transformer increment = new Transformer( ) {
    public Object transform(Object input) {
                Long number = (Long) input;
         return( new Long( number.longValue( ) + 1 ) );
        }
}

Transformer[] chainElements = new Transformer[] { multiply, increment };
Transformer chain = new ChainedTransformer( chainElements );

Long original = new Long( 34 );
Long result = chain.transform( original );

System.out.println( "Original: " + original );
System.out.println( "Result: " + result );</programlisting>

      <para>The <literal moreinfo="none">Transformer</literal> chain takes the
      <literal moreinfo="none">Long</literal> instance <literal
      moreinfo="none">original</literal> and transforms it into a
      result:</para>

      <programlisting format="linespecific" id="I_4_tt185">Original: 34
Result: 3401</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>Since a <literal moreinfo="none">Transformer</literal> leaves the
      input parameter passed to <literal moreinfo="none">transform(
      )</literal> intact, this two-stage <literal
      moreinfo="none">ChainedTransformer</literal> creates a new instance of
      <literal moreinfo="none">Long</literal> for each stage in the <literal
      moreinfo="none">ChainedTransformer</literal>. A <literal
      moreinfo="none">Long</literal> is passed to the first stage, <literal
      moreinfo="none">multiply</literal>, which transforms 34 to 3400. The
      result from the first stage, 3400, is then passed to the second stage,
      <literal moreinfo="none">increment</literal>, which produces the final
      <literal moreinfo="none">Long</literal> result, 3401. A real example
      would involve more complex implementations of <literal
      moreinfo="none">Transformer</literal>, but this simple example
      demonstrates the mechanics of creating a simple pipeline of
      transformations, one leading to another. <link
      linkend="functors-FIG-4">Figure 4-4</link> illustrates the
      simple structure of this two-staged <literal
      moreinfo="none">ChainedTransformer</literal>.</para>

      <figure float="0" id="functors-FIG-4" label="4-4">
        <title>A ChainedTransformer with two Transformers</title>

        <mediaobject id="I_4_tt186">
          <imageobject role="print">
            <imagedata depth="30" fileref="figs/print/jccb_0404.pdf"
                       format="PDF" width="195" />
          </imageobject>

          <imageobject role="web">
            <imagedata depth="30" fileref="figs/web/jccb_0404.png"
                       format="PNG" width="195" />
          </imageobject>
        </mediaobject>
      </figure>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>Jakarta Commons Functor in the Commons Sandbox introduces a
      <literal moreinfo="none">UnaryFunction</literal> interface that provides
      an interface equivalent to <literal
      moreinfo="none">Transformer</literal>, and multiple <literal
      moreinfo="none">UnaryFunction</literal> instances can be chained
      together using the <literal
      moreinfo="none">CompositeUnaryFunction</literal> <indexterm
          id="functors-ITERM-2383" significance="normal">
          <primary>CompositeUnaryFunction class</primary>
        </indexterm> <indexterm id="functors-ITERM-2384"
          significance="normal">
          <primary>classes</primary>

          <secondary>CompositeUnaryFunction</secondary>
        </indexterm> class. For more information about <literal
      moreinfo="none">CompositeUnaryFunction</literal>, see the Commons
      Functor page at <systemitem moreinfo="none"
      role="url">http://jakarta.apache.org/commons/sandbox/functor</systemitem>.</para>
    </sect2>
  </sect1>

  <sect1 id="functors-sect-apply-conditional" label="4.12" role="Recipe">
    <title>Applying Conditional Transformations</title>

    <sect2>
      <title>Problem</title>

      <para>You need to perform a different <indexterm class="startofrange"
          id="functors-ITERM-2385" significance="normal">
          <primary>functors</primary>

          <secondary>objects</secondary>

          <tertiary>conditional transformations</tertiary>
        </indexterm> <indexterm class="startofrange"
          id="functors-ITERM-2386" significance="normal">
          <primary>objects</primary>

          <secondary>transformation</secondary>

          <tertiary>conditional</tertiary>
        </indexterm> <indexterm class="startofrange"
          id="functors-ITERM-2387" significance="normal">
          <primary>transformation</primary>

          <secondary>objects</secondary>

          <tertiary>conditional</tertiary>
        </indexterm> <indexterm class="startofrange"
          id="functors-ITERM-2388" significance="normal">
          <primary>conditional transformations</primary>
        </indexterm>transformation depending on a series of conditions or
      cases.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use a <literal moreinfo="none">SwitchTransformer</literal>
      <indexterm id="functors-ITERM-2389" significance="normal">
          <primary>SwitchTransformer</primary>
        </indexterm> to apply a <literal moreinfo="none">Transformer</literal>
      that is dependent on a <literal moreinfo="none">Predicate</literal>. A
      <literal moreinfo="none">SwitchTransformer</literal> models a <literal
      moreinfo="none">switch</literal> statement, and it takes three
      parameters: an array of <literal moreinfo="none">Predicate</literal>
      instances, an array of <literal moreinfo="none">Transformer</literal>
      instances, and a default <literal moreinfo="none">Transformer</literal>.
      <link linkend="functors-EX-9">Example 4-9</link> uses a
      <literal moreinfo="none">SwitchTransformer</literal> to apply a
      different <literal moreinfo="none">Transformer</literal> implementation
      to odd and even numbers.</para>

      <example id="functors-EX-9" label="4-9">
        <title>Using a SwitchTransformer</title>

        <programlisting format="linespecific">Transformer oddTransform = new Transformer( ) {
    public Object transform(Object input) {
        Integer number = new Integer( input );
        return ( new Integer( number.intValue( ) * 2 );
    }
}

Transformer evenTransform = new Transformer( ) {
    public Object transform(Object input) {
        Integer number = new Integer( input );
        return ( new Integer( number.intValue( ) * 3 );
    }
}

Predicate isEven = new Predicate( ) {
    public boolean evaluate(Object input) {
        Integer number = (Integer) input;
        return( number.intValue( ) % 2 == 0 );
    }
}

<userinput moreinfo="none">Predicate isOdd = new NotPredicate(isEven);</userinput>

                  <userinput moreinfo="none">Predicate[] pArray = new Predicate[] { isOdd, isEven };</userinput>
                  <userinput moreinfo="none">Transformer[] tArray = new Transformer[] { oddTransform, evenTransform };</userinput>

                  <userinput moreinfo="none">Transform predicateTransform = </userinput>
                  <userinput moreinfo="none">    new SwitchTransform( pArray, tArray, new NOPTransformer( ) );</userinput>

Integer one = new Integer( 1 );
Integer two = new Integer( 2 );
Integer three = new Integer( 3 );
Integer four = new Integer( 4 );

System.out.println( "Transform of 1 = " + predicateTransform.
transform( one ) );
System.out.println( "Transform of 2 = " + predicateTransform.
transform( two ) );
System.out.println( "Transform of 3 = " + predicateTransform.
transform( three ) );
System.out.println( "Transform of 4 = " + predicateTransform.
transform( four ) );</programlisting>
      </example>

      <para>If an object being transformed satisfies the <literal
      moreinfo="none">isOdd</literal> <literal
      moreinfo="none">Predicate</literal>, it is passed to the <literal
      moreinfo="none">oddTransform</literal> <literal
      moreinfo="none">Transformer</literal>. If an object being transformed
      satisfies the <literal moreinfo="none">isEven</literal> <literal
      moreinfo="none">Predicate</literal>, it is passed to the <literal
      moreinfo="none">evenTransform</literal> <literal
      moreinfo="none">Predicate</literal>. If the object satisfies neither
      <literal moreinfo="none">Predicate</literal>, it is passed to an
      instance of <literal moreinfo="none">NOPTransformer</literal>, which is
      a <literal moreinfo="none">Transformer</literal> implementation that
      returns the object passed to <literal moreinfo="none">transform(
      )</literal>:</para>

      <programlisting format="linespecific" id="I_4_tt187">Transform of 1 = 2
Transform of 2 = 6
Transform of 3 = 6
Transform of 4 = 12</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>The array of <literal moreinfo="none">Predicate</literal>
      instances and the array of <literal
      moreinfo="none">Transformer</literal> instances passed to the
      constructor of <literal moreinfo="none">SwitchTransformer</literal> must
      be of equal length. The <literal
      moreinfo="none">SwitchTransformer</literal> evaluates each of the
      <literal moreinfo="none">Predicate</literal> instances in the array. If
      a <literal moreinfo="none">Predicate</literal> evaluates to <literal
      moreinfo="none">true</literal>, the <literal
      moreinfo="none">SwitchTransformer</literal> retrieves the <literal
      moreinfo="none">Transformer</literal> that corresponds to the matching
      <literal moreinfo="none">Predicate</literal>. If no <literal
      moreinfo="none">Predicate</literal> evaluates to <literal
      moreinfo="none">true</literal>, the <literal
      moreinfo="none">SwitchTransformer</literal> passes the object being
      transformed to the third parameter—the default <literal
      moreinfo="none">Transformer</literal>. In <link
      linkend="functors-EX-9">Example 4-9</link>, the default
      <literal moreinfo="none">Transformer</literal> was a <literal
      moreinfo="none">NOPTransformer</literal>, which is a <literal
      moreinfo="none">Transformer</literal> implementation that performs no
      transformation and returns the object passed to <literal
      moreinfo="none">transform()</literal>. <link
      linkend="functors-FIG-5">Figure 4-5</link> illustrates the
      <literal moreinfo="none">SwitchTransformer</literal> from the Solution;
      the two <literal moreinfo="none">Predicate</literal> instances
      correspond to two <literal moreinfo="none">Transformer</literal>
      instances.</para>

      <figure float="0" id="functors-FIG-5" label="4-5">
        <title>A SwitchTransform with two Predicate instances, two Transformer
        instances, and a default Transformer</title>

        <mediaobject id="I_4_tt188">
          <imageobject role="print">
            <imagedata depth="118" fileref="figs/print/jccb_0405.pdf"
                       format="PDF" width="199" />
          </imageobject>

          <imageobject role="web">
            <imagedata depth="118" fileref="figs/web/jccb_0405.png"
                       format="PNG" width="199" />
          </imageobject>
        </mediaobject>
      </figure>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>Jakarta Commons Functor in the Commons Sandbox introduces a
      <literal moreinfo="none">UnaryFunction</literal> interface that provides
      an interface equivalent to <literal
      moreinfo="none">Transformer</literal>. A <literal
      moreinfo="none">UnaryFunction</literal> can be predicated with a
      <literal moreinfo="none">UnaryPredicate</literal> object via the
      <literal moreinfo="none">ConditionalUnaryFunction</literal> class. For
      more information about <literal moreinfo="none">UnaryPredicate</literal>
      <indexterm class="endofrange" id="functors-ITERM-2390"
      significance="normal"
      startref="functors-ITERM-2385"></indexterm> <indexterm
      class="endofrange" id="functors-ITERM-2391"
      significance="normal"
      startref="functors-ITERM-2386"></indexterm> <indexterm
      class="endofrange" id="functors-ITERM-2392"
      significance="normal"
      startref="functors-ITERM-2387"></indexterm> <indexterm
      class="endofrange" id="functors-ITERM-2393"
      significance="normal"
      startref="functors-ITERM-2388"></indexterm> and <literal
      moreinfo="none">ConditionalUnaryFunction</literal>, see the Commons
      Functor page at <systemitem moreinfo="none"
      role="url">http://jakarta.apache.org/commons/sandbox/functor</systemitem>.</para>
    </sect2>
  </sect1>

  <sect1 id="functors-sect-writing-closure" label="4.13" role="Recipe">
    <title>Writing a Closure</title>

    <sect2>
      <title>Problem</title>

      <para>You need a functor that <indexterm
          id="functors-ITERM-2394" significance="normal">
          <primary>functors</primary>

          <secondary>objects</secondary>

          <tertiary>closures</tertiary>
        </indexterm> <indexterm id="functors-ITERM-2395"
          significance="normal">
          <primary>objects</primary>

          <secondary>closures</secondary>
        </indexterm> <indexterm id="functors-ITERM-2396"
          significance="normal">
          <primary>closures</primary>
        </indexterm>operates on an object.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use a <literal moreinfo="none">Closure</literal> to encapsulate a
      block of code that acts on an object. In this example, a <literal
      moreinfo="none">discount</literal> <literal
      moreinfo="none">Closure</literal> operates on a <literal
      moreinfo="none">Product</literal> object, reducing the price by 10
      percent:</para>

      <programlisting format="linespecific" id="I_4_tt189">Closure discount = new Closure( ) {
    int count = 0;
    public int getCount( ) { return count; }
  
    public void execute(Object input) {
        count++;
            (Product) product = (Product) input;
            product.setPrice( product.getPrice( ) * 0.90 ); 
    }
}

Product shoes = new Product( );
shoes.setName( "Fancy Shoes" );
shoes.setPrice( 120.00 );
System.out.println( "Shoes before discount: " + shoes );

discount.execute( shoes );
System.out.println( "Shoes after discount: " + shoes );

discount.execute( shoes );
discount.execute( shoes );
System.out.println( "Shoes after " + discount.getcount( ) + 
                    " discounts: " + shoes );</programlisting>

      <para>The example prints out the original cost of <literal
      moreinfo="none">shoes</literal> ($120) and then proceeds to discount
      <literal moreinfo="none">shoes</literal> and print out the discounted
      price. The <literal moreinfo="none">Product</literal> object, <literal
      moreinfo="none">shoes</literal>, is modified by the <literal
      moreinfo="none">discount</literal> <literal
      moreinfo="none">Closure</literal> three separate times:</para>

      <programlisting format="linespecific" id="I_4_tt190">Shoes before discount: Fancy Shoes for $120.00
Shoes after discount: Fancy Shoes for $108.00
Shoes after 3 discounts: Fancy Shoes for $87.48</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>A <literal moreinfo="none">Closure</literal> operates on the input
      object passed to the <literal moreinfo="none">execute( )</literal>
      method, while a <literal moreinfo="none">Transformer</literal> does not
      alter the object passed to <literal moreinfo="none">transform(
      )</literal>. Use <literal moreinfo="none">Closure</literal> if your
      system needs to act on an object. Like the <literal
      moreinfo="none">Transformer</literal> and <literal
      moreinfo="none">Predicate</literal> interfaces, there are a number of
      <literal moreinfo="none">Closure</literal> implementations that can be
      used to chain and combine <literal moreinfo="none">Closure</literal>
      instances.</para>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>Jakarta Commons Functor in the Commons Sandbox expands on the
      initial functors introduced in Commons Collections, introducing a
      <literal moreinfo="none">UnaryProcedure</literal> object that provides a
      simple interface equivalent to <literal
      moreinfo="none">Closure</literal>. For more information about <literal
      moreinfo="none">UnaryProcedure</literal>, see the Commons Functor page
      at <systemitem moreinfo="none"
      role="url">http://jakarta.apache.org/commons/sandbox/functor</systemitem>.</para>
    </sect2>
  </sect1>

  <sect1 id="functors-sect-chaining-closures" label="4.14" role="Recipe">
    <title>Chaining Closures</title>

    <sect2>
      <title>Problem</title>

      <para>An object needs to be acted on<indexterm
          id="functors-ITERM-2397" significance="normal">
          <primary>functors</primary>

          <secondary>objects</secondary>

          <tertiary>chaining closures</tertiary>
        </indexterm> <indexterm id="functors-ITERM-2398"
          significance="normal">
          <primary>objects</primary>

          <secondary>closures</secondary>

          <tertiary>chaining</tertiary>
        </indexterm> <indexterm id="functors-ITERM-2399"
          significance="normal">
          <primary>closures</primary>

          <secondary>chaining</secondary>
        </indexterm> <indexterm id="functors-ITERM-2400"
          significance="normal">
          <primary>chaining</primary>

          <secondary>closures</secondary>
        </indexterm> by a series of <literal moreinfo="none">Closure</literal>
      instances.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use <literal moreinfo="none">ChainedClosure</literal> to create a
      chain of <literal moreinfo="none">Closure</literal> instances that
      appears as a single <literal moreinfo="none">Closure</literal>. A
      <literal moreinfo="none">ChainedClosure</literal> <indexterm
          id="functors-ITERM-2401" significance="normal">
          <primary>ChainedClosure</primary>
        </indexterm> takes an array of <literal
      moreinfo="none">Closure</literal> objects and passes the same object
      sequentially to each <literal moreinfo="none">Closure</literal> in the
      chain. This example sends an object through a <literal
      moreinfo="none">ChainedClosure</literal> containing two stages that
      modify different properties on the object:</para>

      <programlisting format="linespecific" id="I_4_tt191">Closure fuel = new Closure( ) {
    public void execute(Object input) {
        Shuttle shuttle = (Shuttle) input;
        shuttle.setFuelPercent( 100.0 );
    }
}

Closure repairShielding = new Closure( ) {
    public void execute(Object input) {
        Shuttle shuttle = (Shuttle) input;
        shuttle.setShieldingReady( true );
    }
}

Closure[] cArray = new Closure[] { repairShielding, fuel };
Closure preLaunch = new ChainedClosure( cArray );

Shuttle endeavour = new Shuttle( );
endeavour.setName( "Endeavour" );
System.out.println( "Shuttle before preLaunch: " + shuttle );

preLaunch.execute( endeavour );
System.out.println( "Shuttle after preLaunch: " + shuttle );</programlisting>

      <para>A <literal moreinfo="none">Shuttle</literal> object is passed
      through a <literal moreinfo="none">ChainedClosure</literal>, <literal
      moreinfo="none">preLaunch</literal>, which consists of the stages
      <literal moreinfo="none">fuel</literal> and <literal
      moreinfo="none">repairShielding</literal>. These two <literal
      moreinfo="none">Closure</literal> objects each modify the internal state
      of the <literal moreinfo="none">Shuttle</literal> object, which is
      printed out both before and after the execution of the <literal
      moreinfo="none">preLaunch</literal> <literal
      moreinfo="none">Closure</literal>:</para>

      <programlisting format="linespecific" id="I_4_tt192">Shuttle before preLaunch: Shuttle Endeavour has no fuel and no shielding.
Shuttle before preLaunch: Shuttle Endeavour is fueled and is ready for reentry.</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>This example should remind you of <link
      linkend="functors-SECT-11">Recipe 4.11</link>. When chaining
      <literal moreinfo="none">Transformer</literal> objects, the result of
      each transformation is passed between stages—the results of stage one
      are passed to stage two, the results of stage two are passed to stage
      three, and so on. A <literal moreinfo="none">ChainedClosure</literal> is
      different; the same object is passed to each <literal
      moreinfo="none">Closure</literal> in sequence like a car moving through
      a factory assembly line.</para>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>Jakarta Commons Functor in the Commons Sandbox introduces a
      <literal moreinfo="none">UnaryProcedure</literal> interface that is
      equivalent to <literal moreinfo="none">Closure</literal>. Two or more
      <literal moreinfo="none">UnaryProcedure</literal> instances can be
      chained together using the <literal
      moreinfo="none">CompositeUnaryProcedure</literal> class. For more
      information about <literal
      moreinfo="none">CompositeUnaryProcedure</literal>, see the Commons
      Functor page at <systemitem moreinfo="none"
      role="url">http://jakarta.apache.org/commons/sandbox/functor</systemitem>.</para>
    </sect2>
  </sect1>

  <sect1 id="functors-sect-modeling-conditional-closure" label="4.15"
         role="Recipe">
    <title>Modeling Conditional Statements with Closures</title>

    <sect2>
      <title>Problem</title>

      <para>You need to model a <indexterm class="startofrange"
          id="functors-ITERM-2402" significance="normal">
          <primary>functors</primary>

          <secondary>objects</secondary>

          <tertiary>conditional statements with closures</tertiary>
        </indexterm> <indexterm class="startofrange"
          id="functors-ITERM-2403" significance="normal">
          <primary>objects</primary>

          <secondary>closures</secondary>

          <tertiary>conditional statements with</tertiary>
        </indexterm> <indexterm class="startofrange"
          id="functors-ITERM-2404" significance="normal">
          <primary>closures</primary>

          <secondary>conditional statements with</secondary>
        </indexterm>conditional statement with functors.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use an <literal moreinfo="none">IfClosure</literal>, supplying a
      <literal moreinfo="none">Predicate</literal> and two <literal
      moreinfo="none">Closure</literal> objects. If the <literal
      moreinfo="none">Predicate</literal> evaluates to <literal
      moreinfo="none">true</literal>, the first <literal
      moreinfo="none">Closure</literal> is executed; if the <literal
      moreinfo="none">Predicate</literal> evaluates to <literal
      moreinfo="none">false</literal>, the second <literal
      moreinfo="none">Closure</literal> is executed. The following closure
      deals with a financial decision; a <literal
      moreinfo="none">Predicate</literal>, <literal
      moreinfo="none">isWinning</literal>, evaluates a <literal
      moreinfo="none">Stock</literal> object. If the purchase price is less
      than the current price, the stock is a winner, causing the <literal
      moreinfo="none">buy</literal> <literal moreinfo="none">Closure</literal>
      to be executed. If the purchase price is higher than the current price,
      the stock is a loser and it is sold by passing it to the <literal
      moreinfo="none">sell</literal> <literal
      moreinfo="none">Closure</literal>:</para>

      <programlisting format="linespecific" id="I_4_tt193">Closure sell = new Closure( ) {
    public void execute(Object input) {
        Stock stock = (Stock) input;
        stock.sell( stock.getShares( ) );
        System.out.println( "\tSold all shares" );
    }
}

Closure buy = new Closure( ) {
    public void execute(Object input) {
        Stock stock = (Stock) input;
        int buyShares = stock.getShares( ) * 0.10;
        stock.buy( buyShares );
        System.out.println( "\tBought " + buyShares );
    }
}

Predicate isWinning = new Predicate( ) {
    public boolean evaluate(Object object) {
        Stock stock = (Stock) object;
        if( stock.getPurchasePrice( ) &lt; stock.getCurrentPrice( ) ) {
            System.out.println( stock.getSymbol( ) + " is a winner";
            return true;
        } else {
            System.out.println( stock.getSymbol( ) + " is a loser";
            return false;
        }
    }
}

Closure stockAction = new IfClosure( isWinning, buy, sell );

Stock yahoo = new Stock("YHOO");
yahoo.setPurchasePrice( 10.0 );
yahoo.setCurrentPrice( 20.0 );
yahoo.setShares( 100 ); 

Stock tibco = new Stock("TIB");
tibco.setPurchasePrice( 50.0 );
tibco.setCurrentPrice( 30.0 );
tibco.setShares( 50 );

// Execute the IfClosure, take action on stocks based on performance
stockAction.execute( yahoo );
stockAction.execute( tibco );</programlisting>

      <para>The example evaluates two stocks, a winner and a loser. The
      following output is generated:</para>

      <programlisting format="linespecific" id="I_4_tt194">YHOO is a winner
    Bought 10 shares
TIB is a loser
    Sold All Shares</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>Because an <literal moreinfo="none">IfClosure</literal> is an
      implementation of a <literal moreinfo="none">Closure</literal>, you can
      nest <literal moreinfo="none">IfClosures</literal> within other <literal
      moreinfo="none">IfClosures</literal>. The following code uses the
      <literal moreinfo="none">Closure</literal> objects and the <literal
      moreinfo="none">Predicate</literal> defined in the Solution, adding a
      third <literal moreinfo="none">Closure</literal>, <literal
      moreinfo="none">isUnchanged</literal>, to create a nested <literal
      moreinfo="none">IfClosure--sellOrHold</literal>:</para>

      <programlisting format="linespecific" id="I_4_tt195">Predicate isUnchanged = new Predicate( ) {
    public boolean evaluate(Object object) {
        Stock stock = (Stock) object;
        if( stock.getPurchasePrice( ) == stock.getCurrentPrice( ) ) {
            System.out.println( stock.getSymbol( ) + " is unchanged";
            return true;
        }
        return false;
    }
}

Closure sellOrHold = new IfClosure( isUnchanged, new NOPClosure( ), sell );
Closure stockAction = new IfClosure( isWinning, buy, sellOrHold );

Stock tibco = new Stock("TIB");
tibco.setPurchasePrice( 50.0 );
tibco.setCurrentPrice( 30.0 );
tibco.setShares( 50 );

Stock lucent = new Stock("LU");
tibco.setPurchasePrice( 30.0 );
tibco.setCurrentPrice( 30.0 );
tibco.setShares( 150 );

stockAction.execute( tibco );
stockAction.execute( lucent );</programlisting>

      <para>When <literal moreinfo="none">stockAction</literal> is executed,
      and a <literal moreinfo="none">Stock</literal> does not satisfy the
      <literal moreinfo="none">isWinning</literal> <literal
      moreinfo="none">Predicate</literal>, it is passed to the <literal
      moreinfo="none">sellOrHold</literal> <literal
      moreinfo="none">Closure</literal>, which is another <literal
      moreinfo="none">IfClosure</literal>. The <literal
      moreinfo="none">sellOrHold</literal> <literal
      moreinfo="none">Closure</literal> then evaluates the <literal
      moreinfo="none">Stock</literal> to see if it is a loser or unchanged. If
      the stock price is unchanged, it is passed to a <literal
      moreinfo="none">NOPClosure</literal>, which performs no operation on the
      <literal moreinfo="none">Stock</literal> object. If the stock price is
      less than the purchase price, the <indexterm class="endofrange"
      id="functors-ITERM-2405" significance="normal"
      startref="functors-ITERM-2402"></indexterm> <indexterm
      class="endofrange" id="functors-ITERM-2406"
      significance="normal"
      startref="functors-ITERM-2403"></indexterm> <indexterm
      class="endofrange" id="functors-ITERM-2407"
      significance="normal"
      startref="functors-ITERM-2404"></indexterm> <literal
      moreinfo="none">Stock</literal> is passed to the <literal
      moreinfo="none">sell</literal> <literal
      moreinfo="none">Closure</literal>.</para>
    </sect2>
  </sect1>

  <sect1 id="functors-sect-modeling-loops" label="4.16" role="Recipe">
    <title>Modeling Loops with Closures</title>

    <sect2>
      <title>Problem</title>

      <para>You need to execute a <indexterm id="functors-ITERM-2408"
          significance="normal">
          <primary>functors</primary>

          <secondary>objects</secondary>

          <tertiary>loops with closures</tertiary>
        </indexterm> <indexterm id="functors-ITERM-2409"
          significance="normal">
          <primary>objects</primary>

          <secondary>closures</secondary>

          <tertiary>loops with</tertiary>
        </indexterm> <indexterm id="functors-ITERM-2410"
          significance="normal">
          <primary>closures</primary>

          <secondary>loops with</secondary>
        </indexterm> <indexterm id="functors-ITERM-2411"
          significance="normal">
          <primary>loops</primary>

          <secondary sortas="closures">with closures</secondary>
        </indexterm> <literal moreinfo="none">Closure</literal> multiple
      times.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use a <literal moreinfo="none">WhileClosure</literal>, passing in
      a <literal moreinfo="none">Predicate</literal> and a <literal
      moreinfo="none">Closure</literal>. The <literal
      moreinfo="none">WhileClosure</literal> will execute the <literal
      moreinfo="none">Closure</literal> as long as a <literal
      moreinfo="none">Predicate</literal> evaluates to <literal
      moreinfo="none">true</literal>. The following example demonstrates a
      <literal moreinfo="none">Closure</literal> named <literal
      moreinfo="none">drive</literal>, which operates on a <literal
      moreinfo="none">Car</literal> object and a <literal
      moreinfo="none">Predicate</literal> named <literal
      moreinfo="none">hasFuel</literal>, which evaluates the <literal
      moreinfo="none">Car</literal> object. Each time a <literal
      moreinfo="none">Car</literal> is passed to <literal
      moreinfo="none">drive</literal>, a gallon of fuel is used, and <literal
      moreinfo="none">hasFuel</literal> will evaluate to <literal
      moreinfo="none">true</literal> if the amount of fuel in a car is greater
      than zero. The <literal moreinfo="none">WhileClosure</literal>, <literal
      moreinfo="none">useAllFuel</literal>, evaluates <literal
      moreinfo="none">drive</literal> until <literal
      moreinfo="none">hasFuel</literal> evaluates to <literal
      moreinfo="none">false</literal>:</para>

      <programlisting format="linespecific" id="I_4_tt196">import org.apache.commons.collections.Closure;
import org.apache.commons.collections.Predicate;
import org.apache.commons.collections.functors.WhileClosure;

Closure drive = new Closure( ) {
    public void execute(Object input) {
        Car car = (Car) input;
        car.setFuel( car.getFuel( ) - 1 );
    }
}

Predicate hasFuel = new Predicate( ) {
    public boolean evaluate(Object object) {
        Car car = (Car) input;
        return car.getFuel( ) &gt; 0;
    }
}

<userinput moreinfo="none">Closure useAllFuel = new WhileFuel( hasFuel, drive );</userinput>

Car car = new Car( );
car.setMakeModel( "Ford Escort" );
car.setFuel( 20 );
System.out.println( "Car before while closure: " + car );

useAllFuel.execute( car );
System.out.println( "Car after while closure: " + car );</programlisting>

      <para>The <literal moreinfo="none">WhileClosure</literal>, <literal
      moreinfo="none">useAllFuel</literal>, takes a <literal
      moreinfo="none">Car</literal> object, executing a <literal
      moreinfo="none">Closure</literal> and evaluating a <literal
      moreinfo="none">Predicate</literal> after every execution. The state of
      the car is printed both before and after it is passed to the <literal
      moreinfo="none">WhileClosure</literal>:</para>

      <programlisting format="linespecific" id="I_4_tt197">Car before while closure: Ford Escort with 20 gallons of fuel.
Car after while closure: Ford Escort with no fuel.</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>If you need to execute a <literal
      moreinfo="none">Closure</literal> a set number of times, you can also
      use a <literal moreinfo="none">ForClosure</literal>, passing in an
      <literal moreinfo="none">int</literal> that specifies the number of
      times an object is passed to the <literal moreinfo="none">execute(
      )</literal> method of a <literal moreinfo="none">Closure</literal>. This
      example uses the same <literal moreinfo="none">Closure</literal> defined
      in the Solution, but, this time, the <literal
      moreinfo="none">drive</literal> <literal
      moreinfo="none">Closure</literal> is only executed five times:</para>

      <programlisting format="linespecific" id="I_4_tt198">
               <userinput moreinfo="none">Closure driveSome = new ForClosure( 5, drive );</userinput>

Car car = new Car( );
car.setMakeModel( "Toyota Camry" );
car.setFuel( 20 );

System.out.println( "Car before for closure: " + car );

driveSome.execute( car );

System.out.println( "Car after for closure: " + car );</programlisting>

      <para>Since the <literal moreinfo="none">driveSome</literal> <literal
      moreinfo="none">Closure</literal> is called only five times, the Camry
      still has 15 gallons after the <literal
      moreinfo="none">ForClosure</literal> is executed:</para>

      <programlisting format="linespecific" id="I_4_tt199">Car before for closure: Toyota Camry with 20 gallons of fuel.
Car after for closure: Toyota Camry with 15 gallons of fuel.</programlisting>
    </sect2>
  </sect1>
</chapter>