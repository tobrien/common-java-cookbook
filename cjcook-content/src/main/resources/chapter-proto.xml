<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://mars.discursive.com/docbook/xml/4.5/docbookx.dtd">
<chapter id="proto">
  <title>Protocol Buffers</title>

  <sect1 id="proto-sect-intro">
    <title>Introduction</title>

    <sect2>
      <title>What is Protocol Buffers?</title>

      <para>Protocol Buffers, an open-source tool and library from Google,
      allows you to efficiently encode and decode structured data. It is
      primarily used for data exchange and RPC calls in distributed systems.
      It is an open source project created by Google and it is currently one
      of the most efficient ways to encode, transfer, and decode data. It
      takes into account versioning of data elements and provides libraries to
      parse data in Java, C++, or Python.</para>

      <para>If you've been developing systems to encode data you've likely
      been serializing and deserializing XML or JSON documents, and using
      simple REST services or more complex SOAP services to enable
      interoperability between components in a heterogeneous architecture.
      Using a tool like protocol buffers to encode and decode data into
      binary, only makes sense if you understand the motivation behind the
      tool and the context in which it was created. The development of an
      efficient binary protocol for data interchange makes sense if you look
      at the progression of scalable systems in the last decade.</para>
    </sect2>

    <sect2>
      <title>The Evolution of Internet-scale Architecture</title>

      <para>Consider the architecture of a system designed to handle traffic
      at a large-scale, consumer-facing web site in 2000 as shown in <xref
      linkend="proto-fig-old-system" />. Most large sites were implemented
      using multiple application servers communicating with large relational
      databases. When an organization needed to scale such an architecture it
      would usually involve investing in more powerful hardware or starting to
      invest in technology to cache data at the application server layer. If
      you needed to scale such an architecture, you would scale horizontally
      by adding more application servers in parallel and spending more money
      to acquire more and more horsepower for your database server. The
      beginning of the last decade was all about massive relational databases
      and a very straightforward "N-tiered" approach to architecture.</para>

      <figure float="0" id="proto-fig-old-system">
        <title>Internet-scale Architecture from 2000</title>

        <mediaobject>
          <imageobject role="print">
            <imagedata align="center"
                       fileref="figs/print/proto-old-system.pdf" format="PDF"
                       scalefit="0" width="100%" />
          </imageobject>

          <imageobject role="web">
            <imagedata fileref="figs/web/proto-old-system.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>Fast forward ten years, and we're in a completely different
      technology landscape. Server-grade computers are cheaper, data problems
      are much larger, and the amount of traffic generated by mobile devices
      has skyrocketed. An architecture which would have called for 15 very
      expensive machines in 2000, has morphed into an architecture which
      relies on hundreds or thousands of low-cost servers as shown in <xref
      linkend="proto-fig-modern-system" />. In 2000, your application likely
      read from a database and nothing else. In 2010, your internet-scale
      application uses NoSQL technologies such as Cassandra and solves complex
      problems offline using massive, on-demand Hadoop clusters or Amazon AWS
      to run Map/Reduce jobs.</para>

      <para>In 2000, you didn't have to worry about protocols. Your web
      servers communicated with your application servers using either AJP or
      just acted as HTTP proxies, and your applications retrieved and stored
      data in a database using a JDBC connection. In 2010, you are caching
      objects in memory, you are creating massive lookup tables in a memcached
      server to support sharding, and you are often looking to pass
      information and messages between disparate systems in a heterogeneous
      architecture.</para>

      <para>In summary, internet-scale architectures now involve hundreds of
      machines and are usually very data intensive. Compared to 2000, an
      internet-scale application in 2010 has a lot more moving parts: more
      caching, more communications, more activity. The other big difference
      between the Internet-scale architecture of 2000 and 2010 is variety. In
      2000, your entire architecture was on a single platform such as J2EE. In
      2010, your web application might be in Python while your
      high-performance Map/Reduce cluster might execute Java code, and your
      mobile applications are written in ObjectiveC.</para>

      <figure float="0" id="proto-fig-modern-system">
        <title>Internet-scale Architecture in 2010</title>

        <mediaobject>
          <imageobject role="print">
            <imagedata align="center"
                       fileref="figs/print/proto-modern-system.pdf"
                       format="PDF" scalefit="0" width="100%" />
          </imageobject>

          <imageobject role="web">
            <imagedata fileref="figs/web/proto-modern-system.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
    </sect2>

    <sect2>
      <title>Google's Solution: Polyglot Binary Format</title>

      <para>Given the transformation described in the previous section, what
      do you do when you have thousands of servers, each running components
      written in a handful of programming languages which need to parse
      Terabytes of data in a few hours? The commonly accepted solution is to
      divide and conquer big data. If you have a Terabyte of data to process,
      spawn thousands of jobs on a distributed grid of computers and solve
      problems in parallel. If you need to handle millions of requests a
      minute you are probably starting to think of ways to remove the
      relational database as a direct dependency for anything that requires
      massive scaleability.</para>

      <para>This new heterogenous reality along with a move towards more
      complex systems calls for an efficient, language-neutral way to pass
      data between communicating systems. If you need to blaze through a
      Terabyte of data, you don't want to lug around a weighty XML parser just
      to save some data, beam it to another machine and decode it. Instead,
      you want something binary, quick to encode, quick to decode, and
      cross-platform.</para>

      <para>Your distributed computing grid is going to have to send millions
      of objects back and forth in a way that is both fast and efficient in
      terms of storage and network space. Google's answer: Protocol
      Buffers.</para>
    </sect2>
  </sect1>

  <sect1 id="proto-sect-downloading">
    <title>Downloading Protocol Buffers</title>

    <sect2>
      <title>Problem</title>

      <para>You need to download Protocol Buffers.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>If you are using a Mac OSX or a Linux machine, you should download
      the full source distribution of Protocol Buffers and compile the tool
      locally. If you are using a Windows machine, you can download a
      precompiled version of the Protocol Buffers tool.</para>

      <para>To download Protocol Buffers, go to the Google Code project for
      Protocol Buffers at <ulink
      url="???">http://code.google.com/p/protobuf/</ulink>. Once you've loaded
      this site in a browser, click on one of the featured downloads on the
      right side of the page as shown in <xref
      linkend="proto-fig-site" />.</para>

      <figure float="0" id="proto-fig-site">
        <title>Downloading Protocol Buffers Source</title>

        <mediaobject>
          <imageobject role="print">
            <imagedata align="center" fileref="figs/print/proto-site.pdf"
                       format="PDF" scalefit="0" width="100%" />
          </imageobject>

          <imageobject role="web">
            <imagedata fileref="figs/web/proto-site.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>

      <sect3>
        <title>Linux or Mac OSX Installation</title>

        <para>Download the full source distribution for Protocol Buffers.
        Click on the protobuf-2.0.3.tar.gz file shown in <xref
        linkend="proto-fig-site" /> and save this file to your computer.
        Proceed to the next section, <xref
        linkend="proto-sect-compiling" />.</para>
      </sect3>

      <sect3>
        <title>Windows Installation</title>

        <para>On a Windows machine, download
        <filename>protoc-2.3.0-win32.zip</filename> and unzip the archive.
        This win32 distribution contains two files
        <filename>README.txt</filename> and <filename>protoc.exe</filename>.
        Unzip the archive and put the <filename>protoc.exe</filename> compiler
        in your operating system's <varname>PATH</varname>.</para>

        <screen>C:\Users\tobrien\Downloads:&gt; <command>unzip protoc-2.3.0-win32.zip</command> 
Archive:  protoc-2.3.0-win32.zip
  inflating: readme.txt              
  inflating: protoc.exe </screen>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="proto-sect-compiling">
    <title>Compiling Protocol Buffers</title>

    <sect2>
      <title>Problem</title>

      <para>You have downloaded the Protocol Buffers source distribution and
      you need to compile the <filename>protoc</filename> compiler.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>If you've downloaded the Protocol Buffers source distribution to a
      Mac OSX machine, you will need to install Apple Xcode. The Xcode is
      packaged with a number of utilities including GCC. Apple's Xcode is
      available from Apple here <ulink
      url="http://developer.apple.com/technologies/tools/xcode.html">http://developer.apple.com/technologies/tools/xcode.html</ulink>.</para>

      <para>If you've downloaded the Protocol Buffers source distribution to a
      Linux machine, you will need to install the GCC compiler and
      Make.</para>

      <note>
        <para>If you are using Protocol Buffers on a Windows platform, you
        should just download the binary distribution of the protoc.exe
        compiler as shown in <xref linkend="proto-sect-downloading" />.</para>
      </note>

      <para>The source distribution can be configured, built, and installed
      using the following sequence of commands:</para>

      <screen>~/Downloads/protobuf-2.3.0 $ <command>./configure</command>
checking build system type... i386-apple-darwin10.4.0
checking host system type... i386-apple-darwin10.4.0
checking target system type... i386-apple-darwin10.4.0
...
~/Downloads/protobuf-2.3.0 $ <command>make</command>
make  all-recursive
Making all in .
make[2]: Nothing to be done for `all-am'.
Making all in src
~/Downloads/protobuf-2.3.0 $ <command>sudo make install</command>
Password:
Making install in .
...
</screen>

      <para>First, run <command>./configure</command> to check your system for
      required tools and libraries. Then run <command>make</command> to
      compile the Protocol Buffers tool. Running make will take a few minutes.
      After you have successfully compiled Protocol Buffers, install it by
      running <command>make install</command>. Since installation requires
      administrative privileges, run <command>sudo make install</command> to
      run make as an administrative user.</para>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>To test that the Protocol Buffers compiler was successfully
      installed, run <command>protoc --help</command>. Running this command
      should produce the</para>

      <screen>~ $ <command>protoc --help</command>
Usage: protoc [OPTION] PROTO_FILES
Parse PROTO_FILES and generate output based on the options given:
  -IPATH, --proto_path=PATH   Specify the directory in which to search for
                              imports.  May be specified multiple times;
                              directories will be searched in order.  If not
                              given, the current working directory is used.
  --version                   Show version info and exit.
  -h, --help                  Show this text and exit.
  --encode=MESSAGE_TYPE       Read a text-format message of the given type
                              from standard input and write it in binary
                              to standard output.  The message type must
                              be defined in PROTO_FILES or their imports.
  --decode=MESSAGE_TYPE       Read a binary message of the given type from
                              standard input and write it in text format
                              to standard output.  The message type must
                              be defined in PROTO_FILES or their imports.
  --decode_raw                Read an arbitrary protocol message from
                              standard input and write the raw tag/value
                              pairs in text format to standard output.  No
                              PROTO_FILES should be given when using this
                              flag.
  -oFILE,                     Writes a FileDescriptorSet (a protocol buffer,
    --descriptor_set_out=FILE defined in descriptor.proto) containing all of
                              the input files to FILE.
  --include_imports           When using --descriptor_set_out, also include
                              all dependencies of the input files in the
                              set, so that the set is self-contained.
  --error_format=FORMAT       Set the format in which to print errors.
                              FORMAT may be 'gcc' (the default) or 'msvs'
                              (Microsoft Visual Studio format).
  --plugin=EXECUTABLE         Specifies a plugin executable to use.
                              Normally, protoc searches the PATH for
                              plugins, but you may specify additional
                              executables not in the path using this flag.
                              Additionally, EXECUTABLE may be of the form
                              NAME=PATH, in which case the given plugin name
                              is mapped to the given executable even if
                              the executable's own name differs.
  --cpp_out=OUT_DIR           Generate C++ header and source.
  --java_out=OUT_DIR          Generate Java source file.
  --python_out=OUT_DIR        Generate Python source file.</screen>
    </sect2>
  </sect1>

  <sect1>
    <title>Adding Protocol Buffers as a Project Dependency</title>

    <sect2>
      <title>Problem</title>

      <para>You need to use classes generated by Protocol Buffers in your Java
      project. When the Protocol Buffers compiler generates a collection of
      classes to represent a set of message types, it references the Protocol
      Buffers Java library.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>To use Protocol Buffers in a Maven 2 project, add the following
      dependency to your project's <filename>pom.xml</filename>:</para>

      <example id="proto-ex-adding-depend">
        <title>Adding a Dependency on Commons Digester</title>

        <programlisting language="xml">&lt;dependency&gt;
  &lt;groupId&gt;com.google.protobuf&lt;/groupId&gt;
  &lt;artifactId&gt;protobuf-java&lt;/artifactId&gt;
  &lt;version&gt;2.3.0&lt;/version&gt;
&lt;/dependency&gt;
</programlisting>
      </example>

      <para>If you are not sure what this means, I'd suggest reading <ulink
      url="http://www.sonatype.com/books/maven-book">Maven: The Complete
      Reference</ulink>. When you depend on a library in Maven 2, all you need to
      do is add the dependency <varname>groupId</varname>,
      <varname>artifactId</varname>, and <varname>version</varname> to your
      project's dependencies. Once you do this, Maven 2 will download the
      dependency and make it available on your project's classpath. The
      Protocol Buffers library adds no transitive dependencies to your
      project.</para>
    </sect2>
  </sect1>

  <sect1 id="proto-sect-defining">
    <title>Defining a Message Type</title>

    <sect2>
      <title>Problem</title>

      <para>You need to define a message type that will allow you to encode
      data.</para>

      <para>Assume that you are working for a new startup called Checkin which
      is trying to create a system to track the status of every vehicle on the
      road. They've signed a deal with a large car manufacturer to install a
      mobile device which will communicate a car's status and position every
      five minutes. Since you expect more than ten million registered vehicles
      in the first year of operation, you will need to create a polling format
      that is going to scale and leave some flexibility for future
      changes.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Create a file called <filename>checkin.proto</filename> and define
      all of the message types in this file using the protocol buffer
      language.</para>

      <example id="proto-ex-defining">
        <title>A Protocol Buffers Message Definition</title>

        <programlisting>package com.discursive.cjcook.proto;
message PositionData {
  required uint32 vehicle_id = 1;
  optional float latitude = 2;
  optional float longitude = 3;
  optional float altitude = 4 [default = 0];
  optional int32 speed = 5;
  optional uint64 timestamp = 6;
  optional string status = 7;
}
</programlisting>
      </example>

      <para>To generate a Java class for this message type, run the
      <command>protoc</command> compiler:</para>

      <screen>~/projects/checking/src/main/java $ <command>protoc checkin.proto --java_out=.</command></screen>

      <para>Running the compiler against this definition will create a class
      named <classname>Checkin</classname> in the package
      <package>com.discursive.cjcook.proto</package>.</para>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>The Protocol Buffer compiler created a source file named
      <classname>Checkin.java</classname>. This class contains all of the
      message types defined in <xref linkend="proto-ex-defining" /> as well as
      all of the logic required to encode and parse messages.</para>
    </sect2>
  </sect1>

  <sect1 id="proto-sect-encoding-parsing">
    <title>Encoding and Decoding Messages Using Byte Arrays</title>

    <sect2>
      <title>Problem</title>

      <para>You need to create a message, encode it as a byte array, and then
      parse the byte array back into an object.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use the Java classes generated by the Protocol Buffers compiler to
      create a message. Then call <methodname>toByteArray()</methodname> to
      encode the message. The resulting byte array can be parsed back into a
      <classname>PositionData</classname> message object using the static
      <methodname>parseFrom()</methodname> method. The following CheckingTest
      class uses the Checking class generated in <xref
      linkend="proto-sect-defining" />.</para>

      <example id="proto-ex-encode-parse">
        <title>Encoding and Decoding a Protocol Buffers Message</title>

        <programlisting language="java">package com.discursive.cjcook.proto;

import java.util.Date;

import org.apache.webdav.lib.properties.GetContentLengthProperty;

import com.discursive.cjcook.proto.Checkin.PositionData;
import com.google.protobuf.InvalidProtocolBufferException;

public class CheckinTest {

  public static void main(String[] args) throws Exception {

    // Create a new PositionData Message
    PositionData pData = PositionData.newBuilder()
        .setVehicleId(1)
        .setTimestamp((new Date()).getTime())
        .setAltitude(0.0f)
        .setLatitude(0.0f)
        .setLongitude(0.0f)
        .setSpeed(120)
        .build();

    // Convert the PositionData Message to a Byte Array
    byte[] array = pData.toByteArray();
    System.out.printf("Position Data message %d bytes", array.length);

    // Parse the Byte Array into a PositionData message
    PositionData parsed = PositionData.parseFrom(array);

  }

}
</programlisting>
      </example>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>To create a message, you use a builder object which is specific to
      your message type. The <classname>PositionData</classname> class is
      defined as an inner class on <classname>Checkin</classname>, and the
      <classname>Builder</classname> class is defined as an inner class on
      <classname>PositionData</classname>. When you create a new builder using
      the <methodname>PositionData.newBuilder()</methodname> call you are
      creating a new instance of the
      <classname>PositionData.Builder</classname> class. This
      <classname>Builder</classname> class is used to create a new
      <classname>PositionData</classname> message by chaining a number of
      method calls together like this:</para>

      <programlisting language="java">PositionData pData = PositionData.newBuilder()
        .setVehicleId(1)
        .setTimestamp((new Date()).getTime())
        .setAltitude(0.0f)
        .setLatitude(0.0f)
        .setLongitude(0.0f)
        .setSpeed(120)
        .build();</programlisting>

      <para>With the exception of the last call to
      <methodname>build()</methodname>, each method call in this chain returns
      a <classname>Builder</classname> object. The call to
      <methodname>PositionData.newBuilder()</methodname> and all of the setter
      methods on <classname>Builder</classname> can be chainged together and
      terminated with a call to <methodname>build()</methodname> which will
      return a <classname>PositionData</classname> message object.</para>

      <para>The rest of this example is straightforward: to turn a
      <classname>PositionData</classname> object into a byte array call the
      instance method <methodname>toByteArray()</methodname>. The
      <methodname>toByteArray()</methodname> method is not defined in the
      <filename>Checkin.java</filename> class, it is defined in the
      <classname>AbstractMessageLite</classname> class which is the parent of
      the parent's parent (the <classname>PositionData</classname> class'
      Great Grandmother). <classname>Checkin.PositionData</classname> extends
      <classname>GeneratedMessage</classname> which extends
      <classname>AbstractMessage</classname> which, in turn, extends
      <classname>AbstractMessageLite</classname>. This top-level
      <classname>AbstractMessageLite</classname> class implements the
      <classname>MessageLite</classname> interface which contains all of the
      methods to write a message to a <classname>byte[]</classname> or a
      <classname>ByteString</classname>.</para>

      <para>To parse the message from a <classname>byte[]</classname> back
      into a <classname>PositionData</classname> object, call the static
      method <methodname>parseFrom()</methodname> on
      <classname>PositionData</classname>. This method will invoke a method on
      the <classname>PositionData.Builder</classname> class. The builder class
      follows a similar inheritance pattern to the
      <classname>PositionData</classname> class. The
      <classname>PositionData.Builder</classname> class extends the
      <classname>GeneratedMessage.Builder</classname> class which extends the
      <classname>AbstractMessage.Builder</classname> class which, in turn,
      extends the <classname>AbstractMessageLite.Builder</classname> class.
      This <classname>AbstractMessageLite.Builder</classname> class then
      implements the <classname>MessageLite.Builder</classname> interface
      which defines methods to create a builder and parse data.</para>
    </sect2>
  </sect1>

  <sect1 id="proto-sect-performance">
    <title>Measuring Protocol Buffers Performance</title>

    <sect2>
      <title>Problem</title>

      <para>You need to justify the use of Protocol Buffers and compare the
      performance of generating and parsing a Protocol Buffer message to the
      performance of XML.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Create a test class to measure timing using the message definition
      created in the previous section. The following example creates three
      million <classname>PositionData</classname> records and then converts
      them into <classname>byte[]</classname> stored in memory. It then
      decodes these <classname>byte[]</classname> messages and stores the
      result in a new <classname>PositionData</classname> object.</para>

      <example id="proto-ex-perform">
        <title>Measuring Average Execution Time for Protocol Buffers
        Operations</title>

        <programlisting language="java">package com.discursive.cjcook.proto;

import java.util.Date;

import com.discursive.cjcook.proto.Checkin.PositionData;
import com.google.protobuf.InvalidProtocolBufferException;

public class CheckinTiming {

  public static void main(String[] args) throws Exception {

    int size = 3000000;

    PositionData[] pArray = new PositionData[size];

    Date now = new Date();
    long preCreate = (new Date()).getTime();
    for( int i = 0; i &lt; size; i++ ) {
      PositionData pData = PositionData.newBuilder()
        .setVehicleId(1)
        .setTimestamp( now.getTime() )
        .setAltitude( 123.0f )
        .setLatitude( 1.0f )
        .setLongitude( 1.0f )
        .setSpeed( 120 )
        .build();
      pArray[i] = pData;
    }
    long postCreate = (new Date()).getTime();
    float createTime = 
      ((float) (postCreate - preCreate) / 
          (float) size ) * 1000 * 1000;

    System.out.printf( "Create One PositionData %.0f ns\n", createTime);
  
    byte[][] encodedArray = new byte[size][];
    long preEncode = (new Date()).getTime();
    for( int i = 0; i &lt; size; i++ ) {
      byte[] positionBArray = pArray[i].toByteArray();
      encodedArray[i] = positionBArray;

    }
    long postEncode = (new Date()).getTime();
    float encodeTime = 
      ((float) (postEncode - preEncode) / 
          (float) size ) * 1000 * 1000;
    System.out.printf( "Encode One PositionData to byte[] %.0f ns\n", 
                       encodeTime);

    PositionData[] decodedArray = new PositionData[size];
    long preDecode = (new Date()).getTime();
    for( int i = 0; i &lt; size; i++) {
      PositionData pData = PositionData.parseFrom( encodedArray[i] );
      decodedArray[i] = pData;
    }
    long postDecode = (new Date()).getTime();
    float decodeTime = 
      ((float) (postDecode - preDecode) / 
         (float) size ) * 1000 * 1000;
    System.out.printf( "Decode One PositionData from byte[] %.0f ns\n", 
                       decodeTime);
  }
}
</programlisting>
      </example>

      <para>Running this simple test program generates the following
      output<footnote>
          <para>You results may vary. This particular performance test was run
          with a 512 MB heap on a mid-level MacBook Pro with a 2.4 Ghz
          processor in 2010.</para>
        </footnote>:</para>

      <screen>Create One PositionData 404 ns
Encode One PositionData to byte[] 595 ns
Decode One PositionData from byte[] 970 ns</screen>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>Each operation runs so quickly with Protocol Buffers we have to
      multiply the unit time for each operation by one million to convert
      these numbers to nanoseconds. These numbers are going to vary on
      different platforms, but this is the general ballpark for Protocol
      Buffer encoding and decoding operations. Creating a Protocol Buffer
      message will take approximately 500 nanoseconds, encoding it to a byte
      array will take 500 ns, and parsing the byte array will take about a
      microsecond.</para>

      <para>If you are trying to support a decision to use Protocol Buffers
      for encoding data, execution time for encoding and parsing in Java is
      only one part of the argument. You should compare these numbers with the
      execution times for encoding and decoding data to and from JSON and
      XML.</para>

      <para>You should also compare the size of the resulting messages. If you
      are building a production network which needs to tackle big data, a 26
      byte PositionData Protocol Buffers message is going to me preferable to
      a 120 byte PositionData XML document. Using Protocol Buffers doesn't
      just speed up parsing it saves you storage space and network bandwidth.
      As data challenges in Internet-scale systems continue to grow, Protocol
      Buffers scores a Hat-trick<footnote>
          <para>Hat-trick: In sport, a hat-trick (or hat trick) means to
          achieve a positive feat in the sport three times during a game, or
          other achievements based on threes. (Source: <ulink
          url="http://en.wikipedia.org/wiki/Hat-trick">http://en.wikipedia.org/wiki/Hat-trick</ulink>)</para>
        </footnote>: helping you save CPU time, disk space, and network
      bandwith.</para>
    </sect2>
  </sect1>
</chapter>
