<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://mars.discursive.com/docbook/xml/4.5/docbookx.dtd">
<chapter id="lang" label="1">
  <title>Supplements to the Java 2 Platform</title>

  <sect1 id="lang-sect-intro">
    <title>Introduction</title>

    <para>This chapter introduces utilities that augment the <indexterm
        id="lang-ITERM-1715" significance="normal">
        <primary>Java 2 Standard Edition</primary>

        <see>J2SE</see>
      </indexterm>Java 2 Standard <indexterm id="lang-ITERM-1716"
        significance="normal">
        <primary>J2SE (Java 2 Standard Edition)</primary>
      </indexterm>Edition (J2SE), providing classes and utilities that make
    some of the more mundane programming tasks more straightforward. Commons
    Lang is a collection of useful supplements to the J2SE. This package fills
    gaps present in the standard Java API and provides a number of simple,
    time-saving utility classes. Sun's Javadoc for the <literal
    moreinfo="none">java.lang</literal> package in the J2SE states that the
    package "provides classes that are fundamental to the design of the Java
    programming language." In the same vein, Commons Lang provides classes
    that augment the fundamental design of the Java programming
    language.</para>

    <para>You may be tempted to skip the simple recipes presented in this
    chapter and continue on to more advanced topics in this text. String
    manipulation, date truncation, and <literal moreinfo="none">toString(
    )</literal> methods do not inspire the sense of mystery and genius one
    feels when working with <indexterm id="lang-ITERM-1717"
        significance="normal">
        <primary>Extensible Markup Language</primary>

        <see>XML</see>
      </indexterm>Extensible Markup Language (XML) or<indexterm
        id="lang-ITERM-1718" significance="normal">
        <primary>XML (Extensible Markup Language)</primary>
      </indexterm> an open source text-to-speech engine. But, even if you are
    the most fluent speaker of Java, there are lessons to be learned from the
    utilities introduced in this chapter; a simple trick learned here may save
    you a few minutes every single day. Don't waste your time rewriting and
    maintaining utilities that already exist in Commons Lang; there are more
    interesting problems to be solved, and building <literal
    moreinfo="none">hashcode()</literal> functions is not one of them.</para>

    <sidebar id="lang-SIDEBAR-1">
      <title>Java's Continued Progress</title>

      <para>The initial version of this book had a note at this point that
      discussed the release of Tiger (Java 1.5) and how Tiger's introduction
      of new language features had made some features of Commons Lang wholly
      unnecessary. That same note also discussed how Commons Lang could still
      be used on 1.3 and 1.4 JVMs. Since this book was initial published in
      2004, Java has had another major release (Java 6) and we are currently
      expecting the release of Java 7. This version of the book has phased out
      some of the recipes that duplicate Java 5 behavior. I hate to say this
      because I know that there is still some poor developer saddled with
      supporting some legacy 1.3 application... we're pulling the plug on the
      recipes that were aimed at people still using 1.4.</para>
    </sidebar>
  </sect1>

  <sect1 id="lang-sect-obtaining" label="1.1" role="Recipe">
    <title>Depending on Commons Lang</title>

    <sect2>
      <title>Problem</title>

      <para>You want to use <indexterm class="startofrange"
          id="lang-ITERM-1722" significance="normal">
          <primary>Commons Lang</primary>

          <secondary>downloading</secondary>
        </indexterm> <indexterm class="startofrange" id="lang-ITERM-1723"
          significance="normal">
          <primary>downloading</primary>

          <secondary>Commons Lang</secondary>
        </indexterm>Commons Lang because your program needs to use some of the
      simple utilities this component provides, such as array manipulation,
      date manipulation, and enums.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>To use Commons Lang in a Maven 2 project, add the following
      dependency to your project's <filename>pom.xml</filename>:</para>

      <example id="lang-ex-add-depend-lang">
        <title>Adding a Dependency on Commons Lang</title>

        <programlisting language="xml" db:artifact="${project.groupId}:cjcook-examples:${project.version}:src:zip"
                        db:file="cjcook-examples-${project.version}/pom.xml"
                        db:xpath="//dependency[artifactId='commons-lang']"
                        xmlns:db="http://discursive.com/plugins/docbook"></programlisting>
      </example>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>If you are not sure what this means, I'd suggest reading <ulink
      url="http://www.sonatype.com/books/maven-book">Maven: The Complete Reference</ulink>. When you depend on a library in Maven 2, all you need to
      do is add the dependency <varname>groupId</varname>,
      <varname>artifactId</varname>, and <varname>version</varname> to your
      project's dependencies. Once you do this, Maven 2 will download the
      dependency and make it available on your project's classpath.</para>
    </sect2>
  </sect1>

  <sect1 id="lang-sect-automate-tostring" label="1.4" role="Recipe">
    <title>Automating the Generation of toString( ) Content</title>

    <sect2>
      <title>Problem</title>

      <para>You want to automate the creation of <literal
      moreinfo="none">toString( )</literal> methods.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use the Commons Lang<indexterm class="startofrange"
          id="lang-ITERM-1748" significance="normal">
          <primary>Commons Lang</primary>

          <secondary>toString( ) methods</secondary>

          <tertiary>automation</tertiary>
        </indexterm> <indexterm class="startofrange" id="lang-ITERM-1749"
          significance="normal">
          <primary>toString( ) methods</primary>

          <secondary>automation</secondary>
        </indexterm> <indexterm class="startofrange" id="lang-ITERM-1750"
          significance="normal">
          <primary>methods</primary>

          <secondary>toString( )</secondary>

          <tertiary>automation</tertiary>
        </indexterm> <indexterm class="startofrange" id="lang-ITERM-1751"
          significance="normal">
          <primary>automation</primary>

          <secondary>toString( ) methods</secondary>
        </indexterm> <literal
      moreinfo="none">ReflectionToStringBuilder</literal> or <literal
      moreinfo="none">ToStringBuilder</literal> and <literal
      moreinfo="none">ToStringBuilder</literal> to create <literal
      moreinfo="none">toString()</literal> methods. The following code is an
      example of a <literal moreinfo="none">toString( )</literal> method,
      which uses a <indexterm id="lang-ITERM-1752" significance="normal">
          <primary>reflection builders</primary>
        </indexterm>reflection builder:</para>

      <programlisting language="java" db:artifact="${project.groupId}:cjcook-examples:${project.version}:src:zip"
                      db:excerpt="lang_tostring_solution"
                      db:file="cjcook-examples-${project.version}/src/main/java/com/discursive/jccook/lang/builders/reflect/PoliticalCandidate.java"
                      xmlns:db="http://discursive.com/plugins/docbook"></programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>Assume that you have an object named <literal
      moreinfo="none">PoliticalCandidate</literal>—a bean that represents some
      information about a presidential candidate. This bean has a set of
      properties: <literal moreinfo="none">firstName</literal>, <literal
      moreinfo="none">lastName</literal>, <literal
      moreinfo="none">dateOfBirth</literal>, <literal
      moreinfo="none">moneyRaised</literal>, and <literal
      moreinfo="none">homeState</literal>. <link linkend="lang-ex-1">Example
      1-1</link> shows the <literal
      moreinfo="none">PoliticalCandidate</literal> class using a <literal
      moreinfo="none">ReflectionToStringBuilder</literal>; the getter and
      setter methods have been omitted for brevity.</para>

      <example id="lang-ex-1" label="1-1">
        <title>The PoliticalCandidate class using
        ReflectionToStringBuilder</title>

        <programlisting language="java" db:artifact="${project.groupId}:cjcook-examples:${project.version}:src:zip"
                        db:excerpt="lang-ex-1"
                        db:file="cjcook-examples-${project.version}/src/main/java/com/discursive/jccook/lang/builders/reflect/PoliticalCandidate.java"
                        xmlns:db="http://discursive.com/plugins/docbook"></programlisting>
      </example>

      <para>The process of keeping the contents of a <literal
      moreinfo="none">toString()</literal> method synchronized with a changing
      object model becomes a chore (usually a forgotten one). Commons Lang
      includes a fairly simple utility designed to automate this chore using
      reflection. The <literal moreinfo="none">ToStringBuilder</literal>
      <indexterm id="lang-ITERM-1753" significance="normal">
          <primary>ToStringBuilder class</primary>
        </indexterm> <indexterm id="lang-ITERM-1754" significance="normal">
          <primary>classes</primary>

          <secondary>ToStringBuilder</secondary>
        </indexterm> class and its extension, <literal
      moreinfo="none">ReflectionToStringBuilder</literal> <indexterm
          id="lang-ITERM-1755" significance="normal">
          <primary>ReflectionToStringBuilder class</primary>
        </indexterm> <indexterm id="lang-ITERM-1756" significance="normal">
          <primary>classes</primary>

          <secondary>ReflectionToStringBuilder</secondary>
        </indexterm>, can condense a large <literal moreinfo="none">toString(
      )</literal> method body into one line of code. Most importantly, the
      <literal moreinfo="none">ReflectionToStringBuilder</literal> reflects
      any future changes that are made to the object model. The following code
      demonstrates the output of a string <indexterm id="lang-ITERM-1757"
          significance="normal">
          <primary>strings</primary>

          <secondary>built via reflection</secondary>
        </indexterm>built via reflection:</para>

      <programlisting language="java" db:artifact="${project.groupId}:cjcook-examples:${project.version}:src:zip"
                      db:excerpt="lang-ex-sample-1"
                      db:file="cjcook-examples-${project.version}/src/main/java/com/discursive/jccook/lang/builders/reflect/PoliticalCandidate.java"
                      xmlns:db="http://discursive.com/plugins/docbook"></programlisting>

      <para>Assume that the <literal moreinfo="none">State</literal> object is
      another bean using the same <literal
      moreinfo="none">ReflectionToStringBuilder</literal>. The code above sets
      the properties of a bean and produces the following output:</para>

      <programlisting language="java" db:artifact="${project.groupId}:cjcook-examples:${project.version}:jar-with-dependencies:jar"
                      db:main-class="com.discursive.jccook.lang.builders.reflect.PoliticalCandidate"
                      db:type="exec" db:wrap="force"
                      xmlns:db="http://discursive.com/plugins/docbook"></programlisting>

      <tip id="lang-NOTE-43" role="ora">
        <para>As in other cases in this book, I've applied a minimal amount of
        formatting to the output so that it fits on the printed page. Your
        results will be the same in terms of content but will be all on one
        long line.</para>
      </tip>

      <para>This is not the most readable piece of information in the world,
      but it <emphasis>was</emphasis> automatically generated. Keeping a
      <literal moreinfo="none">toString( )</literal> method up-to-date in an
      object model that contains one hundred entities is next to impossible
      under the constraints of a deadline and a budget. If your objects have
      meaningful <literal moreinfo="none">toString( )</literal> methods, it
      will be much easier to diagnose problems in your application. If you use
      the <literal moreinfo="none">ReflectionToStringBuilder</literal>, you
      are assured that the message printed out will be accurate; the
      alternative is to have a message that may or may not <indexterm
      class="endofrange" id="lang-ITERM-1758" significance="normal"
      startref="lang-ITERM-1748"></indexterm> <indexterm class="endofrange"
      id="lang-ITERM-1759" significance="normal"
      startref="lang-ITERM-1749"></indexterm> <indexterm class="endofrange"
      id="lang-ITERM-1760" significance="normal"
      startref="lang-ITERM-1750"></indexterm> <indexterm class="endofrange"
      id="lang-ITERM-1761" significance="normal"
      startref="lang-ITERM-1751"></indexterm>be relevant—trusting developers
      to keep <literal moreinfo="none">toString( )</literal> methods updated
      manually.</para>

      <warning id="lang-NOTE-44" role="ora">
        <para>This utility uses the class <literal
        moreinfo="none">AccessibleObject</literal> in the J2SE reflection
        package to bypass access modifiers and access private member variables
        of an object directly. If your system is running under a restrictive
        <literal moreinfo="none">SecurityManager</literal>, you may need to
        alter your configuration to allow Commons Lang to bypass these
        security restrictions. Only use this reflection builder if you are
        certain that your code will run in an environment without a
        restrictive security policy. I use this utility in a system that runs
        on a few servers in a known location, but if I were writing a reusable
        library, a reflection builder would not be feasible; if someone were
        to use my library in an environment with a different security policy,
        calling a <literal moreinfo="none">toString( )</literal> may cause
        problems. The relevant permission is the <literal
        moreinfo="none">suppressAccessChecks</literal> permission target of
        the <literal
        moreinfo="none">java.lang.reflect.ReflectPermission</literal>
        class.</para>
      </warning>
    </sect2>
  </sect1>

  <sect1 id="lang-sect-customizing-tostring" label="1.5" role="Recipe">
    <title>Customizing Generated toString( ) Content</title>

    <sect2>
      <title>Problem</title>

      <para>You need to automate <literal moreinfo="none">toString(
      )</literal> <indexterm class="startofrange" id="lang-ITERM-1762"
          significance="normal">
          <primary>Commons Lang</primary>

          <secondary>toString( ) methods</secondary>

          <tertiary>customization</tertiary>
        </indexterm> <indexterm class="startofrange" id="lang-ITERM-1763"
          significance="normal">
          <primary>toString( ) methods</primary>

          <secondary>customization</secondary>
        </indexterm> <indexterm class="startofrange" id="lang-ITERM-1764"
          significance="normal">
          <primary>methods</primary>

          <secondary>toString( )</secondary>

          <tertiary>customization</tertiary>
        </indexterm> <indexterm class="startofrange" id="lang-ITERM-1765"
          significance="normal">
          <primary>customization</primary>

          <secondary>toString( ) methods</secondary>
        </indexterm>while retaining control over the output, contents, and
      formatting.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>In addition to the <literal
      moreinfo="none">ReflectionToStringBuilder</literal>, Commons Lang
      provides for customization via the <literal
      moreinfo="none">ToStringBuilder</literal> <indexterm
          id="lang-ITERM-1766" significance="normal">
          <primary>ToStringBuilder class</primary>
        </indexterm> <indexterm id="lang-ITERM-1767" significance="normal">
          <primary>customization</primary>
        </indexterm> <indexterm id="lang-ITERM-1768" significance="normal">
          <primary>classes</primary>

          <secondary>ToStringBuilder</secondary>

          <tertiary>customization</tertiary>
        </indexterm> <indexterm id="lang-ITERM-1769" significance="normal">
          <primary>customization</primary>

          <secondary>ToStringBuilder class</secondary>
        </indexterm> and <literal moreinfo="none">ToStringStyle</literal>
      <indexterm id="lang-ITERM-1770" significance="normal">
          <primary>ToStringStyle class customization</primary>
        </indexterm> <indexterm id="lang-ITERM-1771" significance="normal">
          <primary>classes</primary>

          <secondary>ToStringStyle</secondary>
        </indexterm> <indexterm id="lang-ITERM-1772" significance="normal">
          <primary>customization</primary>

          <secondary>ToStringStyle class</secondary>
        </indexterm> class. From the previous recipe, if you only want the
      <literal moreinfo="none">PoliticalCandidate</literal> <literal
      moreinfo="none">toString( )</literal> method to print <literal
      moreinfo="none">lastName</literal> and <literal
      moreinfo="none">firstName</literal>, use the <literal
      moreinfo="none">ToStringBuilder</literal> class and pass in a <literal
      moreinfo="none">ToStringStyle</literal> object. The following example
      demonstrates a <literal moreinfo="none">toString( )</literal> method
      implementation that customizes both style and content:</para>

      <programlisting language="java" db:artifact="${project.groupId}:cjcook-examples:${project.version}:src:zip"
                      db:excerpt="lang_custom_tostring_solution"
                      db:file="cjcook-examples-${project.version}/src/main/java/com/discursive/jccook/lang/builders/customized/PoliticalCandidate.java"
                      xmlns:db="http://discursive.com/plugins/docbook"></programlisting>

      <para>Calling <literal moreinfo="none">toString( )</literal> on this
      object will produce the following output containing only the two
      properties specified as parameters to <literal moreinfo="none">append(
      )</literal>:</para>

      <programlisting language="java" db:artifact="${project.groupId}:cjcook-examples:${project.version}:jar-with-dependencies:jar"
                      db:main-class="com.discursive.jccook.lang.builders.customized.PoliticalCandidate"
                      db:type="exec"
                      xmlns:db="http://discursive.com/plugins/docbook"></programlisting>

      <tip id="lang-NOTE-46" role="ora">
        <para>Unlike the output shown in <link
        linkend="lang-sect-automate-tostring">Recipe 1.4</link>, this output
        is shown <emphasis>exactly</emphasis> as it appears on your
        screen.</para>
      </tip>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>Generating <literal moreinfo="none">toString( )</literal> content
      using reflection saves time, but the trade-off is that the code using
      reflection prints out every member variable of a given class. What do
      you do when the desired behavior is to print out only a few selected
      variables from a given class? What if your objects are very <filename
      moreinfo="none">wide</filename>, in that they have many properties that
      you don't want to print out in a <literal
      moreinfo="none">toString()</literal> method? There are situations where
      an object could have a large number of properties or when a particular
      property of an object might contain a large amount of textual content.
      In these situations, it would be counterproductive to use <literal
      moreinfo="none">ReflectionToStringBuilder</literal> to print out every
      member variable in a class.</para>

      <para>Use a <literal moreinfo="none">ToStringBuilder</literal> and
      customize the contents of the output with a static member of a <literal
      moreinfo="none">ToStringStyle</literal>. The constructor of a <literal
      moreinfo="none">ToStringBuilder</literal> takes an object instance and a
      <literal moreinfo="none">ToStringStyle</literal>, returning an instance
      of a <literal moreinfo="none">ToStringBuilder</literal>. This builder is
      then customized by calling <literal moreinfo="none">append( )</literal>,
      which lets you specify the properties you want included in the output.
      To customize the contents of a <literal
      moreinfo="none">ToStringBuilder</literal>, you must manually add
      <indexterm id="lang-ITERM-1773" significance="normal">
          <primary>adding</primary>

          <secondary>properties</secondary>
        </indexterm> <indexterm id="lang-ITERM-1774" significance="normal">
          <primary>properties</primary>

          <secondary>adding</secondary>
        </indexterm> <indexterm id="lang-ITERM-1775" significance="normal">
          <primary>instances</primary>

          <secondary>properties, adding</secondary>
        </indexterm>each property to an instance of a builder. The <literal
      moreinfo="none">append( )</literal> <indexterm id="lang-ITERM-1776"
          significance="normal">
          <primary>append( ) method</primary>
        </indexterm> <indexterm id="lang-ITERM-1777" significance="normal">
          <primary>methods</primary>

          <secondary>append( )</secondary>
        </indexterm> method accepts all primitives, objects, and arrays. <link
      linkend="lang-TABLE-1">Table 1-1</link> summarizes the variations of
      <literal moreinfo="none">append( )</literal> for integer primitives and
      objects.</para>

      <table id="lang-TABLE-1" label="1-1">
        <title>Variations of ToStringBuilder append( )</title>

        <tgroup cols="2">
          <colspec colname="col1" colnum="1" />

          <colspec colname="col2" colnum="2" />

          <thead>
            <row>
              <entry><para>ToStringBuilder method</para></entry>

              <entry><para>Description</para></entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><para> <literal moreinfo="none">append(int
              value)</literal> </para></entry>

              <entry><para>Appends the value of the integer.</para></entry>
            </row>

            <row>
              <entry><para> <literal moreinfo="none">append(String n, int
              value)</literal> </para></entry>

              <entry><para>Appends the value of the integer and the name of
              the property.</para></entry>
            </row>

            <row>
              <entry><para> <literal moreinfo="none">append(Object
              value)</literal> </para></entry>

              <entry><para>Appends the <literal moreinfo="none">toString(
              )</literal> of an Object.</para></entry>
            </row>

            <row>
              <entry><para> <literal moreinfo="none">append(String n, Object
              value)</literal> </para></entry>

              <entry><para>Appends the <literal moreinfo="none">toString(
              )</literal> of an Object and the name of the
              property.</para></entry>
            </row>

            <row>
              <entry><para> <literal moreinfo="none">append(int[]
              array)append(Object[] array)</literal> </para></entry>

              <entry><para>Appends the formatted contents of
              array.</para></entry>
            </row>

            <row>
              <entry><para> <literal moreinfo="none">append(String n int[]
              array)append(String n, Object[] array)</literal> </para></entry>

              <entry><para>Appends the property name and the size of an
              array</para></entry>
            </row>

            <row>
              <entry><para> <literal moreinfo="none">append(String n, int[]
              array, boolean detail)</literal> </para></entry>

              <entry><para>Appends the property name and the full contents of
              an array.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>The <literal moreinfo="none">ToStringStyle</literal> class
      provides a mechanism to customize the output of a <literal
      moreinfo="none">ToStringBuilder</literal>, and this class contains a few
      <indexterm id="lang-ITERM-1778" significance="normal">
          <primary>built-in styles</primary>
        </indexterm> <indexterm id="lang-ITERM-1779" significance="normal">
          <primary>ToStringBuilder class</primary>
        </indexterm> <indexterm id="lang-ITERM-1780" significance="normal">
          <primary>styles</primary>
        </indexterm> <indexterm id="lang-ITERM-1781" significance="normal">
          <primary>classes</primary>

          <secondary>ToStringBuilder</secondary>

          <tertiary>styles</tertiary>
        </indexterm>built-in styles. One example is the <literal
      moreinfo="none">ToStringStyle.MULTI_LINE_STYLE</literal>, which puts a
      newline character between every property. Another example is the
      <literal moreinfo="none">ToStringStyle.SIMPLE_STYLE</literal>, which
      simply prints the value of every member variable. The following list
      provides an example of each of these preset styles:</para>

      <variablelist>
        <varlistentry>
          <term><literal
          moreinfo="none">ToStringStyle.DEFAULT_STYLE</literal></term>

          <listitem>
            <programlisting format="linespecific" id="I_1_tt10">com.discursive.jccook.lang.builders.
PoliticalCandidate@1cd2e5f[lastName=Jefferson,firstName=Thomas]</programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal
          moreinfo="none">ToStringStyle.MULTI_LINE_STYLE</literal></term>

          <listitem>
            <programlisting format="linespecific" id="I_1_tt11">com.discursive.jccook.lang.builders.PoliticalCandidate@1cd2e5f[
  lastName=Jefferson
  firstName=Thomas
]</programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal
          moreinfo="none">ToStringStyle.NO_FIELD_NAMES_STYLE</literal></term>

          <listitem>
            <programlisting format="linespecific" id="I_1_tt12">com.discursive.jccook.lang.builders.PoliticalCandidate@1cd2e5f[Jefferson,Thomas]</programlisting>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal
          moreinfo="none">ToStringStyle.SIMPLE_STYLE</literal></term>

          <listitem>
            <programlisting format="linespecific" id="I_1_tt13">Jefferson,Thomas</programlisting>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>What's the big deal about <literal
      moreinfo="none">toString()</literal> methods? This is about accuracy and
      keeping messages relevant in an evolving system. All useful error
      messages include a string representation of the object involved in the
      error. If you get an exception, and you print the value of an object, it
      is usually clear what is causing that exception. In the absence of
      sensible logging, it is next to impossible to debug a system without
      diving directly into a debugger. This is especially true if you are
      trying to diagnose the cause of an infrequent problem that only affects
      a tiny percentage of users who only encounter a problem if they perform
      a very specific action in a specific context. In these cases, it is
      helpful to know the internal state of every object involved in the
      error, and <literal moreinfo="none">toString( )</literal> is the easiest
      way to print this out to a log. Automate your <literal
      moreinfo="none">toString( )</literal> method, and your error messages
      will be more <indexterm class="endofrange" id="lang-ITERM-1782"
      significance="normal" startref="lang-ITERM-1762"></indexterm> <indexterm
      class="endofrange" id="lang-ITERM-1783" significance="normal"
      startref="lang-ITERM-1763"></indexterm> <indexterm class="endofrange"
      id="lang-ITERM-1784" significance="normal"
      startref="lang-ITERM-1764"></indexterm> <indexterm class="endofrange"
      id="lang-ITERM-1785" significance="normal"
      startref="lang-ITERM-1765"></indexterm>meaningful.</para>
    </sect2>
  </sect1>

  <sect1 id="lang-sect-automate-hashcode-equals" label="1.6" role="Recipe">
    <title>Automating hashCode( ) and equals( )</title>

    <sect2>
      <title>Problem</title>

      <para>You need a way to automatically<indexterm class="startofrange"
          id="lang-ITERM-1786" significance="normal">
          <primary>Commons Lang</primary>

          <secondary>hashcode( ) method</secondary>
        </indexterm> <indexterm class="startofrange" id="lang-ITERM-1787"
          significance="normal">
          <primary>hashcode( ) method automation</primary>
        </indexterm> <indexterm class="startofrange" id="lang-ITERM-1788"
          significance="normal">
          <primary>methods</primary>

          <secondary>hashcode( ) automation</secondary>
        </indexterm> <indexterm class="startofrange" id="lang-ITERM-1789"
          significance="normal">
          <primary>automation</primary>

          <secondary>hashcode( ) method</secondary>
        </indexterm> implement <literal moreinfo="none">equals()</literal> and
      <indexterm class="startofrange" id="lang-ITERM-1790"
          significance="normal">
          <primary>Commons Lang</primary>

          <secondary>equals( ) method</secondary>
        </indexterm> <indexterm class="startofrange" id="lang-ITERM-1791"
          significance="normal">
          <primary>automation</primary>
        </indexterm> <indexterm class="startofrange" id="lang-ITERM-1792"
          significance="normal">
          <primary>equals( ) method automation</primary>
        </indexterm> <indexterm class="startofrange" id="lang-ITERM-1793"
          significance="normal">
          <primary>methods</primary>

          <secondary>equals( ) automation</secondary>
        </indexterm> <indexterm class="startofrange" id="lang-ITERM-1794"
          significance="normal">
          <primary>automation</primary>

          <secondary>equals( ) method</secondary>
        </indexterm> <literal moreinfo="none">hashCode( )</literal>
      methods.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Commons Lang <literal moreinfo="none">EqualsBuilder</literal>
      <indexterm id="lang-ITERM-1795" significance="normal">
          <primary>EqualsBuilder class</primary>
        </indexterm> <indexterm id="lang-ITERM-1796" significance="normal">
          <primary>classes</primary>

          <secondary>EqualsBuilder</secondary>
        </indexterm> and <literal moreinfo="none">HashCodeBuilder</literal>
      <indexterm id="lang-ITERM-1797" significance="normal">
          <primary>HashCodeBuilder class</primary>
        </indexterm> <indexterm id="lang-ITERM-1798" significance="normal">
          <primary>classes</primary>

          <secondary>HashCodeBuilder</secondary>
        </indexterm> provide methods to automate both the <literal
      moreinfo="none">equals( )</literal> and <literal
      moreinfo="none">hashCode( )</literal>. <link linkend="lang-ex-2">Example
      1-2</link> briefly demonstrates these two builders using the <literal
      moreinfo="none">PoliticalCandidate</literal> bean from the previous two
      recipes.</para>

      <example id="lang-ex-2" label="1-2">
        <title>Automating hashCode( ) and equals( )</title>

        <programlisting language="java" db:artifact="${project.groupId}:cjcook-examples:${project.version}:src:zip"
                        db:excerpt="lang-ex-2"
                        db:file="cjcook-examples-${project.version}/src/main/java/com/discursive/jccook/lang/builders/equals/PoliticalCandidate.java"
                        xmlns:db="http://discursive.com/plugins/docbook"></programlisting>
      </example>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para><literal moreinfo="none">HashCodeBuilder</literal> has a
      constructor that takes two integer primitives. These primitives are used
      as an offset when creating a hash code; both numbers should be odd,
      nonzero, and prime. The <literal
      moreinfo="none">HashCodeBuilder</literal> in <link
      linkend="lang-ex-2">Example 1-2</link> is configured to use the <literal
      moreinfo="none">firstName</literal> and the <literal
      moreinfo="none">lastName</literal> of the <literal
      moreinfo="none">PoliticalCandidate</literal> object; therefore, two
      <literal moreinfo="none">PoliticalCandidate</literal> objects with the
      same first and last name will have identical hash codes. If a hash code
      depends on every field in a class, you may use reflection to generate a
      hash code:</para>

      <programlisting language="java" format="linespecific" id="I_1_tt14">public int hashCode( ) {
    return HashCodeBuilder.reflectionHashCode(this);
}</programlisting>

      <para>Like <literal moreinfo="none">ToStringBuilder</literal> and
      <literal moreinfo="none">HashCodeBuilder</literal>, the <literal
      moreinfo="none">EqualsBuilder</literal> is also configured via an
      <literal moreinfo="none">append( )</literal> method, which takes two
      arguments to compare. <literal moreinfo="none">EqualsBuilder</literal>'s
      <literal moreinfo="none">append( )</literal> method accepts all
      primitives, objects, and arrays, and one advantage of <literal
      moreinfo="none">EqualsBuilder</literal> is the ability to compare two
      arrays by simply passing them to <literal moreinfo="none">append(
      )</literal>. When this happens, <literal
      moreinfo="none">EqualsBuilder</literal> compares every element of an
      array:</para>

      <programlisting language="java" format="linespecific" id="I_1_tt15">int[] array1 = new int[] { 1, 3, 4, 2, 5, 3, 4, 5, 3, 4 };
int[] array2 = new int[] { 1, 3, 4, 2, 5, 3, 4, 5, 3, 4 };
int[] array3 = new int[] { 3, 3, 3, 3, 3, 3, 3, 3, 3, 3 };

EqualsBuilder builder = new EqualsBuilder( );
builder.append( array1, array2 );
boolean firstTwoEqual = builder.isEquals( );
System.out.println( "Is array1 equal to array2? " + firstTwoEqual );

EqualsBuilder builder = new EqualsBuilder( );
builder.append( array2, array3 );
boolean lastTwoEqual = builder.isEquals( );
System.out.println( "Is array2 equal to array3? " + lastTwoEqual );</programlisting>

      <para>The <literal moreinfo="none">EqualsBuilder</literal> compares the
      contents of two arrays, checking to see that the corresponding element
      is equal. The following output is produced:</para>

      <programlisting format="linespecific" id="I_1_tt16">Is array1 equal to array2? true
Is array2 equal to array3? false</programlisting>

      <para>If two classes are equal only if every field is equal, the
      <literal moreinfo="none">EqualsBuilder</literal> can compare two objects
      using reflection as in the following code:</para>

      <programlisting language="java" format="linespecific" id="I_1_tt17">public boolean equals(Object o) {
    return EqualsBuilder.reflectionEquals(this, o);
}</programlisting>

      <warning id="lang-NOTE-47" role="ora">
        <para>Be careful when using reflection to automate <literal
        moreinfo="none">hashCode()</literal> and <literal
        moreinfo="none">equals( )</literal>, you may get more than you
        bargained for. In <link linkend="lang-ex-2">Example 1-2</link>, a
        candidate is uniquely identified by first and last name; if this bean
        were mapped to a table in a relational database, <literal
        moreinfo="none">firstName</literal> and <literal
        moreinfo="none">lastName</literal> would be a composite key
        identifying each unique row. A <literal
        moreinfo="none">HashMap</literal> or <literal
        moreinfo="none">HashSet</literal> is similar to a database table in
        that the identifier is defined by the fields used by <literal
        moreinfo="none">hashCode()</literal> and <literal
        moreinfo="none">equals( )</literal>; putting an equal object with the
        same hash code into a <literal moreinfo="none">HashMap</literal>
        replaces the previous entry. A poorly implemented <literal
        moreinfo="none">hashCode( )</literal> or <literal
        moreinfo="none">equals( )</literal> can have unintended consequences
        when storing objects in such a data structure. In other words,
        <literal moreinfo="none">equals( )</literal> and <literal
        moreinfo="none">hashCode()</literal> should be based off of the
        properties that uniquely identify a class. This being the case, the
        <literal moreinfo="none">equals()</literal> function should return
        true if two <literal moreinfo="none">PoliticalCandidate</literal>
        objects have<indexterm class="endofrange" id="lang-ITERM-1799"
        significance="normal" startref="lang-ITERM-1786"></indexterm>
        <indexterm class="endofrange" id="lang-ITERM-1800"
        significance="normal" startref="lang-ITERM-1791"></indexterm>
        <indexterm class="endofrange" id="lang-ITERM-1801"
        significance="normal" startref="lang-ITERM-1787"></indexterm>
        <indexterm class="endofrange" id="lang-ITERM-1802"
        significance="normal" startref="lang-ITERM-1788"></indexterm>
        <indexterm class="endofrange" id="lang-ITERM-1803"
        significance="normal" startref="lang-ITERM-1789"></indexterm>
        identical first <indexterm class="endofrange" id="lang-ITERM-1804"
        significance="normal" startref="lang-ITERM-1790"></indexterm>
        <indexterm class="endofrange" id="lang-ITERM-1805"
        significance="normal" startref="lang-ITERM-1792"></indexterm>
        <indexterm class="endofrange" id="lang-ITERM-1806"
        significance="normal" startref="lang-ITERM-1793"></indexterm>
        <indexterm class="endofrange" id="lang-ITERM-1807"
        significance="normal" startref="lang-ITERM-1794"></indexterm>and last
        names, and the hash code for two equal objects should be identical.
        The <literal moreinfo="none">hashCode( )</literal> and <literal
        moreinfo="none">equals()</literal> in <link
        linkend="lang-ex-2">Example 1-2</link> are written to only take into
        account the <literal moreinfo="none">firstName</literal> and <literal
        moreinfo="none">lastName</literal> properties.</para>
      </warning>
    </sect2>
  </sect1>

  <sect1 id="lang-sect-automate-compareTo" label="1.7" role="Recipe">
    <title>Automating compareTo( )</title>

    <sect2>
      <title>Problem</title>

      <para>You need a quick way to implement <literal
      moreinfo="none">compareTo( )</literal> <indexterm class="startofrange"
          id="lang-ITERM-1808" significance="normal">
          <primary>Commons Lang</primary>

          <secondary>compareTo( ) method</secondary>
        </indexterm> <indexterm class="startofrange" id="lang-ITERM-1809"
          significance="normal">
          <primary>automation</primary>
        </indexterm> <indexterm class="startofrange" id="lang-ITERM-1810"
          significance="normal">
          <primary>compareTo( ) method, automation</primary>
        </indexterm> <indexterm class="startofrange" id="lang-ITERM-1811"
          significance="normal">
          <primary>methods</primary>

          <secondary>compareTo( ) automation</secondary>
        </indexterm> <indexterm class="startofrange" id="lang-ITERM-1812"
          significance="normal">
          <primary>automation</primary>

          <secondary>compareTo( ) method</secondary>
        </indexterm>methods.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Commons Lang <literal moreinfo="none">CompareToBuilder</literal>
      provides a builder for <literal moreinfo="none">compareTo( )</literal>
      methods. <literal moreinfo="none">CompareToBuilder</literal> <indexterm
          id="lang-ITERM-1813" significance="normal">
          <primary>CompareToBuilder class</primary>
        </indexterm> <indexterm id="lang-ITERM-1814" significance="normal">
          <primary>classes</primary>

          <secondary>CompareToBuilder</secondary>
        </indexterm> can perform a comparison via reflection, or a comparison
      can be customized by passing parameters to an instance of <literal
      moreinfo="none">CompareToBuilder</literal>. The following example
      demonstrates the use of the reflection builder to implement a <literal
      moreinfo="none">compareTo( )</literal> method. This implementation
      compares all nonstatic and nontransient member variables in both
      classes.</para>

      <programlisting language="java" format="linespecific" id="I_1_tt18">import org.apache.commons.lang.builder.CompareToBuilder;

// Build a compareTo function from reflection 
public int compareTo(Object o) {
    return CompareToBuilder.reflectionCompare(this, obj);
}</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para><literal moreinfo="none">CompareToBuilder.reflectionCompare(
      )</literal> takes two objects and compares the non-static, nontransient
      member variables of these objects. In <link linkend="lang-ex-2">Example
      1-2</link>, the comparison involves the name properties of two <literal
      moreinfo="none">PoliticalCandidate</literal> objects from <link
      linkend="lang-ex-3">Example 1-3</link>, which are considered equal if
      both <literal moreinfo="none">firstName</literal> and <literal
      moreinfo="none">lastName</literal> are equal. <literal
      moreinfo="none">reflectionCompare( )</literal> ignores static fields and
      transients; therefore, in <link linkend="lang-ex-3">Example 1-3</link>,
      <literal moreinfo="none">averageAge</literal> and <literal
      moreinfo="none">fullName</literal> do not contribute to the automated
      comparison.</para>

      <example id="lang-ex-3" label="1-3">
        <title>Implementing compareTo( ) using a reflection builder</title>

        <indexterm id="lang-ITERM-1815" significance="normal">
          <primary>reflection builders</primary>

          <secondary>compareTo( ) method</secondary>
        </indexterm>

        <programlisting language="java" db:artifact="${project.groupId}:cjcook-examples:${project.version}:src:zip"
                        db:excerpt="lang-ex-3"
                        db:file="cjcook-examples-${project.version}/src/main/java/com/discursive/jccook/lang/builders/compare/PoliticalCandidate.java"
                        xmlns:db="http://discursive.com/plugins/docbook"></programlisting>
      </example>

      <para>In addition to a comparison by reflection, the <literal
      moreinfo="none">CompareToBuilder</literal> can be configured to compare
      two objects by a set of variables in a particular order. The order of
      comparisons plays a key role when a comparison involves multiple member
      variables; this order is not specified when using the <literal
      moreinfo="none">reflectionCompare()</literal> <indexterm
          id="lang-ITERM-1816" significance="normal">
          <primary>reflectionCompare( ) method</primary>
        </indexterm> <indexterm id="lang-ITERM-1817" significance="normal">
          <primary>methods</primary>

          <secondary>reflectionCompare( )</secondary>
        </indexterm> method. Assume that the default sorting behavior for
      <literal moreinfo="none">PoliticalCandidate</literal> objects should be
      <literal moreinfo="none">lastName</literal> and then <literal
      moreinfo="none">firstName</literal>; if two objects have the same
      <literal moreinfo="none">lastName</literal>, then sort by the <literal
      moreinfo="none">firstName</literal>. The following example demonstrates
      a customization of the <literal moreinfo="none">compareTo( )</literal>
      method.</para>

      <para>Calling <literal moreinfo="none">append( )</literal> specifies
      what variables will be compared and in what order they will be compared.
      The order of the calls to <literal moreinfo="none">append( )</literal>
      are backward—similar to pushing an object onto the top of a stack. The
      last property "pushed" onto the <literal
      moreinfo="none">CompareToBuilder</literal> is the first property to be
      compared. Objects are compared by last name, and first name is used as a
      "tiebreaker." <link linkend="lang-ex-4">Example 1-4</link> will compare
      two <literal moreinfo="none">PoliticalCandidate</literal> objects by
      <literal moreinfo="none">lastName</literal>, falling back to <literal
      moreinfo="none">firstName</literal> only if the <literal
      moreinfo="none">lastName</literal> values were equal.</para>

      <example id="lang-ex-4" label="1-4">
        <title>Customizing a compareTo( ) method with CompareToBuilder</title>

        <indexterm id="lang-ITERM-1818" significance="normal">
          <primary>customization</primary>

          <secondary>compareTo( ) method</secondary>
        </indexterm>

        <programlisting language="java" format="linespecific">// A compare to that mimics the behavior of equals( )
public int compareTo(Object o) {
    int compare = -1; // By default return less-than
    if( o != null &amp;&amp; 
        PoliticalCandidate.class.isAssignableFrom( o.getClass( ) ) ) {
            PoliticalCandidate pc = (PoliticalCandidate) o;
            compare = (new CompareToBuilder( )
                          .append(firstName, pc.firstName)
                          .append(lastName, pc.lastName)).toComparison( );
    }
    return compare;
}</programlisting>
      </example>

      <para>Remember to keep the behavior of <literal moreinfo="none">equals(
      )</literal> and <literal moreinfo="none">compareTo( )</literal>
      consistent to avoid problems when sorting collections. Automating the
      <literal moreinfo="none">compareTo( )</literal> method via reflection
      may not compare objects in a way that is consistent with <literal
      moreinfo="none">equals( )</literal>.</para>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para><literal moreinfo="none">compareTo( )</literal> methods provide
      the natural sorting order for a set of objects, and they are frequently
      used when sorting a collection of JavaBeans©. If you are trying to sort
      a collection of beans, you are better off using the <literal
      moreinfo="none">BeanComparator</literal>, which is described in <link
      linkend="beans-sect-comparing">Recipe 3.10</link>.</para>

      <para>Instead of capturing comparison logic in a <literal
      moreinfo="none">compareTo()</literal> method, consider using a <literal
      moreinfo="none">Comparator</literal> object. The Commons Collections
      project contains a number of supplements to the <literal
      moreinfo="none">Comparator</literal> interface, such <indexterm
      class="endofrange" id="lang-ITERM-1819" significance="normal"
      startref="lang-ITERM-1808"></indexterm> <indexterm class="endofrange"
      id="lang-ITERM-1820" significance="normal"
      startref="lang-ITERM-1809"></indexterm> <indexterm class="endofrange"
      id="lang-ITERM-1821" significance="normal"
      startref="lang-ITERM-1810"></indexterm> <indexterm class="endofrange"
      id="lang-ITERM-1822" significance="normal"
      startref="lang-ITERM-1811"></indexterm> <indexterm class="endofrange"
      id="lang-ITERM-1823" significance="normal"
      startref="lang-ITERM-1812"></indexterm>as utilities to reverse and chain
      comparators. <literal moreinfo="none">Comparator</literal> utilities are
      discussed in <link linkend="functors">Chapter 4</link>.</para>
    </sect2>
  </sect1>

  <sect1 id="lang-sect-printarray" label="1.8" role="Recipe">
    <title>Printing an Array</title>

    <sect2>
      <title>Problem</title>

      <para>You need to print the contents of an array.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use <literal moreinfo="none">ArrayUtils.toString()</literal>
      <indexterm id="lang-ITERM-1824" significance="normal">
          <primary>ArrayUtils.toString( ) method</primary>
        </indexterm> <indexterm id="lang-ITERM-1825" significance="normal">
          <primary>methods</primary>

          <secondary>ArrayUtils.toString( )</secondary>
        </indexterm> to print the contents<indexterm id="lang-ITERM-1826"
          significance="normal">
          <primary>printing</primary>

          <secondary>arrays</secondary>
        </indexterm> <indexterm id="lang-ITERM-1827" significance="normal">
          <primary>arrays</primary>

          <secondary>printing</secondary>
        </indexterm> of an array. This method takes any array as an argument
      and prints out the contents delimited by commas and surrounded by
      brackets:</para>

      <programlisting language="java" format="linespecific" id="I_1_tt19">int[] intArray = new int[] { 2, 3, 4, 5, 6 };

int[] multiDimension = new int[][] { { 1, 2, 3 }, { 2, 3 }, {5, 6, 7} };

System.out.println( "intArray: " + ArrayUtils.toString( intArray ) );
System.out.println( "multiDimension: " + ArrayUtils.
toString( multiDimension ) );</programlisting>

      <para>This example takes two arrays and prints them out using <literal
      moreinfo="none">ArrayUtils.toString( )</literal>:</para>

      <programlisting format="linespecific" id="I_1_tt20">intArray: {2,3,4,5,6}
multiDimension: {{1,2,3},{2,3},{5,6,7}}</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>This simple utility can be used to print the contents of an
      <literal moreinfo="none">Object[]</literal>, substituting an object for
      a <literal moreinfo="none">null</literal> element:</para>

      <programlisting language="java" format="linespecific" id="I_1_tt21">String[] strings = new String[] { "Blue", "Green", null, "Yellow" };

System.out.println( "Strings: " + ArrayUtils.toString( strings, "Unknown" );</programlisting>

      <para>This example prints the <literal moreinfo="none">strings</literal>
      array, and when <literal moreinfo="none">ArrayUtils</literal> encounters
      a <literal moreinfo="none">null</literal> element, it will print out
      "Unknown":</para>

      <programlisting format="linespecific" id="I_1_tt22">Strings: {Blue,Green,Unknown,Yellow}</programlisting>

      <para>This utility comes in handy when you need to print the contents of
      a <literal moreinfo="none">Collection</literal> for debugging purposes.
      If you need to print out the contents of a <literal
      moreinfo="none">Collection</literal>, convert it to an array, and pass
      that array to <literal
      moreinfo="none">ArrayUtils.toString()</literal>:</para>

      <programlisting language="java" format="linespecific" id="I_1_tt23">List list = new ArrayList( );
list.add( "Foo" );
list.add( "Blah" );

System.out.println( ArrayUtils.toString( list.toArray( ) ) );</programlisting>
    </sect2>
  </sect1>

  <sect1 id="lang-sect-clone-reverse-array" label="1.9" role="Recipe">
    <title>Cloning and Reversing Arrays</title>

    <sect2>
      <title>Problem</title>

      <para>You need to reverse and clone the <indexterm id="lang-ITERM-1828"
          significance="normal">
          <primary>cloning</primary>

          <secondary>arrays</secondary>
        </indexterm> <indexterm id="lang-ITERM-1829" significance="normal">
          <primary>arrays</primary>

          <secondary>cloning</secondary>
        </indexterm> <indexterm id="lang-ITERM-1830" significance="normal">
          <primary>reversing</primary>

          <secondary>arrays</secondary>
        </indexterm> <indexterm id="lang-ITERM-1831" significance="normal">
          <primary>arrays</primary>

          <secondary>reversing</secondary>
        </indexterm>contents of an array.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use <literal moreinfo="none">ArrayUtils.clone()</literal>
      <indexterm id="lang-ITERM-1832" significance="normal">
          <primary>ArrayUtils.clone( ) method</primary>
        </indexterm> <indexterm id="lang-ITERM-1833" significance="normal">
          <primary>methods</primary>

          <secondary>ArrayUtils.clone</secondary>
        </indexterm> and <literal
      moreinfo="none">ArrayUtils.reverse()</literal> <indexterm
          id="lang-ITERM-1834" significance="normal">
          <primary>ArrayUtils.reverse( ) method</primary>
        </indexterm> <indexterm id="lang-ITERM-1835" significance="normal">
          <primary>methods</primary>

          <secondary>ArrayUtils.reverse( )</secondary>
        </indexterm> methods from Commons Lang. <link
      linkend="lang-ex-5">Example 1-5</link> demonstrates the reversal and
      cloning of a primitive array full of <literal
      moreinfo="none">long</literal> primitives.</para>

      <example id="lang-ex-5" label="1-5">
        <title>Cloning and reversing a primitive array with ArrayUtils</title>

        <programlisting language="java" format="linespecific">import org.apache.commons.lang.ArrayUtils;

long[] array = { 1, 3, 2, 3, 5, 6 };
long[] reversed = ArrayUtils.clone( array );
ArrayUtils.reverse( reversed );

System.out.println( "Original: " + ArrayUtils.toString( array ) );
System.out.println( "Reversed: " + ArrayUtils.toString( reversed ) );</programlisting>
      </example>

      <para>The <literal moreinfo="none">array</literal> is cloned and
      reversed, and the contents of the original and the reversed array are
      displayed as output using <literal moreinfo="none">ArrayUtils.toString(
      )</literal>:</para>

      <programlisting format="linespecific" id="I_1_tt24">Original: { 1, 3, 2, 3, 5, 6 }
Reversed: { 6, 5, 3, 2, 3, 1 }</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>In <link linkend="lang-ex-5">Example 1-5</link>, <literal
      moreinfo="none">clone( )</literal> returns a reference to a new array,
      and <literal moreinfo="none">reverse( )</literal> operates on the array
      reference supplied as a parameter. It is important to realize that while
      <literal moreinfo="none">clone( )</literal> leaves the original array
      alone, <literal moreinfo="none">reverse( )</literal> operates directly
      on the supplied array. In addition to supporting all primitive arrays,
      <literal moreinfo="none">ArrayUtils.clone( )</literal> and <literal
      moreinfo="none">ArrayUtils.reverse( )</literal> work with object arrays.
      If <literal moreinfo="none">array</literal> had been an array of
      <literal moreinfo="none">Long</literal> objects, the code would bear a
      striking resemblance to the previous example.</para>

      <para>The only difference between Examples <link
      linkend="lang-ex-6">Example 1-6</link> and <link
      linkend="lang-ex-5">Example 1-5</link> is the type of array being cloned
      and reversed. Again, <literal moreinfo="none">ArrayUtils.toString(
      )</literal> is used to print out the contents of both the original and
      the reverse array:</para>

      <programlisting format="linespecific" id="I_1_tt25">Original: { 3, 56, 233 }
Reversed: { 233, 56, 3 }</programlisting>

      <example id="lang-ex-6" label="1-6">
        <title>Cloning and reversing an Object[ ] with ArrayUtils</title>

        <programlisting language="java" format="linespecific">Long[] array = new Long[] { new Long(3), new Long(56), new Long(233) };
Long[] reversed = ArrayUtils.clone( array );
ArrayUtils.reverse( reversed );

System.out.println( "Original: " + ArrayUtils.toString( array ) );
System.out.println( "Reversed: " + ArrayUtils.toString( reversed ) );</programlisting>
      </example>

      <para>Without the aid of <literal moreinfo="none">ArrayUtils.clone(
      )</literal> and <literal moreinfo="none">ArrayUtils.reverse(
      )</literal>, this task would have involved writing a loop to populate a
      reversed array. The following code completes the same task, but, in
      order to reverse an array, this example assigns the values from the
      original array in reverse; elements are inserted starting at <literal
      moreinfo="none">reversed[reversed.length</literal> <literal
      moreinfo="none">- 1]</literal> and ending at <literal
      moreinfo="none">reversed[0]</literal>:</para>

      <programlisting language="java" format="linespecific" id="I_1_tt26">// readTemps returns a 1000 member double[]
double[] temperature = readTemps( );

double[] reversed = new double[temperature.length];
for( int i = 0; i &lt; temperature.length; i++ ) {
    reversed[reversed.length - (i+1)] = temperature[i];
}</programlisting>

      <para>Another option is the use of the <literal
      moreinfo="none">Collections.reverse()</literal> <indexterm
          id="lang-ITERM-1836" significance="normal">
          <primary>Collections.reverse( ) method</primary>
        </indexterm> <indexterm id="lang-ITERM-1837" significance="normal">
          <primary>methods</primary>

          <secondary>Collections.reverse( )</secondary>
        </indexterm> method. J2SE contains a <literal
      moreinfo="none">Collections</literal> object with a static <literal
      moreinfo="none">reverse()</literal> method, but this only operates on a
      <literal moreinfo="none">List</literal> object. If you had an array of
      <literal moreinfo="none">double</literal> primitives, and you wanted to
      take advantage of the <literal moreinfo="none">Collections</literal>
      class, you would need to convert your double array to a list. Without
      Java 1.5's <indexterm id="lang-ITERM-1838" significance="normal">
          <primary>autoboxing</primary>
        </indexterm>autoboxing feature, a <literal
      moreinfo="none">double[]</literal> will need to be translated into a
      <literal moreinfo="none">Double[]</literal> before elements can be used
      to populate a list:</para>

      <programlisting language="java" format="linespecific" id="I_1_tt27">double[] temps = readTemps( );

List tempList = new ArrayList( );
for( int i = 0; i &lt; temps.length; i++ ) {
    tempList.add( new Double[temps[i]] );
}

Collections.reverse( tempList );

double[] reversed = new double( tempList.size( ) );
Iterator i = tempList.iterator( );
int index = 0;
while( i.hasNext( ) ) {
    reversed[index] = ((Double) i.next( )).doubleValue( );
    index++;
}</programlisting>

      <para>That nasty translation between a <literal
      moreinfo="none">double</literal> array and a list of <literal
      moreinfo="none">Double</literal> objects complicates your code. The next
      recipe will touch upon an easier method for performing this
      translation.</para>

      <para>Is <literal moreinfo="none">ArrayUtils.clone( )</literal> really
      necessary? All arrays have a <literal moreinfo="none">clone( )</literal>
      method, and all Java arrays implement <literal
      moreinfo="none">Cloneable</literal> and <literal
      moreinfo="none">Serializable</literal>, but I would be surprised if many
      Java developers have read the relevant section of the Java Language
      Specification (JLS), which discusses Array Members (section 10.7). All
      arrays can be cloned by calling the <literal moreinfo="none">clone(
      )</literal> method:</para>

      <programlisting language="java" format="linespecific" id="I_1_tt28">long[] temps = readTemps( );
long[] cloned = (long[]) temps.clone( );</programlisting>

      <para><literal moreinfo="none">ArrayUtils.clone( )</literal> doesn't
      provide you with any performance benefits, it doesn't necessarily
      improve your code, and one could debate the assertion that it makes for
      more readable code. But, mainly, it exists as a safe way to handle
      <literal moreinfo="none">null</literal> array references. If you attempt
      to clone a <literal moreinfo="none">null</literal> reference, this
      utility will return a <literal moreinfo="none">null</literal> instead of
      throwing a runtime exception.</para>
    </sect2>
  </sect1>

  <sect1 id="lang-sect-transform-array" label="1.10" role="Recipe">
    <title>Transforming Between Object Arrays and Primitive Arrays</title>

    <sect2>
      <title>Problem</title>

      <para>You need a way to convert an<indexterm id="lang-ITERM-1839"
          significance="normal">
          <primary>conversion</primary>

          <secondary>object arrays to primitive arrays</secondary>
        </indexterm> <indexterm id="lang-ITERM-1840" significance="normal">
          <primary>arrays</primary>

          <secondary>conversion</secondary>
        </indexterm> <indexterm id="lang-ITERM-1841" significance="normal">
          <primary>objects</primary>

          <secondary>conversion</secondary>
        </indexterm> <indexterm id="lang-ITERM-1842" significance="normal">
          <primary>primitive array conversion</primary>
        </indexterm> <indexterm id="lang-ITERM-1843" significance="normal">
          <primary>translation, arrays</primary>
        </indexterm> object array to a primitive array.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use <literal moreinfo="none">ArrayUtils.toObject()</literal>
      <indexterm id="lang-ITERM-1844" significance="normal">
          <primary>ArrayUtils.toObject( ) method</primary>
        </indexterm> <indexterm id="lang-ITERM-1845" significance="normal">
          <primary>methods</primary>

          <secondary>ArrayUtils.toObject( )</secondary>
        </indexterm> and <literal
      moreinfo="none">ArrayUtils.toPrimitive()</literal> <indexterm
          id="lang-ITERM-1846" significance="normal">
          <primary>ArrayUtils.toPrimitive( ) method</primary>
        </indexterm> <indexterm id="lang-ITERM-1847" significance="normal">
          <primary>methods</primary>

          <secondary>ArrayUtils.toPrimitive( )</secondary>
        </indexterm> to translate between primitive arrays and object arrays.
      The following example demonstrates the translation from a primitive
      array to an object array and vice versa:</para>

      <programlisting language="java" format="linespecific" id="I_1_tt29">import org.apache.commons.lang.ArrayUtils;

long[] primitiveArray = new long[] { 12, 100, 2929, 3323 };
Long[] objectArray = ArrayUtils.toObject( primitiveArray );

Double[] doubleObjects = new Double[] { new Double( 3.22, 5.222, 3.221 ) };
double[] doublePrimitives = ArrayUtils.toPrimitive( doubleObject );</programlisting>

      <para>The result from both translations is an array of equal length and
      equal contents. The first translation takes a <literal
      moreinfo="none">long[]</literal> and translates the array to a <literal
      moreinfo="none">Long[]</literal>, and the second translation takes a
      <literal moreinfo="none">Double[]</literal> and turns it into a <literal
      moreinfo="none">double[]</literal>.</para>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>Assume that the following example uses an external library that
      expects a list of <literal moreinfo="none">Double</literal> objects. The
      existing system uses an array of double primitives, and you need to
      "step up" from a primitive array to an object array in order to pass a
      parameter to the <literal moreinfo="none">complexCalculation()</literal>
      <indexterm id="lang-ITERM-1848" significance="normal">
          <primary>complexCalculation( ) method</primary>
        </indexterm> <indexterm id="lang-ITERM-1849" significance="normal">
          <primary>methods</primary>

          <secondary>complexCalculation( )</secondary>
        </indexterm> method:</para>

      <programlisting language="java" format="linespecific" id="I_1_tt30">// Assume that temps is a 4000 element double[]
double[] temps = readTemps( );

<emphasis role="bold">// Turn the double[] into an array of Double objects</emphasis>
               <emphasis role="bold">Double[] objectArray = ArrayUtils.toObject( temps );</emphasis>

List inputList = Arrays.asList( objectArray );

// Assume that some process returns results as a List of Double 
// objects
List outputList = externalLib.complexCalculation( inputList );

<emphasis role="bold">// Transform this List of doubles to an array of double primitives</emphasis>
               <emphasis role="bold">Double[] resultObjArray =</emphasis> 
               <emphasis role="bold">(Double[]) outputList.toArray( new Double[0] );</emphasis>

double[] result = 
    ArrayUtils.toPrimitive( resultObjArray, Double.NaN  );</programlisting>

      <para>The primitive array, <literal moreinfo="none">temps</literal>, is
      transformed to an object array using <literal
      moreinfo="none">ArrayUtils.toObject( )</literal>, and the results of our
      calculation are translated from a list to an array of primitives using
      <literal moreinfo="none">ArrayUtils.toPrimitive( )</literal>. While an
      object array can contain a <literal moreinfo="none">null</literal>
      element, a primitive array cannot; the second argument to <literal
      moreinfo="none">ArrayUtils.toPrimitive( )</literal> specifies a double
      value to be used if there is a <literal moreinfo="none">null</literal>
      in the object array. In this example, <literal
      moreinfo="none">null</literal> values in the object array are stored as
      <literal moreinfo="none">Double.NaN</literal> in our primitive array.
      The second argument to <literal moreinfo="none">ArrayUtils.toPrimitive(
      )</literal> is optional; if it is not present and a <literal
      moreinfo="none">null</literal> value is present in the object array, a
      <literal moreinfo="none">NullPointerException</literal> is
      thrown.</para>

      <para><literal moreinfo="none">ArrayUtils</literal> offers various
      static methods to transform between primitive and object arrays. Tables
      <link linkend="lang-TABLE-2">Table 1-2</link> and <link
      linkend="lang-TABLE-3">Table 1-3</link> summarize both the <literal
      moreinfo="none">toObject( )</literal> and <literal
      moreinfo="none">toPrimitive()</literal> methods.</para>

      <table id="lang-TABLE-2" label="1-2">
        <title>The various flavors of ArrayUtils.toObject( )</title>

        <tgroup cols="2">
          <colspec colname="col1" colnum="1" />

          <colspec colname="col2" colnum="2" />

          <thead>
            <row>
              <entry><para>Return type</para></entry>

              <entry><para>Method signature</para></entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><para> <literal moreinfo="none">Boolean[]</literal>
              </para></entry>

              <entry><para> <literal moreinfo="none">ArrayUtils.toObject(
              boolean[] array )</literal> </para></entry>
            </row>

            <row>
              <entry><para> <literal moreinfo="none">Byte[]</literal>
              </para></entry>

              <entry><para> <literal moreinfo="none">ArrayUtils.toObject(
              byte[] array )</literal> </para></entry>
            </row>

            <row>
              <entry><para> <literal moreinfo="none">Double[]</literal>
              </para></entry>

              <entry><para> <literal moreinfo="none">ArrayUtils.toObject(
              double[] array )</literal> </para></entry>
            </row>

            <row>
              <entry><para> <literal moreinfo="none">Float[]</literal>
              </para></entry>

              <entry><para> <literal moreinfo="none">ArrayUtils.toObject(
              float[] array )</literal> </para></entry>
            </row>

            <row>
              <entry><para> <literal moreinfo="none">Integer[]</literal>
              </para></entry>

              <entry><para> <literal moreinfo="none">ArrayUtils.toObject(
              int[] array )</literal> </para></entry>
            </row>

            <row>
              <entry><para> <literal moreinfo="none">Short[]</literal>
              </para></entry>

              <entry><para> <literal moreinfo="none">ArrayUtils.toObject(
              short[] array )</literal> </para></entry>
            </row>

            <row>
              <entry><para> <literal moreinfo="none">Long[]</literal>
              </para></entry>

              <entry><para> <literal moreinfo="none">ArrayUtils.toObject(
              long[] array )</literal> </para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <table id="lang-TABLE-3" label="1-3">
        <title>The various flavors of ArrayUtils.toPrimitive( )</title>

        <tgroup cols="2">
          <colspec colname="col1" colnum="1" />

          <colspec colname="col2" colnum="2" />

          <thead>
            <row>
              <entry><para>Return type</para></entry>

              <entry><para>Method signature</para></entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><para> <literal moreinfo="none">boolean[]</literal>
              </para></entry>

              <entry><para> <literal moreinfo="none">ArrayUtils.toPrimitive(
              Boolean[] array )</literal> </para></entry>
            </row>

            <row>
              <entry><para> <literal moreinfo="none">byte[]</literal>
              </para></entry>

              <entry><para> <literal moreinfo="none">ArrayUtils.toPrimitive(
              Byte[] array )</literal> </para></entry>
            </row>

            <row>
              <entry><para> <literal moreinfo="none">double[]</literal>
              </para></entry>

              <entry><para> <literal moreinfo="none">ArrayUtils.toPrimitive(
              Double[] array )</literal> </para></entry>
            </row>

            <row>
              <entry><para> <literal moreinfo="none">float[]</literal>
              </para></entry>

              <entry><para> <literal moreinfo="none">ArrayUtils.toPrimitive(
              Float[] array )</literal> </para></entry>
            </row>

            <row>
              <entry><para> <literal moreinfo="none">integer[]</literal>
              </para></entry>

              <entry><para> <literal moreinfo="none">ArrayUtils.toPrimitive(
              Integer[] array )</literal> </para></entry>
            </row>

            <row>
              <entry><para> <literal moreinfo="none">short[]</literal>
              </para></entry>

              <entry><para> <literal moreinfo="none">ArrayUtils.toPrimitive(
              Short[] array )</literal> </para></entry>
            </row>

            <row>
              <entry><para> <literal moreinfo="none">long[]</literal>
              </para></entry>

              <entry><para> <literal moreinfo="none">ArrayUtils.toPrimitive(
              Long[] array )</literal> </para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>Java 1.5 has added a feature called <indexterm
          id="lang-ITERM-1850" significance="normal">
          <primary>autoboxing</primary>
        </indexterm>autoboxing, which provides for automatic conversions
      between primitives and objects. For more information about autoboxing,
      see <ulink
      url="http://www.jcp.org/aboutJava/communityprocess/jsr/tiger/autoboxing.html">http://www.jcp.org/aboutJava/communityprocess/jsr/tiger/autoboxing.html</ulink>.</para>
    </sect2>
  </sect1>

  <sect1 id="lang-sect-finding-items" label="1.11" role="Recipe">
    <title>Finding Items in an Array</title>

    <sect2>
      <title>Problem</title>

      <para>You need to test an array to<indexterm id="lang-ITERM-1851"
          significance="normal">
          <primary>searching</primary>

          <secondary>arrays</secondary>
        </indexterm> <indexterm id="lang-ITERM-1852" significance="normal">
          <primary>arrays</primary>

          <secondary>searching</secondary>
        </indexterm> <indexterm id="lang-ITERM-1853" significance="normal">
          <primary>testing</primary>

          <secondary>arrays</secondary>
        </indexterm> <indexterm id="lang-ITERM-1854" significance="normal">
          <primary>arrays</primary>

          <secondary>testing</secondary>
        </indexterm> <indexterm id="lang-ITERM-1855" significance="normal">
          <primary>indexes</primary>

          <secondary>arrays</secondary>
        </indexterm> see if it contains an element. If the array contains the
      element, you need the index of the matching element.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use <literal moreinfo="none">ArrayUtils.contains()</literal>
      <indexterm id="lang-ITERM-1856" significance="normal">
          <primary>ArrayUtils.contains( ) method</primary>
        </indexterm> <indexterm id="lang-ITERM-1857" significance="normal">
          <primary>methods</primary>

          <secondary>ArrayUtils.contains( )</secondary>
        </indexterm> to see if an array contains a specified element, and use
      <literal moreinfo="none">ArrayUtils.indexOf( )</literal> or <literal
      moreinfo="none">ArrayUtils.lastIndexOf( )</literal> <indexterm
          id="lang-ITERM-1858" significance="normal">
          <primary>ArrayUtils.lastIndexOf( ) method</primary>
        </indexterm> <indexterm id="lang-ITERM-1859" significance="normal">
          <primary>methods</primary>

          <secondary>ArrayUtils.lastIndexOf( )</secondary>
        </indexterm> to find the position of a matching element. The following
      example demonstrates the use of these three methods:</para>

      <programlisting language="java" format="linespecific" id="I_1_tt31">import org.apache.commons.lang.ArrayUtils;

String[] stringArray = { "Red", "Orange", "Blue", "Brown", "Red" };

boolean containsBlue = ArrayUtils.contains( stringArray, "Blue" );
int indexOfRed = ArrayUtils.indexOf( stringArray, "Red");
int lastIndexOfRed = ArrayUtils.lastIndexOf( string, "Red" );

System.out.println( "Array contains 'Blue'? " + containsBlue );
System.out.println( "Index of 'Red'? " + indexOfRed );
System.out.println( "Last Index of 'Red'? " + lastIndexOfRed );</programlisting>

      <para>This example locates strings in a string array and produces the
      following output:</para>

      <programlisting format="linespecific" id="I_1_tt32">Array contains 'Blue'? true
Index of 'Red'? 0
Last Index of 'Red'? 4</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>All three methods work with an object array or any primitive
      array; in fact, almost every method defined in <literal
      moreinfo="none">ArrayUtils</literal> can be applied to every possible
      array type—<literal moreinfo="none">boolean[]</literal>, <literal
      moreinfo="none">byte[]</literal>, <literal
      moreinfo="none">char[]</literal>, <literal
      moreinfo="none">double[]</literal>, <literal
      moreinfo="none">float[]</literal>, <literal
      moreinfo="none">long[]</literal>, <literal
      moreinfo="none">short[]</literal>, and <literal
      moreinfo="none">Object[]</literal>. When using a primitive array,
      <literal moreinfo="none">ArrayUtils</literal> compares the value in
      question to each element of an array until a match is found. When using
      an object array, <literal moreinfo="none">ArrayUtils</literal> calls the
      <literal moreinfo="none">equals( )</literal> method to check for a
      matching array element.</para>

      <para><literal moreinfo="none">ArrayUtils.indexOf( )</literal> and
      <literal moreinfo="none">ArrayUtils.lastIndexOf( )</literal> take an
      optional third parameter that controls where an element search begins.
      In the next example, you are searching an array of double primitives for
      the value -9999. <link linkend="lang-ex-7">Example 1-7</link>
      demonstrates how to establish that the value is contained within an
      array and how to locate the index for each matching element.</para>

      <example id="lang-ex-7" label="1-7">
        <title>Searching an array using ArrayUtils.contains( ) and
        ArrayUtils.indexOf( )</title>

        <programlisting language="java" format="linespecific">// temps is a 1000 element long[]
long[] temps = readTemps( );

// Check to see if the array contains -9999
boolean hasErrorFlag = ArrayUtils.contains( temperature, -9999 );
    
// Print out the index of every errored reading
int start = 0;
while( hasErrorFlag &amp;&amp; 
         (ArrayUtils.indexOf(temperature, -9999, start) != -1) ) {
    int errorIdx = ArrayUtils.indexOf(temperature, -9999, start);
    System.out.println( "Error reading at index: " + errorIdx );
    start = errorIdx + 1;
}</programlisting>
      </example>

      <para>You could easily implement this method yourself; <literal
      moreinfo="none">ArrayUtils.contains( )</literal> and <literal
      moreinfo="none">ArrayUtils.indexOf( )</literal> are simply methods that
      iterate through every element of an array and test for equality. The
      simple savings you gain from <literal
      moreinfo="none">ArrayUtils</literal> is one less <literal
      moreinfo="none">for</literal> loop you have to test and maintain:</para>

      <programlisting language="java" format="linespecific" id="I_1_tt33">long testValue = -9999;
boolean hasErrors = false;

for( int i = 0; i &lt; temps.length; i++ ) {
    if( temps[i] == testValue ) {
        hasErrors = true;
    }
}</programlisting>

      <para>The benefits are small, but maintaining your own custom utility
      classes is a pain—it is just another thing to test and maintain.
      <literal moreinfo="none">ArrayUtils</literal> isn't going to change your
      application's architecture, but it will ultimately reduce the amount of
      trivial code you have to write, and you will not have to expend energy
      maintaining or testing trivial code.</para>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para><link linkend="functors">Chapter 4</link> contains a number of
      recipes dealing with <literal moreinfo="none">Predicate</literal>
      objects and filtering collections. Instead of using the three methods
      defined in this recipe, you can put objects into a collection and count
      or select the elements that match an <literal
      moreinfo="none">EqualPredicate</literal>. See <link
      linkend="functors">Chapter 4</link> for more information about querying
      collections with predicates.</para>
    </sect2>
  </sect1>

  <sect1 id="lang-sect-createmap" label="1.12" role="Recipe">
    <title>Creating a Map from a Multidimensional Array</title>

    <sect2>
      <title>Problem</title>

      <para>You need to create a <literal moreinfo="none">Map</literal> from
      a<indexterm id="lang-ITERM-1860" significance="normal">
          <primary>mapping</primary>

          <secondary>multidimensional arrays</secondary>
        </indexterm> <indexterm id="lang-ITERM-1861" significance="normal">
          <primary>multidimensional arrays, mapping</primary>
        </indexterm> <indexterm id="lang-ITERM-1862" significance="normal">
          <primary>arrays</primary>

          <secondary>mapping multidimensional</secondary>
        </indexterm> multidimensional array.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use <literal moreinfo="none">ArrayUtils.toMap()</literal>
      <indexterm id="lang-ITERM-1863" significance="normal">
          <primary>ArrayUtils.toMap( ) method</primary>
        </indexterm> <indexterm id="lang-ITERM-1864" significance="normal">
          <primary>methods</primary>

          <secondary>ArrayUtils.toMap( )</secondary>
        </indexterm> to create a <literal moreinfo="none">Map</literal> from a
      two-dimensional array (<literal moreinfo="none">Object[][]</literal>).
      <link linkend="lang-ex-8">Example 1-8</link> demonstrates the creation
      of such a <literal moreinfo="none">Map</literal>. <link
      linkend="lang-ex-8">Example 1-8</link> takes an <literal
      moreinfo="none">Object[][]</literal> representing atomic symbols and
      atomic weights and turns it into a <literal
      moreinfo="none">Map</literal> retrieving the atomic weight for
      hydrogen.</para>

      <example id="lang-ex-8" label="1-8">
        <title>Creating a Map from an Object[ ][ ]</title>

        <programlisting language="java" format="linespecific">import org.apache.commons.lang.ArrayUtils;

Object[] weightArray = 
    new Object[][] { {"H" , new Double( 1.007)},
                     {"He", new Double( 4.002)},
                     {"Li", new Double( 6.941)},
                     {"Be", new Double( 9.012)},
                     {"B",  new Double(10.811)},
                     {"C",  new Double(12.010)},
                     {"N",  new Double(14.007)},
                     {"O",  new Double(15.999)},
                     {"F",  new Double(18.998)},
                     {"Ne", new Double(20.180)} };

// Create a Map mapping colors.
Map weights = ArrayUtils.toMap( weightArray );

Double hydrogenWeight = map.get( "H" );</programlisting>
      </example>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>Instead of calling <literal moreinfo="none">weights.put(
      )</literal> for each entry in the <literal
      moreinfo="none">Map</literal>, an <literal
      moreinfo="none">Object[][]</literal> is created and then passed to
      <literal moreinfo="none">ArrayUtils.toMap()</literal> <indexterm
          id="lang-ITERM-1865" significance="normal">
          <primary>ArrayUtils.toMap( ) method</primary>
        </indexterm> <indexterm id="lang-ITERM-1866" significance="normal">
          <primary>methods</primary>

          <secondary>ArraysUtils.toMap( )</secondary>
        </indexterm>. The <literal moreinfo="none">toMap()</literal>
      <indexterm id="lang-ITERM-1867" significance="normal">
          <primary>toMap( ) method</primary>
        </indexterm> <indexterm id="lang-ITERM-1868" significance="normal">
          <primary>methods</primary>

          <secondary>toMap( )</secondary>
        </indexterm> method then extracts the first item in each array as the
      key and the second item as the value. This is a simple way to quickly
      create a <literal moreinfo="none">Map</literal> in a piece of code; the
      alternative to using <literal moreinfo="none">ArrayUtils.toMap(
      )</literal> is to simply create a <literal moreinfo="none">Map</literal>
      and repeatedly call the <literal moreinfo="none">put( )</literal>
      method.</para>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>In the previous example, <literal moreinfo="none">Double</literal>
      objects are added to a <literal moreinfo="none">Map</literal>, and
      values are retrieved from the <literal moreinfo="none">Map</literal>
      using <literal moreinfo="none">get( )</literal>. Commons Collections
      contains utility methods for retrieving <literal
      moreinfo="none">Double</literal> objects as <literal
      moreinfo="none">double</literal> primitives; <literal
      moreinfo="none">MapUtils.getDouble( )</literal> retrieves an object from
      a <literal moreinfo="none">Map</literal>, casts it to a <literal
      moreinfo="none">Number</literal>, and calls <literal
      moreinfo="none">doubleValue( )</literal> using the default value
      supplied if there is no corresponding key in the <literal
      moreinfo="none">Map</literal>. See <link
      linkend="collections-sect-retrieving-casting">Recipe 5.21</link> for
      more information about <literal moreinfo="none">MapUtils.getDouble(
      )</literal>.</para>
    </sect2>
  </sect1>

  <sect1 id="lang-sect-format-dates" label="1.13" role="Recipe">
    <title>Formatting Dates</title>

    <sect2>
      <title>Problem</title>

      <para>You need to format a<indexterm id="lang-ITERM-1869"
          significance="normal">
          <primary>formatting</primary>

          <secondary>dates</secondary>
        </indexterm> <indexterm id="lang-ITERM-1870" significance="normal">
          <primary>dates</primary>

          <secondary>formatting</secondary>
        </indexterm> date, and <literal
      moreinfo="none">SimpleDateFormat</literal> is not thread-safe. You are
      also looking for standard International Organization of Standards (ISO)
      date formats.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use <literal moreinfo="none">FastDateFormat</literal>, a
      thread-safe formatter for Java <literal moreinfo="none">Date</literal>
      objects, and use public static instances of <literal
      moreinfo="none">FastDateFormat</literal> on <literal
      moreinfo="none">DateFormatUtils</literal>, which correspond to ISO date
      and time formatting standards defined in ISO 8601. The following example
      outputs the international standard for representing a date and time in a
      given time zone:</para>

      <programlisting language="java" format="linespecific" id="I_1_tt34">Date now = new Date( );
String isoDT = DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.format( now );
    
System.out.println( "It is currently: " + isoDT );</programlisting>

      <para>This produces the following output displaying the current time
      with time-zone information:</para>

      <programlisting format="linespecific" id="I_1_tt35">It is currently: 2004-03-26T16:20:00-07:00</programlisting>

      <para>If you need to use a custom date format, use <literal
      moreinfo="none">FastDateFormat</literal> as a substitute for <literal
      moreinfo="none">SimpleDateFormat</literal>:</para>

      <programlisting language="java" format="linespecific" id="I_1_tt36">// create a formatter that simply prints the year and month
FastDateFormat formatter = 
    new FastDateFormat( "yyyy-mm",
                         TimeZone.getDefault( ),
                         Locale.getDefault( ) );

String output = formatter.format( new Date( ) );
// output equals "2003-10"</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>The problem for this recipe is two-fold; your <emphasis
      role="bold">multithreaded</emphasis> application needs to print out
      <emphasis role="bold">standard</emphasis> date/time formats. Printing a
      standard format is a problem easily solved by static instances of
      <literal moreinfo="none">FastDateFormat</literal> on <literal
      moreinfo="none">DateFormatUtils</literal>. Ideally, every program that
      needs to deal with dates knows how to recognize an ISO 8601 date when
      parsing input. The world is getting smaller by the day; use
      international standards when presenting dates, times, measures, and
      country codes.</para>

      <para><literal moreinfo="none">SimpleDateFormat</literal> is incapable
      of producing an ISO-8601-compliant time zone that matches the pattern:
      <literal moreinfo="none">+11:30</literal>. Sun's <literal
      moreinfo="none">SimpleDateFormat</literal> class can generate time zones
      without the colon separator, but these are incompatible with systems
      that need to be able to parse a standard format. <literal
      moreinfo="none">FastDateFormat</literal> has achieved compliance with
      the ISO 8601 standard by adding a "ZZ" date format symbol, which is
      translated into the appropriate time-zone representation. In addition to
      the format demonstrated in the previous example, the <literal
      moreinfo="none">DateFormatUtils</literal> class maintains a number of
      variations on the full ISO 8601 date format; there is a format to show
      only the time, a format to show only the date, and others, as well as
      the standard format for displaying dates in Simple Mail Transfer
      Protocol (SMTP). (See <link linkend="lang-TABLE-4">Table
      1-4</link>.)</para>

      <table id="lang-TABLE-4" label="1-4">
        <title>Static date/time formats in DateFormatUtils</title>

        <tgroup cols="2">
          <colspec colname="col1" colnum="1" />

          <colspec colname="col2" colnum="2" />

          <thead>
            <row>
              <entry><para>Name</para></entry>

              <entry><para>Format</para></entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><para> <literal moreinfo="none">ISO_DATE_FORMAT</literal>
              </para></entry>

              <entry><para> <literal
              moreinfo="none">yyyy-MM-dd"2004-01-02</literal>"</para></entry>
            </row>

            <row>
              <entry><para> <literal
              moreinfo="none">ISO_DATE_TIME_ZONE_FORMAT</literal>
              </para></entry>

              <entry><para> <literal
              moreinfo="none">yyyy-MM-ddZZ"2004-01-02-07:00</literal>"</para></entry>
            </row>

            <row>
              <entry><para> <literal
              moreinfo="none">ISO_DATETIME_FORMAT</literal> </para></entry>

              <entry><para> <literal
              moreinfo="none">yyyy-MM-dd'T'HH:mm:ss"2004-01-02T23:22:12</literal>"</para></entry>
            </row>

            <row>
              <entry><para> <literal
              moreinfo="none">ISO_DATETIME_TIME_ZONE_FORMAT</literal>
              </para></entry>

              <entry><para> <literal
              moreinfo="none">yyyy-MM-dd'T'HH:mm:ssZZ"2004-01-02T21:13:45-07:00</literal>"</para></entry>
            </row>

            <row>
              <entry><para> <literal moreinfo="none">ISO_TIME_FORMAT</literal>
              </para></entry>

              <entry><para>'<literal
              moreinfo="none">T'HH:mm:ss"T04:23:22</literal>"</para></entry>
            </row>

            <row>
              <entry><para> <literal
              moreinfo="none">ISO_TIME_NO_T_FORMAT</literal> </para></entry>

              <entry><para> <literal
              moreinfo="none">HH:mm:ss"05:12:34</literal>"</para></entry>
            </row>

            <row>
              <entry><para> <literal
              moreinfo="none">ISO_TIME_NO_T_TIME_ZONE_FORMAT</literal>
              </para></entry>

              <entry><para> <literal
              moreinfo="none">HH:mm:ssZZ"12:32:22-07:00</literal>"</para></entry>
            </row>

            <row>
              <entry><para> <literal
              moreinfo="none">ISO_TIME_TIME_ZONE_FORMAT</literal>
              </para></entry>

              <entry><para>'<literal
              moreinfo="none">T'HH:mm:ssZZ"T18:23:22-07:00</literal>"</para></entry>
            </row>

            <row>
              <entry><para> <literal
              moreinfo="none">SMTP_DATETIME_FORMAT</literal> </para></entry>

              <entry><para> <literal moreinfo="none">EEE, dd MMM yyyy HH:mm:ss
              Z"Wed, 01 Feb 2004 20:03:01 CST</literal>"</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Why would you want to use <literal
      moreinfo="none">FastDateFormat</literal> in the same way <literal
      moreinfo="none">SimpleDateFormat</literal> is used? Isn't <literal
      moreinfo="none">SimpleDateFormat</literal> enough? The simple answer is
      no; <literal moreinfo="none">SimpleDateFormat</literal> is
      <emphasis>not</emphasis> thread-safe and <literal
      moreinfo="none">FastDateFormat</literal> is. In fact, you should be
      aware that none of the Sun formatting classes are thread-safe. If
      multiple threads are using any Java formatting object there is a
      possibility of deadlock, <literal
      moreinfo="none">RuntimeException</literal>, or inconsistent behavior. If
      your systems use a shared instance <literal
      moreinfo="none">SimpleDateFormat</literal> across multiple threads, you
      should migrate to <literal moreinfo="none">FastDateFormat</literal>
      immediately.</para>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>Java date and time classes have a number of issues—concurrency
      issues with date formatting being "only the tip of the iceberg." An
      active member of the Commons community, Stephen Colebourne, has taken
      time to create a clean room reimplementation of a date and time API. For
      more information about Joda, take a look at the Joda project page
      (<ulink
      url="http://www.joda.org/)">http://www.joda.org/)</ulink>.</para>

      <para>For more information about the ISO date and time standards, see
      <ulink
      url="http://www.cl.cam.ac.uk/~mgk25/iso-time.html">http://www.cl.cam.ac.uk/~mgk25/iso-time.html</ulink>.</para>

      <para>For more information about nonthread-safe implementations of
      <literal moreinfo="none">SimpleDateFormat</literal> <indexterm
          id="lang-ITERM-1871" significance="normal">
          <primary>SimpleDateFormat class</primary>
        </indexterm> <indexterm id="lang-ITERM-1872" significance="normal">
          <primary>classes</primary>

          <secondary>SimpleDateFormat</secondary>
        </indexterm>, see Sun's Bug Database, and look for Bug #4264153. Sun
      specifically states that all of the format classes <literal
      moreinfo="none">Format</literal>, <literal
      moreinfo="none">MessageFormat</literal>, <literal
      moreinfo="none">NumberFormat</literal>, <literal
      moreinfo="none">DecimalFormat</literal>, <literal
      moreinfo="none">ChoiceFormat</literal>, <literal
      moreinfo="none">DateFormat</literal>, and <literal
      moreinfo="none">SimpleDateFormat</literal> are not thread-safe. It is
      unclear if Sun has addressed this issue in Java 1.4, but if you are
      writing critical multithreaded applications, you should avoid Sun's
      formatting classes or synchronize access to them.</para>
    </sect2>
  </sect1>

  <sect1 id="lang-sect-rounding-date" label="1.14" role="Recipe">
    <title>Rounding Date Objects</title>

    <sect2>
      <title>Problem</title>

      <para>You need to round a date to the<indexterm id="lang-ITERM-1873"
          significance="normal">
          <primary>dates</primary>

          <secondary>rounding</secondary>
        </indexterm> <indexterm id="lang-ITERM-1874" significance="normal">
          <primary>rounding dates</primary>
        </indexterm> <indexterm id="lang-ITERM-1875" significance="normal">
          <primary>seconds, rounding</primary>
        </indexterm> <indexterm id="lang-ITERM-1876" significance="normal">
          <primary>minutes</primary>

          <secondary>rounding</secondary>
        </indexterm> <indexterm id="lang-ITERM-1877" significance="normal">
          <primary>hours</primary>

          <secondary>rounding</secondary>
        </indexterm> <indexterm id="lang-ITERM-1878" significance="normal">
          <primary>days</primary>

          <secondary>rounding</secondary>
        </indexterm> <indexterm id="lang-ITERM-1879" significance="normal">
          <primary>months</primary>

          <secondary>rounding</secondary>
        </indexterm> <indexterm id="lang-ITERM-1880" significance="normal">
          <primary>years, rounding</primary>
        </indexterm> nearest second, minute, hour, day, month, or year.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use <literal moreinfo="none">DateUtils</literal> to round <literal
      moreinfo="none">Date</literal> objects to the nearest <literal
      moreinfo="none">Calendar</literal> field. <literal
      moreinfo="none">DateUtils.round()</literal> <indexterm
          id="lang-ITERM-1881" significance="normal">
          <primary>DateUtils.round( ) method</primary>
        </indexterm> <indexterm id="lang-ITERM-1882" significance="normal">
          <primary>methods</primary>

          <secondary>DateUtils.round( )</secondary>
        </indexterm> can round to almost every <literal
      moreinfo="none">Calendar</literal> field, including <literal
      moreinfo="none">Calendar.SECOND</literal>, <literal
      moreinfo="none">Calendar.MINUTE</literal>, <literal
      moreinfo="none">Calendar.HOUR</literal>, <literal
      moreinfo="none">Calendar.DAY_OF_MONTH</literal>, <literal
      moreinfo="none">Calendar.MONTH</literal>, and <literal
      moreinfo="none">Calendar.YEAR</literal>. The following example
      demonstrates the use of <literal moreinfo="none">DateUtils.round(
      )</literal>:</para>

      <programlisting language="java" format="linespecific" id="I_1_tt37">import org.apache.commons.lang.time.FastDateFormat;
import org.apache.commons.lang.time.DateFormatUtils;
import org.apache.commons.lang.time.DateUtils;

FastDateFormat dtFormat = DateFormatUtils.ISO_DATETIME_FORMAT;

Date now = new Date( );
Date nearestHour = DateUtils.round( now, Calendar.HOUR );
Date nearestDay = DateUtils.round( now, Calendar.DAY_OF_MONTH );
Date nearestYear = DateUtils.round( now, Calendar.YEAR );

System.out.println( "Now: " + dtFormat.format( now ) );
System.out.println( "Nearest Hour: " + dtFormat.format( nearestHour ) );
System.out.println( "Nearest Day: " + dtFormat.format( nearestDay ) );
System.out.println( "Nearest Year: " + dtFormat.format( nearestYear ) );</programlisting>

      <para>This example creates an object representing the current time and
      rounds this date to the nearest hour, day, and year. Assuming that the
      current date is March 28, 2004, and the current time is 1:48 P.M., this
      program creates the following output using the <literal
      moreinfo="none">FastDateFormat</literal> class from the previous
      recipe:</para>

      <programlisting format="linespecific" id="I_1_tt38">Now: 2004-03-28T13:48:12
Nearest Hour: 2004-03-28T14:00:00
Nearest Day: 2004-03-29T00:00:00
Nearest Year: 2004-01-01T00:00:00</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>If you are creating a system to record the time of an event, and
      you are not certain exactly when that event happened, it is appropriate
      to round that date and time to an approximate value. Are you certain
      that you woke up at 9:02 A.M., 23 seconds, and 879 milliseconds? Or, is
      it more likely that you remember that you woke up around 9 A.M.? It
      would be appropriate to round this time to the <literal
      moreinfo="none">Calendar.MINUTE</literal> or <literal
      moreinfo="none">Calendar.HOUR</literal> field at the very
      least—recording a general time, such as "around 9 A.M." In the following
      example, <literal moreinfo="none">DateUtils.round( )</literal>
      calculates an approximate time:</para>

      <programlisting language="java" format="linespecific" id="I_1_tt39">// Rounding to the nearest hour
Date wokeUp = new Date( );
Date wokeUpAround = DateUtils.round( now, Calendar.HOUR );</programlisting>

      <para>If your <literal moreinfo="none">wokeUp</literal> <literal
      moreinfo="none">Date</literal> object is 1:31 P.M., then <literal
      moreinfo="none">wokeUpAround</literal> will be equal to 2:00 P.M. But,
      if you woke up at 1:15 P.M., your <literal
      moreinfo="none">wokeUpAround</literal> object would then be rounded down
      to 1:00 P.M. When you round or truncate to a field, all of the date
      fields less significant than the specified field are set to zero. In
      this example, rounding to an hour causes the minutes, seconds, and
      milliseconds to be set to zero. Rounding a <literal
      moreinfo="none">Date</literal> to a <literal
      moreinfo="none">Calendar.YEAR</literal> sets the day of the year to one
      and the time to the first instance of the nearest year:</para>

      <programlisting language="java" format="linespecific" id="I_1_tt40">Date now = new Date( )
Date nearestYear = DateUtils.round( now, Calendar.YEAR );</programlisting>

      <para>This previous code rounds to the nearest year, and if <literal
      moreinfo="none">now</literal> is 15 May 2004, the resulting <literal
      moreinfo="none">Date</literal> will correspond to the first instance of
      2004. Alternatively, if <literal moreinfo="none">now</literal> is 15
      July 2004, the resulting <literal moreinfo="none">Date</literal> will be
      the first instance of 2005.</para>

      <para><literal moreinfo="none">DateUtils.round( )</literal> works with
      the following field values, listed in order of significance:</para>

      <itemizedlist>
        <listitem>
          <para><literal moreinfo="none">Calendar.MILLISECOND</literal></para>
        </listitem>

        <listitem>
          <para><literal moreinfo="none">Calendar.SECOND</literal></para>
        </listitem>

        <listitem>
          <para><literal moreinfo="none">Calendar.MINUTE</literal></para>
        </listitem>

        <listitem>
          <para><literal moreinfo="none">Calendar.HOUR_OF_DAY</literal> and
          <literal moreinfo="none">Calendar.HOUR</literal></para>
        </listitem>

        <listitem>
          <para><literal moreinfo="none">Calendar.DATE</literal>, <literal
          moreinfo="none">Calendar.DAY_OF_MONTH</literal>, and <literal
          moreinfo="none">Calendar.AM_PM</literal></para>
        </listitem>

        <listitem>
          <para><literal moreinfo="none">Calendar.MONTH</literal></para>
        </listitem>

        <listitem>
          <para><literal moreinfo="none">DateUtils.SEMI_MONTH</literal></para>
        </listitem>

        <listitem>
          <para><literal moreinfo="none">Calendar.YEAR</literal></para>
        </listitem>

        <listitem>
          <para><literal moreinfo="none">Calendar.ERA</literal></para>
        </listitem>
      </itemizedlist>

      <para><literal moreinfo="none">DateUtils</literal> introduces a <literal
      moreinfo="none">DateUtils.SEMI_MONTH</literal> field, which will cause
      dates to be rounded to the middle or beginning of a month. In <literal
      moreinfo="none">DateUtils</literal>, the middle of the month is defined
      as the 15th day of the month with the second half of the month starting
      at midnight on the 16th day of the month:</para>

      <programlisting language="java" format="linespecific" id="I_1_tt41">Calendar cal = Calendar.getInstance( );
cal.set( 2004, Calendar.MARCH, 5, 10, 2, 2 );

System.out.println( DateUtils.round( cal.getTime( ) , 
DateUtils.SEMI_MONTH ) );</programlisting>

      <para>This code will print out <filename moreinfo="none">Mon Mar 01
      00:00:00 CST 2004</filename> as the 5th of March and is closer to the
      beginning of the month than it is to the middle of the month. If the
      <literal moreinfo="none">Calendar</literal> object was March, 14th,
      2004, and it had been rounded to a <literal
      moreinfo="none">DateUtils.SEMI_MONTH</literal>, the rounded date would
      have been set to midnight on March 16th. One would think that the middle
      of March is the 15th? Isn't that date the famous Ides of March—the date
      on which Brutus betrayed Caesar? According to <literal
      moreinfo="none">DateUtils</literal>, the first half of the month ends at
      11:59 P.M. on the 15th of the month; the <literal
      moreinfo="none">DateUtils.round( )</literal> method returns the first
      instant of the beginning of the second half of March: <filename
      moreinfo="none">March 16 12:00:00.000 A.M</filename>.</para>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>The more you work with Java's <literal
      moreinfo="none">Date</literal> and <literal
      moreinfo="none">Calendar</literal> object, the more you will curse the
      J2SE. If your frustration is boiling over, take a look at<indexterm
          id="lang-ITERM-1883" significance="normal">
          <primary>Joda</primary>
        </indexterm> Joda. Joda contains an entire package devoted to date,
      time, and duration formatting, and it is not based on the <literal
      moreinfo="none">Date</literal> or <literal
      moreinfo="none">Calendar</literal> classes. For more information about
      Joda, take a look at the Joda project page at: <ulink
      url="http://www.joda.org/">http://www.joda.org/</ulink>.</para>
    </sect2>
  </sect1>

  <sect1 id="lang-sect-truncate-date" label="1.15" role="Recipe">
    <title>Truncating Date Objects</title>

    <sect2>
      <title>Problem</title>

      <para>You need to truncate a<indexterm id="lang-ITERM-1884"
          significance="normal">
          <primary>truncating dates</primary>
        </indexterm> <indexterm id="lang-ITERM-1885" significance="normal">
          <primary>dates</primary>

          <secondary>truncating</secondary>
        </indexterm> date to a calendar field.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use <literal moreinfo="none">DateUtils.truncate()</literal>
      <indexterm id="lang-ITERM-1886" significance="normal">
          <primary>DateUtils.truncate( ) method</primary>
        </indexterm> <indexterm id="lang-ITERM-1887" significance="normal">
          <primary>methods</primary>

          <secondary>DateUtils.truncate( )</secondary>
        </indexterm> to throw out<indexterm id="lang-ITERM-1888"
          significance="normal">
          <primary>fields, truncating date objects</primary>
        </indexterm> all fields less significant than the specified field.
      When a <literal moreinfo="none">Date</literal> is truncated to the
      <literal moreinfo="none">Calendar.MONTH</literal> field, <literal
      moreinfo="none">DateUtils.truncate( )</literal> will return a <literal
      moreinfo="none">Date</literal> object set to the first instance of the
      month. The <indexterm id="lang-ITERM-1889" significance="normal">
          <primary>days</primary>

          <secondary>truncating</secondary>
        </indexterm> <indexterm id="lang-ITERM-1890" significance="normal">
          <primary>hours</primary>

          <secondary>truncating</secondary>
        </indexterm> <indexterm id="lang-ITERM-1891" significance="normal">
          <primary>minutes</primary>

          <secondary>truncating</secondary>
        </indexterm> <indexterm id="lang-ITERM-1892" significance="normal">
          <primary>seconds, truncating</primary>
        </indexterm> <indexterm id="lang-ITERM-1893" significance="normal">
          <primary>months</primary>

          <secondary>truncating</secondary>
        </indexterm> <indexterm id="lang-ITERM-1894" significance="normal">
          <primary>milliseconds, truncating</primary>
        </indexterm>day, hour, minute, second, and millisecond field will each
      contain the minimum possible value for that field. <link
      linkend="lang-ex-9">Example 1-9</link> truncates a date at the month
      field and the hour field.</para>

      <example id="lang-ex-9" label="1-9">
        <title>Truncating a Date object at Calendar.MONTH</title>

        <programlisting language="java" format="linespecific">import org.apache.commons.lang.time.DateUtils;
import org.apache.commons.lang.time.FastDateFormat;
import org.apache.commons.lang.time.DateFormatUtils;

FastDateFormat dtFormat = DateFormatUtils.ISO_DATETIME_FORMAT;

Date now = new Date( );
Date truncatedMonth = DateUtils.truncate( now, Calendar.MONTH );
Date truncatedHour = DateUtils.truncate( now, Calendar.HOUR ); 

System.out.println( "Now: " + dtFormat.format( now ) );
System.out.println( "Truncated Month: " 
                 + dtFormat.format( truncatedMonth ) );
System.out.println( "Truncated Hour: " 
                    + dtFormat.format( truncatedHour ) );</programlisting>
      </example>

      <para>Assuming that the current date is March 28, 2004, and the current
      time is 1:48 P.M., this example produces the following output:</para>

      <programlisting format="linespecific" id="I_1_tt42">Now: 2004-03-28T13:48:12
Truncated Month: 2004-03-01T00:00:00
Truncated Hour: 2004-03-28T13:00:00</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>If you want to associate every event that happened between 2 P.M.
      and 3 P.M. with the 2 P.M. hour, or every event that happened in a
      particular year with the first instant of that year, you need to
      truncate a <literal moreinfo="none">Date</literal> at a specified
      <literal moreinfo="none">Calendar</literal> field. When a <literal
      moreinfo="none">Date</literal> is truncated, it is rounded down;
      <literal moreinfo="none">DateUtils.truncate()</literal> is the
      equivalent of <literal moreinfo="none">Math.floor( )</literal> for the
      <literal moreinfo="none">Date</literal> class. If it is 4:02 P.M. on
      October 31, 1975, a <literal moreinfo="none">Date</literal> object
      truncated at the <literal moreinfo="none">Calendar.HOUR</literal> field
      will point to 4:00 P.M., and a <literal moreinfo="none">Date</literal>
      truncated at the <literal moreinfo="none">Calendar.YEAR</literal> field
      will point to the first millisecond of the first minute, of the first
      hour, of the first day of year 2005: <filename moreinfo="none">January
      01 2005: 12:00:00.000 A.M</filename>.</para>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para><literal moreinfo="none">DateUtils.truncate( )</literal> can also
      be used to truncate a date to the nearest <literal
      moreinfo="none">DateUtils.SEMI_MONTH</literal>. <link
      linkend="lang-sect-rounding-date">Recipe 1.14</link> discusses <literal
      moreinfo="none">DateUtils.SEMI_MONTH</literal> in more detail.</para>
    </sect2>
  </sect1>

  <sect1 id="lang-sect-create-enum" label="1.16" role="Recipe">
    <title>Creating an Enum</title>

    <sect2>
      <title>Problem</title>

      <para>You need an Enum, but<indexterm class="startofrange"
          id="lang-ITERM-1895" significance="normal">
          <primary>enums, creating</primary>
        </indexterm> <indexterm class="startofrange" id="lang-ITERM-1896"
          significance="normal">
          <primary>formatting</primary>

          <secondary>enums</secondary>
        </indexterm> you are not using the new Java 1.5 release.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>If you are stuck with Java 1.4 or lower, you can use Commons Lang
      <literal moreinfo="none">Enum</literal>, <literal
      moreinfo="none">ValuedEnum</literal>, and <literal
      moreinfo="none">EnumUtils</literal> to create an enum "type," which
      approximates the new language feature. <link
      linkend="lang-ex-10">Example 1-10</link> extends Enum, providing three
      flavors: <literal moreinfo="none">Flavor.CHOCOLATE</literal>, <literal
      moreinfo="none">Flavor.VANILLA</literal>, and <literal
      moreinfo="none">Flavor.STRAWBERRY</literal>.</para>

      <example id="lang-ex-10" label="1-10">
        <title>Defining a Flavor enumeration by extending Enum</title>

        <programlisting language="java" format="linespecific">import java.util.*;
import org.apache.commons.lang.enum.Enum;

public final class Flavor extends Enum {
    public static Flavor CHOCOLATE = new Flavor( "Chocolate" );
    public static Flavor VANILLA = new Flavor( "Vanilla" );
    public static Flavor STRAWBERRY = new Flavor( "Strawberry" );

    private Flavor(String name, int value) { super( name, value ); }

    public static Flavor getEnum(String flavor) {
        return (Flavor) getEnum(Flavor.class, flavor);
    }
 
    public static Map getEnumMap( ) {
        return getEnumMap(Flavor.class);
    }
 
    public static List getEnumList( ) {
        return getEnumList(Flavor.class);
    }
 
    public static Iterator iterator( ) {
        return iterator(Flavor.class);
    }
}</programlisting>
      </example>

      <para>The key to an <literal moreinfo="none">Enum</literal> is the
      private constructor; this guarantees that there are only three instances
      of <literal moreinfo="none">Flavor</literal> in any virtual machine.
      This extension of <literal moreinfo="none">Enum</literal> provides a
      number of useful utilities to get a <literal
      moreinfo="none">List</literal> or <literal moreinfo="none">Map</literal>
      of available <literal moreinfo="none">Flavor</literal> instances:</para>

      <programlisting language="java" format="linespecific" id="I_1_tt43">// Using Flavor to create an ice cream cone
IceCreamCone cone = new IceCreamCone( );
cone.setScoops( 5 );
cone.setFlavor( Flavor.VANILLA );
cone.addTopping( "sprinkles" );

List flavors = Flavor.getEnumList( );
System.out.println( ArrayUtils.toString( flavors.toString( ) ) );
// prints "{ Chocolate, Vanilla, Strawberry }"</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>Assume that you are writing a system to classify choral singers by
      voice type: soprano, alto, tenor, and bass. Your database has a table
      <literal moreinfo="none">dbo.lu_VoicePart</literal>, which contains a
      part name and a numeric part code. This voice part is a coded type; it
      needs both a name and a code, and a straightforward design is achieved
      by extending <literal moreinfo="none">ValuedEnum</literal> <indexterm
          id="lang-ITERM-1897" significance="normal">
          <primary>ValuedEnum, extending</primary>
        </indexterm>. <literal moreinfo="none">ValuedEnum</literal> is an
      <literal moreinfo="none">Enum</literal> that keeps track of a numeric
      code for each instance of the enumeration. <literal
      moreinfo="none">PartEnum</literal> extends <literal
      moreinfo="none">ValuedEnum</literal> to store static instances of the
      four possible voice parts: soprano, alto, tenor, and bass. (See <link
      linkend="lang-ex-11">Example 1-11</link>.)</para>

      <example id="lang-ex-11" label="1-11">
        <title>Extending ValuedEnum to create an enum</title>

        <programlisting language="java" format="linespecific">import java.util.*;
import org.apache.commons.lang.enum.ValuedEnum;

public final class PartEnum extends ValuedEnum {
    public static int  SOPRANO_VAL = 1;
    public static int  ALTO_VAL = 2;
    public static int  TENOR_VAL = 3;
    public static int  BASS_VAL = 4;

    public static PartEnum SOPRANO = new PartsEnum( "Soprano", SOPRANO_VAL );
    public static PartEnum ALTO = new PartsEnum( "Alto", ALTO_VAL );
    public static PartEnum TENOR = new PartsEnum( "Tenor", TENOR_VAL );
    public static PartEnum BASS = new PartsEnum( "Bass", BASS_VAL );

    private PartsEnum(String name, int value) { super( name, value ); }

    public static PartEnum getEnum(String part) {
        return (PartEnum) getEnum(PartEnum.class, part);
    }

    public static PartEnum getEnum(int part) {
        return (PartEnum) getEnum(PartEnum.class, part);
    }

    public static Map getEnumMap( ) {
        return getEnumMap(PartEnum.class);
    }

    public static List getEnumList( ) {
        return getEnumList(PartEnum.class);
    }

    public static Iterator iterator( ) {
        return iterator(PartEnum.class);
    }
}</programlisting>
      </example>

      <para>This class extends <literal moreinfo="none">ValuedEnum</literal>
      and has a private constructor. This guarantees that the only instances
      of this enumeration will be defined in <literal
      moreinfo="none">PartEnum</literal>; four instances of <literal
      moreinfo="none">PartEnum</literal> are created as public static final
      constants, and a name is assigned to every part. (See <link
      linkend="lang-ex-12">Example 1-12</link>.)</para>

      <example id="lang-ex-12" label="1-12">
        <title>Vocalist bean with a PartEnum</title>

        <programlisting language="java" format="linespecific">public class Vocalist {
    private String name;
    private PartEnum part;

    public String getName( ) { return name; }
    public void setName(String name) { this.name = name; }

    public PartEnum getPart( ) { return part; }
    public void setPart(PartEnum part) { this.part = part; }
}</programlisting>
      </example>

      <para>Checking for every voice part involves a call to <literal
      moreinfo="none">PartEnum.iterator( )</literal>, which obviates the need
      for an <literal moreinfo="none">if</literal>/<literal
      moreinfo="none">else if</literal> control statement to catch every
      single voice part:</para>

      <programlisting language="java" format="linespecific" id="I_1_tt44">Iterator parts = PartEnum.iterator( );
while( parts.hasNext( ) ) {
  PartEnum part = (PartEnum) parts.next( );
  if( part.equals( vocalist.getPart( ) ) ) {
    System.out.println( "Vocalist is a " + part.getValue( ) );
  }
}</programlisting>

      <para>This example did not include any reference to a specific voice
      part, but, if your code needs to reference a specific voice type, it can
      use the static constants in <literal
      moreinfo="none">PartEnum</literal>—<literal
      moreinfo="none">PartEnum.SOPRANO</literal>, <literal
      moreinfo="none">PartEnum.ALTO</literal>, <literal
      moreinfo="none">PartEnum.TENOR</literal>, and <literal
      moreinfo="none">PartEnum.BASS</literal>. And, lastly, it is impossible
      to create a <literal moreinfo="none">Vocalist</literal> object with an
      invalid voice part, as the part property must be one of the four static
      instances of <literal moreinfo="none">PartEnum</literal> defined in a
      <literal moreinfo="none">PartEnum</literal> or <literal
      moreinfo="none">null</literal>.</para>

      <para>Using Enum types becomes especially important if an object has
      multiple classifications. If you were creating an object to track a
      person, you could easily end up with two overlapping classifications. In
      <link linkend="lang-ex-13">Example 1-13</link>, both <literal
      moreinfo="none">jobStatus</literal> and <literal
      moreinfo="none">gender</literal> can be <literal
      moreinfo="none">UNKNOWN</literal>, and the valid options for both
      <literal moreinfo="none">jobStatus</literal> and <literal
      moreinfo="none">gender</literal> are defined as public static <literal
      moreinfo="none">int</literal> variables.</para>

      <example id="lang-ex-13" label="1-13">
        <title>Using public static final constants for category
        information</title>

        <indexterm id="lang-ITERM-1898" significance="normal">
          <primary>public static final constants</primary>
        </indexterm>

        <indexterm id="lang-ITERM-1899" significance="normal">
          <primary>constants</primary>

          <secondary>public static final</secondary>
        </indexterm>

        <programlisting language="java" format="linespecific">public class Person {
    public static final int STUDENT = -1;
    public static final int EMPLOYED = 0;
    public static final int UNEMPLOYED = 1;
    public static final int RETIRED = 2;
    public static final int UNKNOWN = 3;
    public static final int MALE = 0;
    public static final int FEMALE = 1;

    private int jobStatus;
    private int gender;

    public int getJobStatus( ) { return jobStatus; }
    public void setJobStatus(int jobStatus) { this.jobStatus = jobStatus; }

    public int getGender( ) { return gender; }
    public void setGender(int gender) { this.gender = gender; }
}</programlisting>
      </example>

      <para>This class defines two properties—<literal
      moreinfo="none">jobStatus</literal> and <literal
      moreinfo="none">gender</literal>—and both correspond to codes stored in
      the database. This system needs to know; that <literal
      moreinfo="none">MALE</literal>, <literal
      moreinfo="none">FEMALE</literal>, and <literal
      moreinfo="none">UNKNOWN</literal> are the valid values for the <literal
      moreinfo="none">gender</literal> property; and <literal
      moreinfo="none">STUDENT</literal>, <literal
      moreinfo="none">EMPLOYED</literal>, <literal
      moreinfo="none">UNEMPLOYED</literal>, <literal
      moreinfo="none">UNKNOWN</literal>, and <literal
      moreinfo="none">RETIRED</literal> all correspond to the <literal
      moreinfo="none">jobStatus</literal> property. This class does not define
      which constants are related to which property. Is <literal
      moreinfo="none">UNKNOWN</literal> a <literal
      moreinfo="none">gender</literal> or a <literal
      moreinfo="none">jobStatus</literal>? Some systems rename these static
      variables to reflect which properties they correspond to—<literal
      moreinfo="none">GENDER_MALE</literal>, <literal
      moreinfo="none">GENDER_FEMALE</literal>, <literal moreinfo="none">and
      GENDER_UNKNOWN</literal> would clearly correspond to the <literal
      moreinfo="none">gender</literal> property; and <literal
      moreinfo="none">JOB_STUDENT</literal>, <literal
      moreinfo="none">JOB_EMPLOYED</literal>, <literal
      moreinfo="none">JOB_UNEMPLOYED</literal>, <literal
      moreinfo="none">JOB_UNKNOWN</literal>, and <literal
      moreinfo="none">JOB_RETIRED</literal> would correspond to the <literal
      moreinfo="none">jobStatus</literal> property. This solution only draws a
      conceptual boundary in the mind of the programmer; no logical separation
      is achieved, and there is still no way to guarantee that a bean property
      will have a valid value. (See <link linkend="lang-ex-14">Example
      1-14</link>.)</para>

      <example id="lang-ex-14" label="1-14">
        <title>Simplifying with ValueEnum</title>

        <programlisting language="java" format="linespecific">public class Person {
    private JobStatusEnum jobStatus;
    private GenderEnum gender;

    public JobStatusEnum getJobStatus( ) { return jobStatus; }
    public void setJobStatus(JobStatusEnum jobStatus) { 
        this.jobStatus = jobStatus; 
    }

    public GenderEnum getGender( ) { return gender; }
    public void setGender(GenderEnum gender) { this.gender = gender; }
}</programlisting>
      </example>

      <para>The solution to this problem can be solved by extending <literal
      moreinfo="none">ValuedEnum</literal> and getting rid of the confusing
      mish-mash of public static constants. If you find yourself frequently
      creating static variables to reflect categories or types, enums are the
      solution. And, if you haven't upgraded to Java 1.5, use<indexterm
      class="endofrange" id="lang-ITERM-1900" significance="normal"
      startref="lang-ITERM-1895"></indexterm> <indexterm class="endofrange"
      id="lang-ITERM-1901" significance="normal"
      startref="lang-ITERM-1896"></indexterm> Commons Lang <literal
      moreinfo="none">Enum</literal> and <literal
      moreinfo="none">ValuedEnum</literal>.</para>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>As mentioned previously, Java 1.5 (or Tiger) has a new language
      feature: enums. If you are using Java 1.5, see the "Java 1.5 in a
      Nutshell" article from Sun Microsystems at <ulink
      url="http://java.sun.com/developer/technicalArticles/releases/j2se15/">http://java.sun.com/developer/technicalArticles/releases/j2se15/</ulink>.</para>
    </sect2>
  </sect1>

  <sect1 id="lang-sect-valid-params" label="1.18" role="Recipe">
    <title>Validation of Method Parameters</title>

    <sect2>
      <title>Problem</title>

      <para>You need to validate parameters <indexterm class="startofrange"
          id="lang-ITERM-1926" significance="normal">
          <primary>parameters</primary>

          <secondary>validation</secondary>
        </indexterm> <indexterm class="startofrange" id="lang-ITERM-1927"
          significance="normal">
          <primary>validation</primary>

          <secondary>parameters</secondary>
        </indexterm> <indexterm class="startofrange" id="lang-ITERM-1928"
          significance="normal">
          <primary>testing</primary>

          <secondary>parameters</secondary>
        </indexterm>passed to a method. You would prefer one line of code to
      test that a method parameter is valid.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use <literal moreinfo="none">Validate</literal> to check method
      parameters. <literal moreinfo="none">Validate</literal> can check for
      empty or <literal moreinfo="none">null</literal> parameters, as well as
      evaluate any logical conditions. <link linkend="lang-ex-18">Example
      1-18</link> demonstrates the use of <literal
      moreinfo="none">Validate</literal> to perform a few simple
      validations.</para>

      <example id="lang-ex-18" label="1-18">
        <title>Using Validate to perform simple validations</title>

        <programlisting language="java" format="linespecific">import org.apache.commons.lang.Validate;

public doSomething( int param1, Object[] param2, Collection param3 ) {

    Validate.isTrue( param1 &gt; 0, "param must be greater than zero" );
    Validate.notEmpty( param2, "param2 must not be empty" );
    Validate.notEmpty( param3, "param3 must not be empty" );
    Validate.noNullElements( param3, "param3 cannot contain null elements" );

    // do something complex and interesting
}</programlisting>
      </example>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>Write finicky methods. Don't just work with any input, have some
      standards. Don't hang around with garbage or <literal
      moreinfo="none">null</literal>s—clean up your act, and use <literal
      moreinfo="none">Validate</literal>. Methods in <literal
      moreinfo="none">Validate</literal> throw an <literal
      moreinfo="none">IllegalArgumentException</literal> if invalid parameters
      are encountered. <literal moreinfo="none">Validate.notEmpty( )</literal>
      will throw an exception if the parameter is <literal
      moreinfo="none">null</literal> or empty, and <literal
      moreinfo="none">Validate.isTrue( )</literal> takes a logical expression
      that must evaluate to true. <link linkend="lang-TABLE-5">Table
      1-5</link> lists a number of static methods of <literal
      moreinfo="none">Validate</literal>.</para>

      <table id="lang-TABLE-5" label="1-5">
        <title>Available static methods on Validate</title>

        <tgroup cols="2">
          <colspec colname="col1" colnum="1" />

          <colspec colname="col2" colnum="2" />

          <thead>
            <row>
              <entry><para>Validate method</para></entry>

              <entry><para>Description</para></entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><para> <literal moreinfo="none">isTrue(boolean
              expr)</literal> </para></entry>

              <entry><para>Fails if expression evaluates to
              false</para></entry>
            </row>

            <row>
              <entry><para> <literal moreinfo="none">isTrue(boolean expr,
              String msg)</literal> </para></entry>

              <entry><para>Same as above; constructs exception with a
              message</para></entry>
            </row>

            <row>
              <entry><para> <literal moreinfo="none">noNullElements(Collection
              col)</literal> </para></entry>

              <entry><para>Fails if collection contains a null</para></entry>
            </row>

            <row>
              <entry><para> <literal moreinfo="none">noNullElements(Object[]
              array)</literal> </para></entry>

              <entry><para>Fails if array contains a null</para></entry>
            </row>

            <row>
              <entry><para> <literal moreinfo="none">notEmpty(Collection
              col)</literal> </para></entry>

              <entry><para>Fails if collection is empty</para></entry>
            </row>

            <row>
              <entry><para> <literal moreinfo="none">notEmpty(Map
              map)</literal> </para></entry>

              <entry><para>Fails if map is empty</para></entry>
            </row>

            <row>
              <entry><para> <literal moreinfo="none">notEmpty(Object[]
              array)</literal> </para></entry>

              <entry><para>Fails if array is empty</para></entry>
            </row>

            <row>
              <entry><para> <literal moreinfo="none">notNull(Object
              obj)</literal> </para></entry>

              <entry><para>Fails if object is null</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Well-written code tests input and parameters. Is the number within
      a given range? Has the user supplied an index that is out of bounds for
      this array? Unless you want your applications to break down and throw
      exceptions, make sure that you are not trying to access the 15th element
      of a 10-element array; your code should be skeptical of parameters and
      refuse to run if it doesn't get its way. In fragile systems, parameter
      validation is not a top priority; errors are dealt with as different
      application layers throw a potpourri of exceptions. Other, more
      unstable, systems will pass a <literal moreinfo="none">null</literal>
      all the way down the call stack until the lowest level blows up and
      spits back a <literal
      moreinfo="none">NullPointerException</literal>—with a long-winded stack
      trace. Don't play around with <literal
      moreinfo="none">null</literal>—avoid it, test your system exhaustively,
      and throw an <literal
      moreinfo="none">IllegalArgumentException</literal>.</para>

      <para>Consider the following method, which takes a latitude, longitude,
      and mode parameter. Both the latitude and longitude must fall within a
      valid range, and this method should throw an <literal
      moreinfo="none">IllegalArgumentException</literal> if it encounters an
      unrealistic latitude, an unrealistic longitude, or an empty mode
      parameter. The <literal moreinfo="none">Validate</literal> utility used
      in conjunction with a <literal moreinfo="none">DoubleRange</literal>
      object can reduce the amount of code dedicated to range checking and
      method parameter validation. To test the validity of the coordinates,
      two constant <literal moreinfo="none">DoubleRange</literal> objects are
      created outside of the method. <literal
      moreinfo="none">DoubleRange.includesDouble(double</literal> <literal
      moreinfo="none">d)</literal> returns true if the number falls within the
      defined range—<literal moreinfo="none">if x &lt;= rangeMax &amp;&amp; x
      &gt;= rangeMin</literal>. (See <link linkend="lang-ex-19">Example
      1-19</link>.)</para>

      <example id="lang-ex-19" label="1-19">
        <title>Using the Validator and the DoubleRange to validate method
        parameters</title>

        <programlisting language="java" format="linespecific">public static final DoubleRange LAT_RANGE = new DoubleRange(  -90.0,  90.0 );
public static final DoubleRange LON_RANGE = new DoubleRange( -180.0, 180.0 );

public double elevation( double latitude, 
                         double longitude,
                         String mode ) {
    Validate.notEmpty( mode, "Mode cannot be empty or null" );
    Validate.isTrue( LAT_RANGE.includesDouble( latitude ),
                      "Lat not in range " + latRange, latitude );
    Validate.isTrue( LON_RANGE.includesDouble( longitude ),
                      "Lon not in range " + lonRange, longitude );

    double elevation = 0.0;
    // code to implement the elevation method
    return elevation;
}</programlisting>
      </example>

      <para>It takes a fair amount of institutional discipline to make sure
      that a code base has a sufficient amount of validation, and it is
      surprising how often systems scale to thousands of lines without it.
      Systems without good internal validation and sanity checks are
      characterized by frequent occurrences of <literal
      moreinfo="none">NullPointerException</literal> and <literal
      moreinfo="none">RuntimeException</literal>. Throwing <literal
      moreinfo="none">RuntimeException</literal> in the form of <literal
      moreinfo="none">IllegalArgumentException</literal> might seem like an
      odd recipe for increasing overall stability. But, if you actively throw
      exceptions and test exhaustively, it will be less toil and trouble to
      identify and fix defects—your application will fail sooner, and you will
      have short stack traces and well-defined problems. Performing rigorous
      parameter validation alone will not create a stable system, but it is
      part of a larger equation, which involves unit testing and
      validation.</para>

      <para>In addition to parameter validation, you should be writing unit
      tests that test this validation. If you write good unit tests using
      JUnit and then measure your test coverage with a tool like Clover or
      JCoverage, you can save yourself an amazing amount of grief fixing
      unanticipated defects. Your unit tests should be covering close to 100%
      of your code, and they should throw curveballs. Don't just test the
      expected situation—if your method takes a double, see what it does with
      <literal moreinfo="none">Double.POSITIVE_INFINITY</literal>; and if your
      method takes an array, pass it a <literal
      moreinfo="none">null</literal>. Test the unexpected; if you find that
      your method melts down with a <literal moreinfo="none">null</literal>,
      check the parameter with <literal moreinfo="none">Validate</literal>.
      100% test coverage is not an unrealistic ideal; it will drive your
      validation code. More test coverage always leads to a higher level of
      system quality.</para>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para><link linkend="math">Chapter 8</link> discusses <literal
      moreinfo="none">DoubleRange</literal> and other utilities for capturing
      a range of numbers.</para>

      <para>Chapters 4 to Chapter 7 of the <emphasis>Java Extreme Programming
      Cookbook</emphasis> by Eric Burke and Brian Coyner (O'Reilly) are great
      introductions to unit testing tools and concepts. Read this book for an
      introduction to JUnit, HttpUnit, mock objects, and the idea of unit
      testing. Think of <literal moreinfo="none">Validate</literal> as a
      runtime test for a method; the methods on <literal
      moreinfo="none">Validate</literal> are analogous to the <literal
      moreinfo="none">assert( )</literal> methods in JUnit's <literal
      moreinfo="none">TestCase</literal> class.</para>

      <para>If you are interested in measuring code coverage of unit tests,
      take some time to look at Clover from Cortex eBusiness. Cortex eBusiness
      offers a free license to Open Source projects, but if you are using the
      product in a commercial environment, it is around $250. More information
      about Clover is available at <ulink
      url="http://www.thecortex.net/clover/">http://www.thecortex.net/clover/</ulink>.
      Other than Clover, there is another tool named JCoverage, which can also
      be used to measure test coverage. More information about JCoverage is
      available at <ulink
      url="http://www.jcoverage.com/">http://www.jcoverage.com/</ulink>. For
      more information <indexterm class="endofrange" id="lang-ITERM-1929"
      significance="normal" startref="lang-ITERM-1926"></indexterm> <indexterm
      class="endofrange" id="lang-ITERM-1930" significance="normal"
      startref="lang-ITERM-1927"></indexterm> <indexterm class="endofrange"
      id="lang-ITERM-1931" significance="normal"
      startref="lang-ITERM-1928"></indexterm>about JUnit, go to <ulink
      url="http://www.junit.org/">http://www.junit.org/</ulink>.</para>
    </sect2>
  </sect1>

  <sect1 id="lang-sect-measure-time" label="1.19" role="Recipe">
    <title>Measuring Time</title>

    <sect2>
      <title>Problem</title>

      <para>You need to determine how much<indexterm class="startofrange"
          id="lang-ITERM-1932" significance="normal">
          <primary>measuring</primary>

          <secondary>time</secondary>
        </indexterm> <indexterm class="startofrange" id="lang-ITERM-1933"
          significance="normal">
          <primary>time, measuring</primary>
        </indexterm> time has elapsed during the execution of a block of
      code.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use <literal moreinfo="none">StopWatch</literal> <indexterm
          id="lang-ITERM-1934" significance="normal">
          <primary>StopWatch</primary>
        </indexterm> to measure the time it takes to execute a section of
      code. <link linkend="lang-ex-20">Example 1-20</link> demonstrates the
      use of this class to measure the time it takes to perform simple
      arithmetic operations.</para>

      <example id="lang-ex-20" label="1-20">
        <title>Using StopWatch to measure time</title>

        <programlisting language="java" format="linespecific">import org.apache.commons.lang.time.StopWatch;

StopWatch clock = new StopWatch( );
        
System.out.println("Time to Math.sin(0.34) ten million times?" );
clock.start( );
for( int i = 0; i &lt; 100000000; i++ ) {
    Math.sin( 0.34 );
}
clock.stop( );
System.out.println( "It takes " + clock.getTime( ) + " milliseconds" );

clock.reset( );
System.out.println( "How long to multiply 2 doubles one billion times?" );

clock.start( );
for( int i = 0; i &lt; 1000000000; i++) {
    double result = 3423.2234 * 23e-4;
}
clock.stop( );
System.out.println( "It takes " + clock.getTime( ) + " milliseconds." );</programlisting>
      </example>

      <para>This example measures execution time with <literal
      moreinfo="none">StopWatch</literal> and produces the following
      output:</para>

      <programlisting format="linespecific" id="I_1_tt47">Time to Math.sin(0.34) ten million times?
It takes 6865 milliseconds

How long to multiply 2 doubles one billion times?
It takes 1992 milliseconds.</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para><literal moreinfo="none">StopWatch</literal> performs the same
      functions as a physical stop watch; you can start, stop, pause, resume,
      reset, and split the clock. The name of this utility conveys
      unmistakable meaning: starting, stopping, pausing, and resuming a clock
      are methods that need no explanation, and resetting an instance of
      <literal moreinfo="none">StopWatch</literal> simply resets the elapsed
      time to zero. When a <literal moreinfo="none">StopWatch</literal> is
      "split" the clock continues to tick, but every call to <literal
      moreinfo="none">StopWatch.getTime()</literal> <indexterm
          id="lang-ITERM-1935" significance="normal">
          <primary>StopWatch.getTime( ) method</primary>
        </indexterm> <indexterm id="lang-ITERM-1936" significance="normal">
          <primary>methods</primary>

          <secondary>StopWatch.getTime( )</secondary>
        </indexterm> will return the time at which <literal
      moreinfo="none">split( )</literal> was invoked. This is analogous to the
      "lap" button on a real stop watch; the <literal
      moreinfo="none">StopWatch.split( )</literal> causes <literal
      moreinfo="none">StopWatch.getTime( )</literal> to return "lap time."
      When a runner completes a lap, you can "freeze" the lap time while the
      clock continues to count seconds. Once you split a <literal
      moreinfo="none">StopWatch</literal>, you will need to invoke the
      <literal moreinfo="none">StopWatch.unsplit( )</literal> <indexterm
          id="lang-ITERM-1937" significance="normal">
          <primary>StopWatch.unsplit( ) method</primary>
        </indexterm> <indexterm id="lang-ITERM-1938" significance="normal">
          <primary>methods</primary>

          <secondary>StopWatch.unsplit( )</secondary>
        </indexterm> method to measure the total time elapsed since the clock
      was started.</para>

      <para><link linkend="lang-ex-21">Example 1-21</link> demonstrates the
      <literal moreinfo="none">split()</literal> <indexterm
          id="lang-ITERM-1939" significance="normal">
          <primary>split( ) method</primary>
        </indexterm> <indexterm id="lang-ITERM-1940" significance="normal">
          <primary>methods</primary>

          <secondary>split( )</secondary>
        </indexterm> method on <literal moreinfo="none">StopWatch</literal>.
      The clock continues to tick for three seconds, and after one second the
      <literal moreinfo="none">StopWatch</literal> is split. Calling <literal
      moreinfo="none">getTime()</literal> between the split and unsplit times
      will return one second. After three seconds, the <literal
      moreinfo="none">unsplit( )</literal> method is invoked, and calling
      <literal moreinfo="none">getTime( )</literal> <indexterm
          id="lang-ITERM-1941" significance="normal">
          <primary>getTime( ) method</primary>
        </indexterm> <indexterm id="lang-ITERM-1942" significance="normal">
          <primary>methods</primary>

          <secondary>getTime( )</secondary>
        </indexterm> returns three seconds. <link linkend="lang-fig-1">Figure
      1-1</link> shows a timeline for this example.</para>

      <figure float="0" id="lang-fig-1" label="1-1">
        <title>Timeline of StopWatch.split( ) and unsplit( )</title>

        <mediaobject id="I_1_tt48">
          <imageobject role="print">
            <imagedata depth="53" fileref="figs/print/jccb_0101.pdf"
                       format="PDF" width="182" />
          </imageobject>

          <imageobject role="web">
            <imagedata depth="53" fileref="figs/web/jccb_0101.png"
                       format="PNG" width="182" />
          </imageobject>
        </mediaobject>
      </figure>

      <example id="lang-ex-21" label="1-21">
        <title>Using the StopWatch.split( ) and StopWatch.unsplit( )
        methods</title>

        <programlisting language="java" format="linespecific">import org.apache.commons.lang.time.StopWatch;

System.out.println( "Testing the split( ) method." );

clock.reset( );
clock.start( );
try { Thread.sleep(1000); } catch( Exception e ) {}

clock.split( );
System.out.println( "Split Time after 1 sec: " + clock.getTime( ) );

try { Thread.sleep(1000); } catch( Exception e ) {}
System.out.println( "Split Time after 2 sec: " + clock.getTime( ) );

clock.unsplit( );
try { Thread.sleep(1000); } catch( Exception e ) {}
System.out.println( "Time after 3 sec: " + clock.getTime( ) );</programlisting>
      </example>

      <para>This example produces the following output, which shows that a
      split at one second resulted in 1001 being returned by the <literal
      moreinfo="none">StopWatch</literal> after two seconds:</para>

      <programlisting format="linespecific" id="I_1_tt49">Split Time after 1 sec: 1001
Split Time after 2 sec: 1001
Time after 3 sec: 3004</programlisting>

      <para>The same requirements are easily fulfilled without the use of the
      <literal moreinfo="none">StopWatch</literal> class. A program can
      measure time by calling <literal
      moreinfo="none">System.currentTimeMillis( )</literal> and subtracting
      the time after a section of code from a time measured before that same
      section of code; this yields the number of milliseconds elapsed. But the
      real benefit of using this little Commons Lang utility is to the
      readability and maintainability of a system. Writing good code is
      similar to writing a well-written essay, and <literal
      moreinfo="none">StopWatch</literal> is a clear and concise noun that
      conveys direct meaning; it is a tangible analogy to a familiar object.
      In the previous example, the execution time of a block of code was
      obtained without adding clutter. Statements like <literal
      moreinfo="none">clock.start( )</literal> and <literal
      moreinfo="none">clock.stop()</literal> are more apparent than <literal
      moreinfo="none">long time1 = System.currentTimeMillis( )</literal>
      <indexterm id="lang-ITERM-1943" significance="normal">
          <primary>System.currentTimeMillis( ) method</primary>
        </indexterm> <indexterm id="lang-ITERM-1944" significance="normal">
          <primary>methods</primary>

          <secondary>System.currentTimeMillis( )</secondary>
        </indexterm> and <literal moreinfo="none">long time2</literal>
      <literal moreinfo="none">= System.currentTimeMillis( )</literal>. And,
      for the same reasons, <literal moreinfo="none">clock.getTime()</literal>
      <indexterm id="lang-ITERM-1945" significance="normal">
          <primary>clock.getTime( ) method</primary>
        </indexterm> <indexterm id="lang-ITERM-1946" significance="normal">
          <primary>methods</primary>

          <secondary>clockgetTime( )</secondary>
        </indexterm> conveys a stronger message <indexterm class="endofrange"
      id="lang-ITERM-1947" significance="normal"
      startref="lang-ITERM-1932"></indexterm> <indexterm class="endofrange"
      id="lang-ITERM-1948" significance="normal"
      startref="lang-ITERM-1933"></indexterm>than <literal
      moreinfo="none">long timeElapsed = time2</literal> <literal
      moreinfo="none">- time1</literal>.</para>
    </sect2>
  </sect1>
</chapter>
