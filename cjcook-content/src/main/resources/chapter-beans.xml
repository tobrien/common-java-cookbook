<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="beans" label="3">
  <title>JavaBeans</title>

  <sect1 id="beans-sect-intro">
    <title>Introduction</title>

    <para>Beans are everywhere, popping up in web-application frameworks,
    enterprise applications, Swing Graphical User Interface (GUIs), templating
    engines, and object-relational mapping (ORM) tools. Most systems have some
    sort of object model; for example, an electronic commerce application
    would have an object model involving an <literal
    moreinfo="none">Invoice</literal>, which relates to a <literal
    moreinfo="none">Customer</literal>; or a sports news web site would have
    related <literal moreinfo="none">Athlete</literal>, <literal
    moreinfo="none">Sport</literal>, and <literal
    moreinfo="none">Team</literal> objects. Frequently, objects in these
    object models are beans—simple objects with properties, encapsulating
    access to these properties via public getter and setter methods.</para>

    <para>In 1997, Sun Microsystems published Version 1.01 of the <indexterm
        id="beans-ITERM-2103" significance="normal">
        <primary>JavaBeans</primary>
      </indexterm>JavaBeans© specification. Initially, Sun offered beans as
    visual components for graphical user interfaces; JavaBeans were to be the
    equivalent of Microsoft's ActiveX controls—a framework and set of
    interfaces for creating reusable and pluggable GUI components. Used as
    components, which exposed states through a series of accessor and mutator
    (<literal moreinfo="none">getX( )</literal> and <literal
    moreinfo="none">setX()</literal>) methods, a developer would develop a GUI
    Java application by creating a visual layout using an IDE like Visual Cafe
    or JBuilder. If you've ever developed with Microsoft tools, you'll know
    exactly what this means—Java was going to unseat Visual Basic, and GUI
    development was going to be easier than easy. According to the JavaBeans
    Specification Version 1.01 from 1997:</para>

    <blockquote>
      <para>A Java Bean is a reusable software component that can be
      manipulated visually in a builder tool.</para>
    </blockquote>

    <para>Don't be misled; 1997 was ages ago, and the concept of the bean has
    evolved. In the last seven years, Java has become a dominant technology
    for server-side applications; impressive Swing applications do exist, but
    Java has not been an attractive platform for desktop application
    development due to reasons technical, economic, and judicial.</para>

    <para>Don't be confused by the 1997 JavaBeans specification, either; it is
    still relevant, but, when used in the context of this book, the term
    <filename moreinfo="none">bean</filename> is any object with a no-argument
    constructor, which encapsulates access to private member variables via
    getter and setter methods. <link linkend="beans-ex-1">Example 3-1</link>
    defines a bean, <literal moreinfo="none">SimpleBean</literal> <indexterm
        id="beans-ITERM-2104" significance="normal">
        <primary>SimpleBean</primary>
      </indexterm>, which contains two bean properties—<literal
    moreinfo="none">name1</literal> and <literal
    moreinfo="none">name2</literal>.</para>

    <example id="beans-ex-1" label="3-1">
      <title>Sample bean</title>

      <programlisting format="linespecific">package org.test.bean;

public class SimpleBean {
    private String name1;
    private String name2;

    public SimpleBean( ) {}

    public String getName1( ) { return name1; }
    public void setName1(String name1) { this.name1 = name1; }

    public String getName2( ) { return name2; }
    public void setName2(String name2) { this.name2 = name2; }
}</programlisting>
    </example>

    <para>The presence of the public methods <literal
    moreinfo="none">getName1( )</literal> and <literal
    moreinfo="none">getName2( )</literal> make the bean properties <literal
    moreinfo="none">name1</literal> and <literal
    moreinfo="none">name2</literal> readable, and the public methods <literal
    moreinfo="none">setName1( )</literal> and <literal
    moreinfo="none">setName2( )</literal> make these properties writable. A
    bean should also have a public no-argument constructor; other constructors
    are not prohibited, but, since many tools need to dynamically create and
    populate beans, a no-argument constructor is required.</para>

    <para>The original JavaBeans specification is available at <ulink
    url="http://java.sun.com/products/javabeans/docs/spec.html">http://java.sun.com/products/javabeans/docs/spec.html</ulink>.
    The JavaBeans specification still exists and features have been added to
    the Java 1.4 release to support reading and writing JavaBeans to
    Extensible Markup Language (XML) documents. More information about more
    modern additions to the JavaBeans specification can be found at <ulink
    url="http://java.sun.com/j2se/1.4.2/docs/guide/beans/changes14.html">http://java.sun.com/j2se/1.4.2/docs/guide/beans/changes14.html</ulink>.</para>
  </sect1>

  <sect1 id="beans-sect-obtaining" label="3.2" role="Recipe">
    <title>Obtaining Commons BeanUtils</title>

    <sect2>
      <title>Problem</title>

      <para>You want to use <indexterm id="beans-ITERM-2124"
          significance="normal">
          <primary>Commons BeanUtils</primary>

          <secondary>downloading</secondary>
        </indexterm> <indexterm id="beans-ITERM-2125" significance="normal">
          <primary>downloading</primary>

          <secondary>Commons BeanUtils</secondary>
        </indexterm> <indexterm id="beans-ITERM-2126" significance="normal">
          <primary>beans</primary>

          <secondary>Commons BeanUtils</secondary>

          <tertiary>downloading</tertiary>
        </indexterm> <indexterm id="beans-ITERM-2127" significance="normal">
          <primary>JavaBeans</primary>

          <secondary>Commons BeanUtils</secondary>

          <tertiary>downloading</tertiary>
        </indexterm>Commons BeanUtils to manipulate and access simple,
      indexed, and nested bean properties.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>To use Commons BeanUtils in a Maven 2 project, add the following
      dependency to your project's <filename>pom.xml</filename>:</para>

      <example id="beans-ex-add-depend-beanutils">
        <title>Adding a Dependency on Commons BeanUtils</title>

        <programlisting>    &lt;dependency&gt;
      &lt;groupId&gt;commons-beanutils&lt;/groupId&gt;
      &lt;artifactId&gt;commons-beanutils&lt;/artifactId&gt;
      &lt;version&gt;1.8.0&lt;/version&gt;
    &lt;/dependency&gt;
</programlisting>
      </example>

      <para>If you are not sure what this means, I'd suggest reading <ulink
      url="http://www.sonatype.com/books/maven-book">Maven: The Definitive
      Guide</ulink>. When you depend on a library in Maven 2, all you need to
      do is add the dependency <varname>groupId</varname>,
      <varname>artifactId</varname>, and <varname>version</varname> to your
      project's dependencies. Once you do this, Maven 2 will download the
      dependency and make it available on your project's classpath.</para>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>Commons BeanUtils is a collection of utilities that makes working
      with beans and bean properties much easier. This project contains
      utilities that allow one to retrieve a bean property by name, sort beans
      by a property, translate beans to maps, and more. BeanUtils is simple
      and straightforward, and, as such, you will find that it is one of the
      most widely used and distributed libraries in open source Java. Along
      with Commons Lang and Commons Collections, Commons BeanUtils is part of
      the core of Apache Commons. Unless specified otherwise, every utility
      mentioned in this chapter is from Commons BeanUtils.</para>

      <sidebar id="beans-SIDEBAR-1">
        <title>In the Beginning...</title>

        <para>BeanUtils was originally a part of Jakarta Struts, a widely used
        <indexterm id="beans-ITERM-2128" significance="normal">
            <primary>Model-View-Controller (MVC)</primary>
          </indexterm> <indexterm id="beans-ITERM-2129" significance="normal">
            <primary>MVC (Model-View-Controller)</primary>
          </indexterm> <indexterm id="beans-ITERM-2130" significance="normal">
            <primary>form beans</primary>
          </indexterm> <indexterm id="beans-ITERM-2131" significance="normal">
            <primary>beans</primary>

            <secondary>form</secondary>
          </indexterm>Model-View-Controller (MVC) framework for web
        applications, which originated in the Jakarta project. The Struts
        framework hinges upon <filename moreinfo="none">form beans</filename>,
        which are used to present and communicate user input to and from a
        Struts action. The Struts <literal
        moreinfo="none">ActionServlet</literal> and the bean JavaServer Pages
        (JSP) tag libraries use the <literal
        moreinfo="none">BeanUtils</literal>, <literal
        moreinfo="none">PropertyUtils</literal>, and <literal
        moreinfo="none">ConvertUtils</literal> classes to populate and
        manipulate beans. Refactoring BeanUtils from Struts created new
        possibilities of reuse throughout the Jakarta project and the larger
        open source Java community.</para>
      </sidebar>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>To learn more about Commons BeanUtils, visit the Commons BeanUtils
      web site: <ulink
      url="http://commons.apache.org/beanutils/">http://commons.apache.org/beanutils/</ulink>.</para>
    </sect2>
  </sect1>

  <sect1 id="beans-sect-accessing-simple" label="3.4" role="Recipe">
    <title>Accessing Simple Bean Properties</title>

    <sect2>
      <title>Problem</title>

      <para>You need to access a simple <indexterm class="startofrange"
          id="beans-ITERM-2138" significance="normal">
          <primary>JavaBeans</primary>

          <secondary>properties</secondary>

          <tertiary>accessing</tertiary>
        </indexterm> <indexterm class="startofrange" id="beans-ITERM-2139"
          significance="normal">
          <primary>beans</primary>

          <secondary>properties</secondary>

          <tertiary>accessing</tertiary>
        </indexterm> <indexterm class="startofrange" id="beans-ITERM-2140"
          significance="normal">
          <primary>properties</primary>

          <secondary>beans</secondary>

          <tertiary>accessing</tertiary>
        </indexterm> <indexterm class="startofrange" id="beans-ITERM-2141"
          significance="normal">
          <primary>access</primary>

          <secondary>properties</secondary>

          <tertiary>beans</tertiary>
        </indexterm>bean property by name.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use <literal
      moreinfo="none">PropertyUtils.getSimpleProperty()</literal> <indexterm
          id="beans-ITERM-2142" significance="normal">
          <primary>PropertyUtils.getSimpleProperty( ) method</primary>
        </indexterm> <indexterm id="beans-ITERM-2143" significance="normal">
          <primary>methods</primary>

          <secondary>PropertyUtils.getSimpleProperty( )</secondary>
        </indexterm> to access a bean property by <indexterm
          id="beans-ITERM-2144" significance="normal">
          <primary>names</primary>

          <secondary>bean properties</secondary>
        </indexterm>name; this method takes the name of a property and returns
      the value of that property. The following example uses this method to
      retrieve the <literal moreinfo="none">name</literal> property from a
      <literal moreinfo="none">Person</literal> bean:</para>

      <programlisting format="linespecific" id="I_3_tt115">import org.apache.commons.beanutils.PropertyUtils;

Person person = new Person( );
person.setName( "Alex" );    

<userinput moreinfo="none">String name = (String) PropertyUtils.getSimpleProperty( person, "name" );</userinput>
System.out.println( name );</programlisting>

      <para><literal moreinfo="none">PropertyUtils.getSimpleProperty(
      )</literal> invokes the public method <literal moreinfo="none">getName(
      )</literal> <indexterm id="beans-ITERM-2145" significance="normal">
          <primary>getName( ) method</primary>
        </indexterm> <indexterm id="beans-ITERM-2146" significance="normal">
          <primary>methods</primary>

          <secondary>getName( )</secondary>
        </indexterm> on an instance of <literal
      moreinfo="none">Person</literal>, returning the value of the <literal
      moreinfo="none">name</literal> property. The previous example executes
      and prints out the name "Alex."</para>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>A simple bean property is a private member variable that can be
      accessed with a getter method. If a property can be read via a getter
      method, that getter method is said to be the<indexterm
          id="beans-ITERM-2147" significance="normal">
          <primary>read methods</primary>
        </indexterm> <filename moreinfo="none">read method</filename> for the
      named property. If the property can be modified with a setter method,
      that setter method is said to be the <filename moreinfo="none">write
      method </filename> <indexterm id="beans-ITERM-2148"
          significance="normal">
          <primary>write methods</primary>
        </indexterm>for the named property. The <literal
      moreinfo="none">Person</literal> bean in <link
      linkend="beans-ex-4">Example 3-4</link> defines two simple bean
      properties, <literal moreinfo="none">name</literal> and <literal
      moreinfo="none">favoriteColor</literal>.</para>

      <example id="beans-ex-4" label="3-4">
        <title>A Person bean with two simple properties</title>

        <programlisting format="linespecific">package com.discursive.jccook.bean;

public class Person {
    private String name;
    private String favoriteColor;

    public Person( ) {}

    public String getName( ) { return name; }
    public void setName(String name) { 
        this.name = name; 
    }

    public String getFavoriteColor( ) { return favoriteColor; }
    public void setFavoriteColor(String favoriteColor) { 
        this.favoriteColor = favoriteColor;
    }
}</programlisting>
      </example>

      <para>The class defined in <link linkend="beans-ex-4">Example 3-4</link>
      is used in the following sample code, which creates a <literal
      moreinfo="none">Person</literal> object, sets the <literal
      moreinfo="none">name</literal> and <literal
      moreinfo="none">favoriteColor</literal> properties, and demonstrates the
      use of <literal moreinfo="none">Property.getSimpleProperty( )</literal>
      to retrieve both properties by name:</para>

      <programlisting format="linespecific" id="I_3_tt116">import org.apache.commons.beanutils.PropertyUtils;

// Create a person
<userinput moreinfo="none">Person person = new Person( );</userinput>
               <userinput moreinfo="none">person.setName( "Alex Wolfe" );</userinput>
               <userinput moreinfo="none">person.setFavoriteColor( "Green" );</userinput>

try {
    <userinput moreinfo="none">String name = (String) PropertyUtils.getSimpleProperty( person, "name" );</userinput>
               <userinput moreinfo="none">    String favoriteColor =</userinput>
               <userinput moreinfo="none">        (String) PropertyUtils.getSimpleProperty( person, "favoriteColor" );</userinput>
    System.out.println( "The Person: " + name + " likes " + favoriteColor );
} catch (IllegalAccessException e) {
    System.out.println( "You are not allowed to access a property!" );
} catch (InvocationTargetException e) {
    System.out.println( "There was a problem invoking the method." );
} catch (NoSuchMethodException e) {
    System.out.println( "There is no method to get a property." );
}</programlisting>

      <para>Take note of the extensive exception handling required to retrieve
      two bean properties; three separate exceptions can be thrown by <literal
      moreinfo="none">getSimpleProperty( )</literal>. The first, <literal
      moreinfo="none">IllegalAccessException</literal>, is thrown if the
      getter method is not accessible (not public). <literal
      moreinfo="none">InvocationTargetException</literal> is thrown if the
      getter method throws an exception, and <literal
      moreinfo="none">NoSuchMethodException</literal> is thrown if you specify
      a bean property that does not exist on an object; for example,
      attempting to retrieve the <literal
      moreinfo="none">numberOfDoors</literal> property from the <literal
      moreinfo="none">person</literal> object above would throw a <literal
      moreinfo="none">NoSuchMethodException</literal> because there is no
      <literal moreinfo="none">getNumberOfDoors( )</literal> method.</para>

      <tip id="beans-NOTE-54" role="ora">
        <para>To simplify the examples in this chapter, most examples will
        omit the <literal moreinfo="none">try</literal>/<literal
        moreinfo="none">catch</literal> or catch the general <literal
        moreinfo="none">Exception</literal>—to do otherwise would be a
        needless waste of paper. As a general programming practice, catching
        the general <literal moreinfo="none">Exception</literal> should be
        avoided; well-written code usually catches individual, specific
        exceptions. But, in this case, catching the general <literal
        moreinfo="none">Exception</literal> may save you a great deal of
        hassle.</para>
      </tip>

      <para>Using <literal moreinfo="none">PropertyUtils.getSimpleProperty(
      )</literal> when you could simply call a get method might seem like an
      unwieldy solution to a very simple problem, but the alternative—calling
      a getter method—locks you into a specific bean property at compile time.
      This may be unacceptable if you are designing something generic like a
      templating system or an expression language interpreter; you may need to
      access an arbitrary property of an arbitrary object known only at
      runtime. The ability to retrieve the value of a bean property by name
      lies at the heart of a number of important tools, such as Struts, Apache
      Velocity, Commons JEXL, and utilities from Commons Collections.
      Accessing bean properties by name is an appropriate solution for a
      system that needs a high level of flexibility.</para>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>The next three recipes focus on accessing different types of bean
      properties: nested, indexed, and mapped. Simple properties may also be
      retrieved with <literal moreinfo="none">PropertyUtils.getProperty(
      )</literal>; this method is described in <link
      linkend="beans-sect-accessing-all">Recipe 3.8</link>.</para>

      <para>This recipe<indexterm class="endofrange" id="beans-ITERM-2149"
      significance="normal" startref="beans-ITERM-2138"></indexterm>
      <indexterm class="endofrange" id="beans-ITERM-2150"
      significance="normal" startref="beans-ITERM-2139"></indexterm>
      <indexterm class="endofrange" id="beans-ITERM-2151"
      significance="normal" startref="beans-ITERM-2140"></indexterm>
      <indexterm class="endofrange" id="beans-ITERM-2152"
      significance="normal" startref="beans-ITERM-2141"></indexterm> mentions
      Apache Struts, a web application MVC framework. For more information
      about the Struts project, see <ulink
      url="http://struts.apache.org">http://struts.apache.org/</ulink>. Apache
      Velocity and Commons JEXL are discussed in <link
      linkend="templating">Chapter 9</link>, and Commons Collections is
      discussed in <link linkend="collections">Chapter 5</link>.</para>
    </sect2>
  </sect1>

  <sect1 id="beans-sect-accessing-nested" label="3.5" role="Recipe">
    <title>Accessing Nested Bean Properties</title>

    <sect2>
      <title>Problem</title>

      <para>You need to access a nested <indexterm class="startofrange"
          id="beans-ITERM-2153" significance="normal">
          <primary>JavaBeans</primary>

          <secondary>properties</secondary>

          <tertiary>nested bean access</tertiary>
        </indexterm> <indexterm class="startofrange" id="beans-ITERM-2154"
          significance="normal">
          <primary>beans</primary>

          <secondary>properties</secondary>

          <tertiary>nested access</tertiary>
        </indexterm> <indexterm class="startofrange" id="beans-ITERM-2155"
          significance="normal">
          <primary>properties</primary>

          <secondary>beans</secondary>

          <tertiary>nested access</tertiary>
        </indexterm> <indexterm class="startofrange" id="beans-ITERM-2156"
          significance="normal">
          <primary>access</primary>

          <secondary>properties</secondary>

          <tertiary>nested beans</tertiary>
        </indexterm> <indexterm class="startofrange" id="beans-ITERM-2157"
          significance="normal">
          <primary>nested beans</primary>
        </indexterm>bean property.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use <literal
      moreinfo="none">PropertyUtils.getNestedProperty()</literal> <indexterm
          id="beans-ITERM-2158" significance="normal">
          <primary>PropertyUtils.getNestedProperty( ) method</primary>
        </indexterm> <indexterm id="beans-ITERM-2159" significance="normal">
          <primary>methods</primary>

          <secondary>PropertyUtils.getNestedProperty( )</secondary>
        </indexterm> to retrieve a nested bean property. Use a period as a
      delimiter to identify nested bean properties; <filename
      moreinfo="none">one.two.three.four</filename> refers to a property
      nested three levels deep—the <literal moreinfo="none">four</literal>
      property of the <literal moreinfo="none">three</literal> property of the
      <literal moreinfo="none">two</literal> property of the <literal
      moreinfo="none">one</literal> property. The following example accesses a
      nested bean property on a <literal moreinfo="none">Person</literal>
      bean, <filename moreinfo="none">author.name</filename>:</para>

      <programlisting format="linespecific" id="I_3_tt117">import org.apache.commons.beanutils.PropertyUtils;

Book book = new Book( );
book.setName( "Emerson's Essays" );

Person author = new Person( );
author.setName( "Ralph Waldo Emerson" );
book.setAuthor( author );

<userinput moreinfo="none">String authorName = (String) PropertyUtils.getNestedProperty(book, 
"author.name");</userinput>
System.out.println( "authorName" );This example retrieves the name 
property of the author property on the Book object, printing "Ralph 
Waldo Emerson".</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>The <literal moreinfo="none">author</literal> property of <literal
      moreinfo="none">Book</literal> is a <literal
      moreinfo="none">Person</literal> bean with a <literal
      moreinfo="none">name</literal> property; calling <literal
      moreinfo="none">getNestedProperty( )</literal> with <filename
      moreinfo="none">author.name</filename> retrieves the simple property
      <literal moreinfo="none">author</literal> from <literal
      moreinfo="none">Book</literal> and the property <literal
      moreinfo="none">name</literal>, which is nested in the <literal
      moreinfo="none">author</literal> property. <link
      linkend="beans-fig-3">Figure 3-3</link> shows the <literal
      moreinfo="none">Book</literal> and <literal
      moreinfo="none">Person</literal> beans that were used in the previous
      example.</para>

      <figure float="0" id="beans-fig-3" label="3-3">
        <title>Structure of two simple beans: Book and Person</title>

        <mediaobject id="I_3_tt118">
          <imageobject role="print">
            <imagedata depth="46" fileref="figs/print/jccb_0303.pdf"
                       format="PDF" width="193" />
          </imageobject>

          <imageobject role="web">
            <imagedata depth="46" fileref="figs/web/jccb_0303.png"
                       format="PNG" width="193" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>The following example demonstrates a combination of <literal
      moreinfo="none">getSimpleProperty( )</literal> and <literal
      moreinfo="none">getNestedProperty( )</literal>, retrieving a book name
      and an author name:</para>

      <programlisting format="linespecific" id="I_3_tt119">General Exception is caught.

import org.apache.commons.beanutils.PropertyUtils;

// Create an author
Person author = new Person( );
author.setName( "Chaucer" );

Book book = new Book( );
book.setName( "The Canterbury Tales" );
book.setAuthor( author );

try {
   <userinput moreinfo="none"> String bookName = (String) PropertyUtils.getSimpleProperty( book, "name" );</userinput>
               <userinput moreinfo="none">    String authorName = </userinput>
               <userinput moreinfo="none">        (String) PropertyUtils.getNestedProperty( book, "author.name" );</userinput>

    System.out.println( "The book is " + bookName );
    System.out.println( "The author is " + authorName );

} catch (Exception e) {
    System.out.println( "There was a problem getting a bean property." );
    e.printStackTrace( );
}</programlisting>

      <tip id="beans-NOTE-55" role="ora">
        <para>To reduce the size of the example code, only the general
        <literal moreinfo="none">Exception</literal> is caught.</para>
      </tip>

      <para>When using <literal moreinfo="none">getNestedProperty(
      )</literal>, there is no limit to the number of nesting levels for a
      property; demonstrating the retrieval of a deeply nested property, the
      following example retrieves the <literal moreinfo="none">name</literal>
      property from the <literal moreinfo="none">state</literal> property of
      the <literal moreinfo="none">address</literal> property of a <literal
      moreinfo="none">Person</literal> object:</para>

      <programlisting format="linespecific" id="I_3_tt120">String propertyName = "address.state.name";

<userinput moreinfo="none">String stateName =</userinput>
               <userinput moreinfo="none">    (String) PropertyUtils.getNestedProperty( person,  propertyName );</userinput>
            </programlisting>

      <para>This example assumes that the <literal
      moreinfo="none">Person</literal> class has a<indexterm
          id="beans-ITERM-2160" significance="normal">
          <primary>getAddress( ) method</primary>
        </indexterm> <indexterm id="beans-ITERM-2161" significance="normal">
          <primary>methods</primary>

          <secondary>getAddress( )</secondary>
        </indexterm> <literal moreinfo="none">getAddress( )</literal> method
      that returns an <literal moreinfo="none">Address</literal> object with a
      <literal moreinfo="none">getState( )</literal> <indexterm
          id="beans-ITERM-2162" significance="normal">
          <primary>getState( ) method</primary>
        </indexterm> <indexterm id="beans-ITERM-2163" significance="normal">
          <primary>methods</primary>

          <secondary>getState( )</secondary>
        </indexterm> method and returns a <literal
      moreinfo="none">State</literal> object with a <literal
      moreinfo="none">getName()</literal> <indexterm id="beans-ITERM-2164"
          significance="normal">
          <primary>getName( ) method</primary>
        </indexterm> <indexterm id="beans-ITERM-2165" significance="normal">
          <primary>methods</primary>

          <secondary>getName( )</secondary>
        </indexterm> method. The emphasized code in <indexterm
      class="endofrange" id="beans-ITERM-2166" significance="normal"
      startref="beans-ITERM-2153"></indexterm> <indexterm class="endofrange"
      id="beans-ITERM-2167" significance="normal"
      startref="beans-ITERM-2154"></indexterm> <indexterm class="endofrange"
      id="beans-ITERM-2168" significance="normal"
      startref="beans-ITERM-2155"></indexterm> <indexterm class="endofrange"
      id="beans-ITERM-2169" significance="normal"
      startref="beans-ITERM-2156"></indexterm> <indexterm class="endofrange"
      id="beans-ITERM-2170" significance="normal"
      startref="beans-ITERM-2157"></indexterm>the previous example is the
      equivalent of the following three lines of code:</para>

      <programlisting format="linespecific" id="I_3_tt121">Address address = person.getAddress( );
State state = address.getState( );
String stateName = state.getName( );</programlisting>
    </sect2>
  </sect1>

  <sect1 id="beans-sect-accessing-indexed" label="3.6" role="Recipe">
    <title>Accessing Indexed Bean Properties</title>

    <sect2>
      <title>Problem</title>

      <para>You need to access the nth <indexterm id="beans-ITERM-2171"
          significance="normal">
          <primary>JavaBeans</primary>

          <secondary>properties</secondary>

          <tertiary>indexed bean access</tertiary>
        </indexterm> <indexterm id="beans-ITERM-2172" significance="normal">
          <primary>beans</primary>

          <secondary>properties</secondary>

          <tertiary>indexed access</tertiary>
        </indexterm> <indexterm id="beans-ITERM-2173" significance="normal">
          <primary>properties</primary>

          <secondary>beans</secondary>

          <tertiary>indexed access</tertiary>
        </indexterm> <indexterm id="beans-ITERM-2174" significance="normal">
          <primary>access</primary>

          <secondary>properties</secondary>

          <tertiary>indexed beans</tertiary>
        </indexterm> <indexterm id="beans-ITERM-2175" significance="normal">
          <primary>indexes</primary>

          <secondary>bean properties</secondary>
        </indexterm>element of a bean property, which is an array or a
      <literal moreinfo="none">List</literal>.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use <literal moreinfo="none">PropertyUtils.getIndexed()</literal>
      <indexterm id="beans-ITERM-2176" significance="normal">
          <primary>PropertyUtils.getIndexed( ) method</primary>
        </indexterm> <indexterm id="beans-ITERM-2177" significance="normal">
          <primary>methods</primary>

          <secondary>PropertyUtils.getIndexed( )</secondary>
        </indexterm> to retrieve an element at a specific index of an array or
      a <literal moreinfo="none">List</literal> property. Assuming that the
      <literal moreinfo="none">chapters</literal> property of the <literal
      moreinfo="none">Book</literal> object is an instance of <literal
      moreinfo="none">List</literal>, the following demonstrates the use of
      <literal moreinfo="none">getIndexedProperty( )</literal> to access the
      first element of the list of chapters.</para>

      <programlisting format="linespecific" id="I_3_tt122">import org.apache.commons.beanutils.PropertyUtils;

// Create a new Book
Book book = new Book( );

// Create a list of Chapters
Chapter chapter1 = new Chapter( );
Chapter chapter2 = new Chapter( );
book.getChapters( ).add( chapter1 );
book.getChapters( ).add( chapter2 );

// Retrieve the first Chapter via a property name and an index.
<userinput moreinfo="none">Chapter chapter = </userinput>
               <userinput moreinfo="none">    (Chapter) PropertyUtils.getIndexedProperty(book, "chapters[0]");</userinput>
            </programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>There are two ways of accessing an indexed property via <literal
      moreinfo="none">PropertyUtils</literal>: the index can be specified in
      the name, or it can be specified as a third parameter. The following
      code uses both versions of <literal moreinfo="none">getIndexedProperty(
      )</literal> to retrieve the first chapter from the list of
      chapters:</para>

      <programlisting format="linespecific" id="I_3_tt123">import org.apache.commons.beanutils.PropertyUtils;

Book book = new Book( );

Chapter chapter1 = new Chapter( );
Chapter chapter2 = new Chapter( );
List chapters = new ArrayList( );
chapters.add( chapter1 );
chapters.add( chapter2 );

book.setChapters( chapters );

// You can retrieve the first chapters like this...
<userinput moreinfo="none">Chapter chapterOne = </userinput>
               <userinput moreinfo="none">    (Chapter) PropertyUtils.getIndexedProperty( book, "chapters[0]" );</userinput>

// Or... you can retrieve the first chapter like this...
<userinput moreinfo="none">chapterOne =</userinput>
               <userinput moreinfo="none">    (Chapter) PropertyUtils.getIndexedProperty( book, "chapters", 0 );</userinput>
            </programlisting>

      <para>In the previous example, the first version of <literal
      moreinfo="none">getIndexedProperty( )</literal> accepts a string
      specifying an indexed bean property—<literal
      moreinfo="none">chapters[0]</literal>. If this string is not
      well-formed, <literal moreinfo="none">PropertyUtils</literal> will throw
      an <literal moreinfo="none">IllegalArgumentException</literal>; <literal
      moreinfo="none">chapters[zero]</literal> and <literal
      moreinfo="none">chapters['zero']</literal> will cause an exception
      because neither index is an integer value, and <literal
      moreinfo="none">chapters]0[</literal> will cause an exception because
      the brackets are transposed. The second call to <literal
      moreinfo="none">getIndexedProperty( )</literal> is preferred because
      there is less risk that a parsing error will throw an <literal
      moreinfo="none">IllegalArgumentException</literal>.</para>
    </sect2>
  </sect1>

  <sect1 id="beans-sect-accessing-mapped" label="3.7" role="Recipe">
    <title>Accessing Mapped Bean Properties</title>

    <sect2>
      <title>Problem</title>

      <para>You need to retrieve values <indexterm class="startofrange"
          id="beans-ITERM-2178" significance="normal">
          <primary>JavaBeans</primary>

          <secondary>properties</secondary>

          <tertiary>mapped bean access</tertiary>
        </indexterm> <indexterm class="startofrange" id="beans-ITERM-2179"
          significance="normal">
          <primary>beans</primary>

          <secondary>properties</secondary>

          <tertiary>mapped access</tertiary>
        </indexterm> <indexterm class="startofrange" id="beans-ITERM-2180"
          significance="normal">
          <primary>properties</primary>

          <secondary>beans</secondary>

          <tertiary>mapped access</tertiary>
        </indexterm> <indexterm class="startofrange" id="beans-ITERM-2181"
          significance="normal">
          <primary>access</primary>

          <secondary>properties</secondary>

          <tertiary>mapped beans</tertiary>
        </indexterm> <indexterm class="startofrange" id="beans-ITERM-2182"
          significance="normal">
          <primary>mapping</primary>

          <secondary>bean property access</secondary>
        </indexterm>from a bean property of type <literal
      moreinfo="none">Map</literal>.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use <literal
      moreinfo="none">PropertyUtils.getMappedProperty()</literal> <indexterm
          id="beans-ITERM-2183" significance="normal">
          <primary>PropertyUtils.getMappedProperty( ) method</primary>
        </indexterm> <indexterm id="beans-ITERM-2184" significance="normal">
          <primary>methods</primary>

          <secondary>PropertyUtils.getMappedProperty( )</secondary>
        </indexterm> to obtain values from a map property. The code here
      retrieves the value corresponding to the key "Dining Room" from the
      <literal moreinfo="none">room</literal> <literal
      moreinfo="none">map</literal> property of the <literal
      moreinfo="none">Apartment</literal> bean:</para>

      <programlisting format="linespecific" id="I_3_tt124">import org.apache.commons.beanutils.PropertyUtils;

Room dining = new Room( );
dining.setArea( 20 );
dining.setCarpeted( true );
dining.setFurnished( true );

Map rooms = new HashMap( );
rooms.put( "Dining Room", dining );

Apartment apartment = new Apartment( );
apartment.setRooms( rooms );

<userinput moreinfo="none">// Retrieve the Dining Room object</userinput>
               <userinput moreinfo="none">Room room = </userinput>
               <userinput moreinfo="none">    PropertyUtils.getMappedProperty( apartment, "rooms(Dining Room)" );</userinput>
            </programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>The code shown in the Solution section retrieves the value from
      the <literal moreinfo="none">rooms</literal> <literal
      moreinfo="none">map</literal> corresponding to the key "Dining
      Room"—<literal moreinfo="none">rooms(Dining</literal> <literal
      moreinfo="none">Room)</literal>. The call to <literal
      moreinfo="none">getMappedProperty( )</literal> is the equivalent of
      calling <literal moreinfo="none">apartment.getRooms(
      ).get("Dining</literal> <literal moreinfo="none">Room")</literal>. <link
      linkend="beans-fig-4">Figure 3-4</link> illustrates the structure and
      relationship of these two beans used, <literal
      moreinfo="none">Apartment</literal> and <literal
      moreinfo="none">Room</literal>.</para>

      <figure float="0" id="beans-fig-4" label="3-4">
        <title>Diagram of the Apartment and Room beans</title>

        <mediaobject id="I_3_tt125">
          <imageobject role="print">
            <imagedata depth="60" fileref="figs/print/jccb_0304.pdf"
                       format="PDF" width="235" />
          </imageobject>

          <imageobject role="web">
            <imagedata depth="60" fileref="figs/web/jccb_0304.png"
                       format="PNG" width="235" />
          </imageobject>
        </mediaobject>
      </figure>

      <para><literal moreinfo="none">getMappedProperty( )</literal> works only
      if the specified <literal moreinfo="none">Map</literal> has <literal
      moreinfo="none">String</literal> keys. <literal
      moreinfo="none">getMappedProperty( )</literal> takes the string between
      <literal moreinfo="none">(</literal> and <literal
      moreinfo="none">)</literal> and retrieves the value corresponding to
      this string.</para>

      <para>There is another version of <literal
      moreinfo="none">PropertyUtils.getMappedProperty()</literal> that takes a
      third argument, allowing you to specify the map property in the second
      argument and the key in the third argument. The code here uses two
      different versions of <literal moreinfo="none">getMappedProperty(
      )</literal> to retrieve the same value from the <literal
      moreinfo="none">rooms</literal> <literal moreinfo="none">map</literal>
      property:</para>

      <programlisting format="linespecific" id="I_3_tt126">import java.util.Map;
import java.util.HashMap;
import org.apache.commons.beanutils.PropertyUtils;

Room dining = new Room( );
dining.setArea( 20 );
dining.setCarpeted( true );
dining.setFurnished( true );

Map rooms = new HashMap( );
rooms.put( "Dining Room", dining );

Apartment apartment = new Apartment( );
apartment.setRooms( rooms );

// Retrieve the livingRoom key
<userinput moreinfo="none">Room room = </userinput>
               <userinput moreinfo="none">    (Room) PropertyUtils.getMappedProperty( apartment, 
     "rooms(Dining Room)" );</userinput>

// Or.. retrieve the livingRoom key with 3 parameters - 
// equivalent to previous
room = 
   <userinput moreinfo="none"> (Room) PropertyUtils.getMappedProperty( apartment, "rooms", 
   "Dining Room" ); </userinput>
            </programlisting>

      <para>What was true for <literal moreinfo="none">getIndexedProperty(
      )</literal> is also true for <literal moreinfo="none">getMappedProperty(
      )</literal>. In the previous example, the first call to <literal
      moreinfo="none">getMappedProperty( )</literal> specifies a key with a
      string—<literal moreinfo="none">rooms(Dining Room)</literal>. If
      <literal moreinfo="none">getMappedProperty( )</literal> is unable to
      parse this string, an <literal
      moreinfo="none">IllegalArgumentException</literal> will be thrown;
      <literal moreinfo="none">rooms[DiningRoom)</literal> and <literal
      moreinfo="none">rooms((DiningRoom)</literal> will both throw <literal
      moreinfo="none">IllegalArgumentException</literal> because the property
      string is not well-formed. The second call to <literal
      moreinfo="none">getMappedProperty( )</literal> reduces the risk of a
      property string parsing error because the key <indexterm
      class="endofrange" id="beans-ITERM-2185" significance="normal"
      startref="beans-ITERM-2178"></indexterm> <indexterm class="endofrange"
      id="beans-ITERM-2186" significance="normal"
      startref="beans-ITERM-2179"></indexterm> <indexterm class="endofrange"
      id="beans-ITERM-2187" significance="normal"
      startref="beans-ITERM-2180"></indexterm> <indexterm class="endofrange"
      id="beans-ITERM-2188" significance="normal"
      startref="beans-ITERM-2181"></indexterm> <indexterm class="endofrange"
      id="beans-ITERM-2189" significance="normal"
      startref="beans-ITERM-2182"></indexterm>is specified in a third
      parameter.</para>
    </sect2>
  </sect1>

  <sect1 id="beans-sect-accessing-all" label="3.8" role="Recipe">
    <title>Accessing a Simple, Nested, Indexed, and Mapped Bean
    Property</title>

    <sect2>
      <title>Problem</title>

      <para>You need to access a nested,<indexterm class="startofrange"
          id="beans-ITERM-2190" significance="normal">
          <primary>JavaBeans</primary>

          <secondary>properties</secondary>

          <tertiary>accessing</tertiary>
        </indexterm> <indexterm class="startofrange" id="beans-ITERM-2191"
          significance="normal">
          <primary>beans</primary>

          <secondary>properties</secondary>

          <tertiary>accessing</tertiary>
        </indexterm> <indexterm class="startofrange" id="beans-ITERM-2192"
          significance="normal">
          <primary>properties</primary>

          <secondary>beans</secondary>

          <tertiary>accessing</tertiary>
        </indexterm> <indexterm class="startofrange" id="beans-ITERM-2193"
          significance="normal">
          <primary>access</primary>

          <secondary>properties</secondary>

          <tertiary>beans</tertiary>
        </indexterm> indexed, and mapped bean property by name.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use <literal moreinfo="none">PropertyUtils.getProperty()</literal>
      <indexterm id="beans-ITERM-2194" significance="normal">
          <primary>PropertyUtils.getProperty( ) method</primary>
        </indexterm> <indexterm id="beans-ITERM-2195" significance="normal">
          <primary>methods</primary>

          <secondary>PropertyUtils.getProperty( )</secondary>
        </indexterm> to access any bean property. This single utility can be
      used to access any bean property be it simple, nested, indexed, mapped,
      or any combination thereof. The following example accesses a simple
      property, <literal moreinfo="none">population</literal>, of a nested
      mapped property, <literal moreinfo="none">cities</literal>, on an
      indexed property, <literal moreinfo="none">regions</literal>:</para>

      <programlisting format="linespecific" id="I_3_tt127">import java.util.*;
import org.apache.commons.beanutils.PropertyUtils;

// Create a series of nested beans
City richmond = new City( );
richmond.setName( "Richmond" );
richmond.setPopulation( new Long(500000) );

Map cities = new HashMap( );
cities.put( "richmond", richmond );

Region midAtlantic = new Region( );
midAtlantic.setName( "Mid-Atlantic" );
midAtlantic.setCities( cities );

List regions = new ArrayList( );
regions.add( midAtlantic );

Country country = new Country( );
country.setName( "United States" );
country.setRegions( regions );

// Retrieve the population of Richmond
<userinput moreinfo="none">Long population =</userinput>
               <userinput moreinfo="none">    (Long) PropertyUtils.getProperty( country, </userinput>
               <userinput moreinfo="none">                                "regions[0].cities(richmond).population" );</userinput>
            </programlisting>

      <para>Most of this code sets up a complex nested object hierarchy to be
      queried by <literal moreinfo="none">PropertyUtils.getProperty(
      )</literal>. Retrieving the <literal
      moreinfo="none">regions[0].cities(richmond).population</literal>
      property is the equivalent of traversing down a tree of objects and
      retrieving the bottom-most element—<literal
      moreinfo="none">population</literal>.</para>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>The emphasized code retrieves the <literal
      moreinfo="none">population</literal> of the <literal
      moreinfo="none">City</literal> object <literal
      moreinfo="none">richmond</literal>; it is equivalent to the following
      code excerpt:</para>

      <programlisting format="linespecific" id="I_3_tt128">Region region = (Region) country.getRegions( ).get(0);
City city = (City) region.getCities( ).get("Richmond");
Long population = city.getPopulation( );</programlisting>

      <para><link linkend="beans-fig-5">Figure 3-5</link> displays the
      structure of these three beans: <literal
      moreinfo="none">Country</literal>, <literal
      moreinfo="none">Region</literal>, and <literal
      moreinfo="none">City</literal>.</para>

      <figure float="0" id="beans-fig-5" label="3-5">
        <title>The Country, Region, and City beans</title>

        <mediaobject id="I_3_tt129">
          <imageobject role="print">
            <imagedata depth="46" fileref="figs/print/jccb_0305.pdf"
                       format="PDF" width="334" />
          </imageobject>

          <imageobject role="web">
            <imagedata depth="46" fileref="figs/web/jccb_0305.png"
                       format="PNG" width="334" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>When accessing a bean property, you can use <literal
      moreinfo="none">PropertyUtils.getProperty( )</literal> in lieu of the
      methods introduced in the previous four recipes. The <literal
      moreinfo="none">getProperty( )</literal> method parses the supplied
      property name, splitting the name as the period character. Once this
      property has been split, this utility parses each token and passes the
      string to the appropriate method—<literal
      moreinfo="none">getSimpleProperty()</literal>, <literal
      moreinfo="none">getNestedProperty( )</literal>, <literal
      moreinfo="none">getIndexedProperty( )</literal>, or <literal
      moreinfo="none">getMappedProperty( )</literal>.</para>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>Bean properties may also be retrieved using a simple expression
      language, such as <indexterm id="beans-ITERM-2196" significance="normal">
          <primary>Expression Language (EL)</primary>
        </indexterm> <indexterm id="beans-ITERM-2197" significance="normal">
          <primary>EL (Expression Language)</primary>
        </indexterm>Expression Language (EL) or <indexterm
          id="beans-ITERM-2198" significance="normal">
          <primary>Java Expression Language (JEXL)</primary>
        </indexterm> <indexterm id="beans-ITERM-2199" significance="normal">
          <primary>JEXL (Java Expression Language)</primary>
        </indexterm>Java Expression Language (JEXL). For more information
      about retrieving bean properties using an expression language, see <link
      linkend="searching-filtering-sect-obtaining-jxpath">Recipe
      12.1</link>.</para>

      <para>Bean properties may also be<indexterm class="endofrange"
      id="beans-ITERM-2200" significance="normal"
      startref="beans-ITERM-2190"></indexterm> <indexterm class="endofrange"
      id="beans-ITERM-2201" significance="normal"
      startref="beans-ITERM-2191"></indexterm> <indexterm class="endofrange"
      id="beans-ITERM-2202" significance="normal"
      startref="beans-ITERM-2192"></indexterm> <indexterm class="endofrange"
      id="beans-ITERM-2203" significance="normal"
      startref="beans-ITERM-2193"></indexterm> retrieved using an XPath
      expression. For more information, see <link
      linkend="searching-filtering-sect-obtaining-jxpath">Recipe
      12.1</link>.</para>
    </sect2>
  </sect1>

  <sect1 id="beans-sect-determine-type" label="3.9" role="Recipe">
    <title>Determining the Type of a Bean Property</title>

    <sect2>
      <title>Problem</title>

      <para>You need to determine <indexterm id="beans-ITERM-2204"
          significance="normal">
          <primary>JavaBeans</primary>

          <secondary>properties</secondary>

          <tertiary>types of</tertiary>
        </indexterm> <indexterm id="beans-ITERM-2205" significance="normal">
          <primary>beans</primary>

          <secondary>properties</secondary>

          <tertiary>types of</tertiary>
        </indexterm> <indexterm id="beans-ITERM-2206" significance="normal">
          <primary>properties</primary>

          <secondary>beans</secondary>

          <tertiary>types of</tertiary>
        </indexterm> <indexterm id="beans-ITERM-2207" significance="normal">
          <primary>types of bean properties</primary>
        </indexterm>the type of a bean property.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use <literal moreinfo="none">PropertyUtils.getPropertyType(
      )</literal> to determine the type of a bean property. This utility will
      return a <literal moreinfo="none">Class</literal> object that represents
      the return type of the property's getter method. The following example
      uses this method to obtain the return type for the <literal
      moreinfo="none">author</literal> property on the <literal
      moreinfo="none">Book</literal> bean:</para>

      <programlisting format="linespecific" id="I_3_tt130">import org.apache.commons.beanutils.PropertyUtils

Book book = new Book( );

Class type = PropertyUtils.getPropertyType( book, "author" );

System.out.println( "book.author type: " + type.getName( ) );</programlisting>

      <para>This example retrieves and displays the type of the <literal
      moreinfo="none">author</literal> property on <literal
      moreinfo="none">Book</literal>, which happens to be a <literal
      moreinfo="none">Person</literal> object. The type of the property is
      returned and printed to the console:</para>

      <programlisting format="linespecific" id="I_3_tt131">book.author type: org.test.Person</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para><literal moreinfo="none">PropertyUtils.getPropertyType()</literal>
      <indexterm id="beans-ITERM-2208" significance="normal">
          <primary>PropertyUtils.getPropertyType( ) method</primary>
        </indexterm> <indexterm id="beans-ITERM-2209" significance="normal">
          <primary>methods</primary>

          <secondary>PropertyUtils.getProperty( )</secondary>
        </indexterm> also works for a complex bean property. Passing a nested,
      indexed, or mapped bean property to this utility will return the type of
      the last property specified. The following code retrieves the type of a
      nested, indexed property—<literal
      moreinfo="none">chapters[0].name</literal>:</para>

      <programlisting format="linespecific" id="I_3_tt132">import org.apache.commons.beanutils.PropertyUtils;

Chapter chapter = new Chapter( );
chapter.setName( "Chapter 3 BeanUtils" );
chapter.setLength( new Integer(40) );

List chapters = new ArrayList( );
chapters.add( chapter );

Book book = new Book( );
book.setName( "Common Java Cookbook" );
book.setAuthor( "Dude" );
book.setChapters( chapters );

<userinput moreinfo="none">String property = "chapters[0].name";</userinput>
               <userinput moreinfo="none">Class propertyType = PropertyUtils.getPropertyType(book, property);</userinput>

System.out.println( property + " type: " + propertyType.getName( ) );</programlisting>

      <para>This code retrieves the type of the <literal
      moreinfo="none">name</literal> property from an instance of the <literal
      moreinfo="none">Chapter</literal> retrieved as an indexed property, and
      it prints the following output:</para>

      <programlisting format="linespecific" id="I_3_tt133">chapters[0].name type: java.lang.String</programlisting>

      <para><literal moreinfo="none">PropertyUtils</literal> contains another
      method to retrieve a <literal moreinfo="none">PropertyDescriptor--
      PropertyUtils.getPropertyDescriptor( )</literal>. This method takes a
      reference to any bean property, simple or complex, and returns an object
      describing the type of a property and providing access to the read and
      write methods of a property. The following code excerpt obtains the
      <literal moreinfo="none">PropertyDescriptor</literal> of a nested,
      indexed property—<literal
      moreinfo="none">chapters[0].name</literal>:</para>

      <programlisting format="linespecific" id="I_3_tt134">String property = "chapters[0].name";

PropertyDescriptor descriptor = 
    PropertyUtils.getPropertyDescriptor(book, property);

Class propertyType = descriptor.getPropertyType( ); 
Method writeMethod = descriptor.getWriteMethod( );
Method readMethod = descriptor.getReadMethod( );</programlisting>
    </sect2>
  </sect1>

  <sect1 id="beans-sect-comparing" label="3.10" role="Recipe">
    <title>Comparing Beans</title>

    <sect2>
      <title>Problem</title>

      <para>You need to sort <indexterm class="startofrange"
          id="beans-ITERM-2210" significance="normal">
          <primary>JavaBeans</primary>

          <secondary>properties</secondary>

          <tertiary>comparing</tertiary>
        </indexterm> <indexterm class="startofrange" id="beans-ITERM-2211"
          significance="normal">
          <primary>beans</primary>

          <secondary>properties</secondary>

          <tertiary>comparing</tertiary>
        </indexterm> <indexterm class="startofrange" id="beans-ITERM-2212"
          significance="normal">
          <primary>properties</primary>

          <secondary>beans</secondary>

          <tertiary>comparing</tertiary>
        </indexterm> <indexterm class="startofrange" id="beans-ITERM-2213"
          significance="normal">
          <primary>comparing</primary>

          <secondary>beans</secondary>
        </indexterm> <indexterm class="startofrange" id="beans-ITERM-2214"
          significance="normal">
          <primary>sorting</primary>

          <secondary>bean properties</secondary>
        </indexterm>or compare beans by a bean property.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use <literal moreinfo="none">BeanComparator</literal> <indexterm
          id="beans-ITERM-2215" significance="normal">
          <primary>BeanComparator</primary>
        </indexterm> to compare two beans using a bean property, which can be
      simple, nested, indexed, or mapped. <literal
      moreinfo="none">BeanComparator</literal> obtains the value of the same
      bean property from two objects and, by default, compares the properties
      with a <literal moreinfo="none">ComparableComparator</literal>. The
      following example sorts a list of <literal
      moreinfo="none">Country</literal> objects using a <literal
      moreinfo="none">BeanComparator</literal> and the default <literal
      moreinfo="none">ComparableComparator</literal>:</para>

      <programlisting format="linespecific" id="I_3_tt135">import java.util.*;
import org.apache.commons.beanutils.BeanComparator;

Country country1 = new Country( );
country1.setName( "India" );

Country country2 = new Country( );
country2.setName( "Pakistan" );

Country country3 = new Country( );
country3.setName( "Afghanistan" );

// Create a List of Country objects
Country[] countryArray = new Country[] { country1, country2, country3 };
List countryList = Arrays.asList( countryArray );

<userinput moreinfo="none">// Sort countries by name</userinput>
               <userinput moreinfo="none">Comparator nameCompare = new BeanComparator( "name" );</userinput>
               <userinput moreinfo="none">Collections.sort( countryList, nameCompare );</userinput>

System.out.println( "Sorted Countries:" );
Iterator countryIterator = countryList.iterator( );
while( countryIterator.hasNext( ) ) {
    Country country = (Country) countryIterator.next( );
    System.out.println( "\tCountry: " + country.getName( ) );
}</programlisting>

      <para>This code creates three <literal moreinfo="none">Country</literal>
      objects with different names, places the <literal
      moreinfo="none">Country</literal> objects into a list, and sorts this
      list with a <literal moreinfo="none">BeanComparator</literal> configured
      to compare by the bean property <literal moreinfo="none">name</literal>.
      This code executes and prints the sorted list of countries:</para>

      <programlisting format="linespecific" id="I_3_tt136">Sorted Countries:
    Country: Afghanistan
    Country: India
    Country: Pakistan</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>The previous example demonstrated the default behavior of <literal
      moreinfo="none">BeanComparator</literal>; when a <literal
      moreinfo="none">BeanComparator</literal> is constructed with only one
      parameter, it uses a <literal
      moreinfo="none">ComparableComparator</literal> to compare the values of
      the properties it retrieves. You can also construct a <literal
      moreinfo="none">BeanComparator</literal> with an instance of <literal
      moreinfo="none">Comparator</literal>; in this case, <literal
      moreinfo="none">BeanComparator</literal> decorates another <literal
      moreinfo="none">Comparator</literal>, retrieving the values of a
      property and passing these values on to an instance of <literal
      moreinfo="none">Comparator</literal>. The following example demonstrates
      the use of <literal moreinfo="none">BeanComparator</literal> with a
      custom <literal moreinfo="none">Comparator</literal> implementation.
      This example involves two objects shown in <link
      linkend="beans-fig-6">Figure 3-6</link>: <literal
      moreinfo="none">ElectricVehicle</literal> and <literal
      moreinfo="none">Engine</literal>.</para>

      <figure float="0" id="beans-fig-6" label="3-6">
        <title>Objects involved in a sorting example</title>

        <mediaobject id="I_3_tt137">
          <imageobject role="print">
            <imagedata depth="88" fileref="figs/print/jccb_0306.pdf"
                       format="PDF" width="223" />
          </imageobject>

          <imageobject role="web">
            <imagedata depth="88" fileref="figs/web/jccb_0306.png"
                       format="PNG" width="223" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>An application needs to sort <literal
      moreinfo="none">ElectricVehicle</literal> objects by efficiency, and, in
      this contrived example, efficiency is defined as the number of miles per
      gallon times the percentage of electric operation; an 80% electric
      hybrid vehicle is more efficient than a 25% electric hybrid vehicle with
      the same mileage because of reduced emissions. The code fragments shown
      in <link linkend="beans-ex-5">Example 3-5</link> sort a collection of
      beans by wrapping a custom <literal moreinfo="none">Comparator</literal>
      with a <literal moreinfo="none">BeanComparator</literal>.</para>

      <example id="beans-ex-5" label="3-5">
        <title>Decorating a Comparator with a BeanComparator</title>

        <programlisting format="linespecific">import java.util.*;
import org.apache.commons.beanutils.BeanComparator;

// Create Engines
Engine engine1 = new Engine( );
engine1.setMilesGallon( new Integer(60) );
engine1.setPercentElectric( new Integer(50) );

Engine engine2 = new Engine( );
engine2.setMilesGallon( new Integer(90) );
engine2.setPercentElectric( new Integer(50) );

Engine engine3 = new Engine( );
engine3.setMilesGallon( new Integer(65) );
engine3.setPercentElectric( new Integer(45) );

// Create Vehicles
ElectricVehicle vehicle1 = new ElectricVehicle( );
vehicle1.setMake( "Toy Yoda" );
vehicle1.setModel( "Electro" );
vehicle1.setYear( 2005 );
vehicle1.setEngine( engine1 );

ElectricVehicle vehicle2 = new ElectricVehicle( );
vehicle2.setMake( "Fjord" );
vehicle2.setModel( "Photon" );
vehicle2.setYear( 2004 );
vehicle2.setEngine( engine2 );

ElectricVehicle vehicle3 = new ElectricVehicle( );
vehicle3.setMake( "Ford" );
vehicle3.setModel( "Electric Pinto" );
vehicle3.setYear( 2005 );
vehicle3.setEngine( engine3 );

// Create List of Vehicles
List vehicles = new ArrayList( );
vehicle.add( vehicle1 );
vehicle.add( vehicle2 );
vehicle.add( vehicle3 );

// Define Engine Comparison Logic in an Anonymous inner class
// which implements the Comparator interface
Comparator engineCompare = new Comparator( ) {
    public int compare(Object o1, Object o2) {
        Engine engine1 = (Engine) o1;
        Engine engine2 = (Engine) o2;

        int engine1Temp = engine1.getMilesGallon( ).intValue( ) *
                        engine1.getPercentElectric( ).intValue( );
        int engine2Temp = engine2.getMilesGallon( ).intValue( ) *
                        engine2.getPercentElectric( ).intValue( );

        Integer engine1Factor = new Integer( engine1Temp );
        Integer engine2Factor = new Integer( engine2Temp );

        return engine1Factor.compareTo( engine2Factor );
    }
}

<userinput moreinfo="none">Comparator vehicleCompare = new BeanComparator( "engine", engineCompare );</userinput>
                  <userinput moreinfo="none">Collections.sort( vehicles, vehicleCompare );</userinput>

// Print Sorted Results
System.out.println( "Vehicles Sorted by Efficiency:" );
Iterator vehicleIter = vehicles.iterator( );
while( vehicleIter.hasNext( ) ) {
    ElectricVehicle vehicle = (ElectricVehicle) vehicleIter.next( );
    System.out.println( "\tVehicle: " + vehicle.getModel( ) + ", " +
        vehicle.getEngine( ).getMilesGallon( ) + " MPG, " + 
        vehicle.getEngine( ).getPercentElectric( ) + "% Electric" );
}</programlisting>
      </example>

      <para><literal moreinfo="none">engineCompare</literal> contains the
      logic used to sort vehicles by efficiency, and <literal
      moreinfo="none">BeanComparator</literal> supplies the <literal
      moreinfo="none">engine</literal> properties to this <literal
      moreinfo="none">Comparator</literal> implementation. This previous
      example creates three vehicles and sorts the vehicles in order of
      efficiency; the following results are printed:</para>

      <programlisting format="linespecific" id="I_3_tt138">Vehicles Sorted by Efficiency:
    Vehicle: Photon, 90 MPG, 50% Electric
    Vehicle: Electro, 60 MPG, 50% Electric
    Vehicle: Electric Pinto, 65 MPG, 45% Electric</programlisting>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para><link linkend="functors">Chapter 4</link> provides examples of
      various <literal moreinfo="none">Comparator</literal> implementations,
      which can be used to decorate other comparators. One <literal
      moreinfo="none">Comparator</literal> in particular is important if you
      plan to sort beans on a bean property, which could be <literal
      moreinfo="none">null</literal>. If a bean property could be <literal
      moreinfo="none">null</literal>, make sure to pass a <literal
      moreinfo="none">NullComparator</literal> to <literal
      moreinfo="none">BeanComparator</literal>; otherwise, <literal
      moreinfo="none">ComparableComparator</literal> will throw a <literal
      moreinfo="none">NullPointerException</literal> if a property value is
      <literal moreinfo="none">null</literal>. <link
      linkend="functors-sect-comparing-nulls">Recipe 4.5</link> discusses
      techniques for decorating a <literal
      moreinfo="none">Comparator</literal> with <literal
      moreinfo="none">NullComparator</literal>.</para>

      <para><link linkend="beans-sect-validating-predicate">Recipe 3.15</link>
      discusses a <literal moreinfo="none">BeanPredicate</literal> <indexterm
          id="beans-ITERM-2216" significance="normal">
          <primary>BeanPredicate object</primary>
        </indexterm> <indexterm id="beans-ITERM-2217" significance="normal">
          <primary>objects</primary>

          <secondary>BeanPredicate</secondary>
        </indexterm> object that can be used to validate beans. The <literal
      moreinfo="none">BeanPredicate</literal> is similar to the <literal
      moreinfo="none">BeanComparator</literal> as it decorates another
      instance of <literal moreinfo="none">Predicate</literal>, providing
      access to a<indexterm class="endofrange" id="beans-ITERM-2218"
      significance="normal" startref="beans-ITERM-2210"></indexterm>
      <indexterm class="endofrange" id="beans-ITERM-2219"
      significance="normal" startref="beans-ITERM-2211"></indexterm>
      <indexterm class="endofrange" id="beans-ITERM-2220"
      significance="normal" startref="beans-ITERM-2212"></indexterm>
      <indexterm class="endofrange" id="beans-ITERM-2221"
      significance="normal" startref="beans-ITERM-2213"></indexterm>
      <indexterm class="endofrange" id="beans-ITERM-2222"
      significance="normal" startref="beans-ITERM-2214"></indexterm> bean
      property.</para>
    </sect2>
  </sect1>

  <sect1 id="beans-sect-copying" label="3.11" role="Recipe">
    <title>Copying Bean Properties</title>

    <sect2>
      <title>Problem</title>

      <para>You have two instances of a <indexterm id="beans-ITERM-2223"
          significance="normal">
          <primary>JavaBeans</primary>

          <secondary>properties</secondary>

          <tertiary>copying</tertiary>
        </indexterm> <indexterm id="beans-ITERM-2224" significance="normal">
          <primary>beans</primary>

          <secondary>properties</secondary>

          <tertiary>copying</tertiary>
        </indexterm> <indexterm id="beans-ITERM-2225" significance="normal">
          <primary>properties</primary>

          <secondary>beans</secondary>

          <tertiary>copying</tertiary>
        </indexterm> <indexterm id="beans-ITERM-2226" significance="normal">
          <primary>copying</primary>

          <secondary>bean properties</secondary>
        </indexterm> <indexterm id="beans-ITERM-2227" significance="normal">
          <primary>instances</primary>

          <secondary>beans</secondary>

          <tertiary>copying properties</tertiary>
        </indexterm>bean, and you need to copy the properties of one bean to
      another instance of the same class.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use <literal
      moreinfo="none">PropertyUtils.copyProperties()</literal> <indexterm
          id="beans-ITERM-2228" significance="normal">
          <primary>PropertyUtils.copyProperties( ) method</primary>
        </indexterm> <indexterm id="beans-ITERM-2229" significance="normal">
          <primary>methods</primary>

          <secondary>PropertyUtils.copyProperties( )</secondary>
        </indexterm> to copy the properties from one bean to another. The
      first parameter is the destination bean, and the second parameter is the
      bean to copy properties from:</para>

      <programlisting format="linespecific" id="I_3_tt139">import org.apache.commons.beanutils.PropertyUtils;

Book book = new Book( );
book.setName( "Prelude to Foundation" );
book.setAuthorName( "Asimov" );

Book destinationBook = new Book( );

PropertyUtils.copyProperties( destinationBook, book );</programlisting>

      <para>After executing this code, <literal
      moreinfo="none">destinationBook.getName()</literal> should return
      "Prelude to Foundation," and <literal
      moreinfo="none">destinationBook.getAuthorName( )</literal> should return
      "Asimov"; the <literal moreinfo="none">name</literal> and <literal
      moreinfo="none">authorName</literal> properties of <literal
      moreinfo="none">book</literal> were both copied to <literal
      moreinfo="none">destinationBook</literal>.</para>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para><literal moreinfo="none">PropertyUtils.copyProperties( )</literal>
      retrieves the values of all properties from a source instance of a bean,
      assigning the retrieved values to a matching property on a destination
      instance. If the <literal moreinfo="none">Book</literal> bean in the
      previous example had an <literal moreinfo="none">author</literal>
      property of type <literal moreinfo="none">Author</literal>, <literal
      moreinfo="none">copyProperties( )</literal> would have assigned the same
      reference object to the <literal
      moreinfo="none">destinationBook</literal>. In other words, <literal
      moreinfo="none">copyProperties( )</literal> does
      <emphasis>not</emphasis> clone the values of the bean properties. The
      following example demonstrates this explicitly:</para>

      <programlisting format="linespecific" id="I_3_tt140">Author author = new Author( );
author.setName( "Zinsser" );

Book book = new Book( );
book.setName( "On Writing Well" );
book.setAuthor( author );

Book destinationBook = new Book( );

PropertyUtils.copyProperties( destinationBook, book );

// At this point book and destinationBook have the same author object
if( book.getAuthor( ) == destinationBook.getAuthor( ) ) {
    system.out.println( "Author objects identical" );
}</programlisting>

      <para>The <literal moreinfo="none">author</literal> properties of these
      two objects are now identical references to the same instance of the
      <literal moreinfo="none">Author</literal> class. <literal
      moreinfo="none">copyProperties( )</literal> does not clone the values of
      bean properties.</para>

      <para><literal moreinfo="none">copyProperties( )</literal> can also copy
      the contents of a <literal moreinfo="none">Map</literal> to a bean if
      the keys of a <literal moreinfo="none">Map</literal> correspond to names
      of simple bean properties on the destination bean:</para>

      <programlisting format="linespecific" id="I_3_tt141">Map mapProps = new HashMap( );
mapProps.put( "name", "The Art of Computer Programming" );
mapProps.put( "author", "Knuth" );

Book destinationBook = new Book( );

PropertyUtils.copyProperties( destinationBook, mapProps );</programlisting>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>If you need to clone a bean, take a look at <link
      linkend="beans-sect-cloning">Recipe 3.12</link></para>
    </sect2>
  </sect1>

  <sect1 id="beans-sect-cloning" label="3.12" role="Recipe">
    <title>Cloning a Bean</title>

    <sect2>
      <title>Problem</title>

      <para>You need to clone a bean.<indexterm id="beans-ITERM-2230"
          significance="normal">
          <primary>JavaBeans</primary>

          <secondary>properties</secondary>

          <tertiary>cloning</tertiary>
        </indexterm> <indexterm id="beans-ITERM-2231" significance="normal">
          <primary>beans</primary>

          <secondary>properties</secondary>

          <tertiary>cloning</tertiary>
        </indexterm> <indexterm id="beans-ITERM-2232" significance="normal">
          <primary>properties</primary>

          <secondary>beans</secondary>

          <tertiary>cloning</tertiary>
        </indexterm> <indexterm id="beans-ITERM-2233" significance="normal">
          <primary>cloning</primary>

          <secondary>properties</secondary>
        </indexterm> <indexterm id="beans-ITERM-2234" significance="normal">
          <primary>instances</primary>

          <secondary>beans</secondary>

          <tertiary>cloning properties</tertiary>
        </indexterm></para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use <literal moreinfo="none">BeanUtils.cloneBean()</literal>
      <indexterm id="beans-ITERM-2235" significance="normal">
          <primary>BeanUtils.cloneBean( ) method</primary>
        </indexterm> <indexterm id="beans-ITERM-2236" significance="normal">
          <primary>methods</primary>

          <secondary>BeanUtils.cloneBean( )</secondary>
        </indexterm>. This method creates a new instance of a bean with the
      default constructor, and it copies every property to the new bean
      instance. The following instance creates a cloned instance of a <literal
      moreinfo="none">Book</literal> object:</para>

      <programlisting format="linespecific" id="I_3_tt142">import org.apache.commons.beanutils.BeanUtils;

Book book1 = new Book( );
book1.setName( "Count of Monte Cristo" );

<userinput moreinfo="none">Book book2 = (Book) BeanUtils.cloneBean( book1 );</userinput>
            </programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para><literal moreinfo="none">cloneBean( )</literal> instantiates a new
      instance of the bean to be cloned and calls <literal
      moreinfo="none">BeanUtils.copyProperties( )</literal> to transfer all
      readable bean properties to the newly instantiated bean. The following
      code demonstrates the steps that <literal moreinfo="none">cloneBean(
      )</literal> is taking to clone an instance of a bean:</para>

      <programlisting format="linespecific" id="I_3_tt143">Book book1 = new Book( );
book1.setName( "Practical C Programming" );

<userinput moreinfo="none">Book book2 = book1.getClass( ).newInstance( );</userinput>
               <userinput moreinfo="none">PropertyUtils.copyProperties( book2, book1 );</userinput>
            </programlisting>
    </sect2>
  </sect1>

  <sect1 id="beans-sect-setting-property" label="3.13" role="Recipe">
    <title>Setting a Bean Property</title>

    <sect2>
      <title>Problem</title>

      <para>You need to set a simple, indexed, nested, or <indexterm
          id="beans-ITERM-2237" significance="normal">
          <primary>JavaBeans</primary>

          <secondary>properties</secondary>

          <tertiary>setting</tertiary>
        </indexterm> <indexterm id="beans-ITERM-2238" significance="normal">
          <primary>beans</primary>

          <secondary>properties</secondary>

          <tertiary>setting</tertiary>
        </indexterm> <indexterm id="beans-ITERM-2239" significance="normal">
          <primary>properties</primary>

          <secondary>beans</secondary>

          <tertiary>setting</tertiary>
        </indexterm> <indexterm id="beans-ITERM-2240" significance="normal">
          <primary>setting bean properties</primary>
        </indexterm> <indexterm id="beans-ITERM-2241" significance="normal">
          <primary>configuration</primary>

          <secondary>bean properties</secondary>
        </indexterm>mapped bean property by name.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use <literal moreinfo="none">PropertyUtils.setProperty()</literal>
      <indexterm id="beans-ITERM-2242" significance="normal">
          <primary>PropertyUtils.setProperty( ) method</primary>
        </indexterm> <indexterm id="beans-ITERM-2243" significance="normal">
          <primary>methods</primary>

          <secondary>PropertyUtils.setProperty( )</secondary>
        </indexterm> to set any bean property: simple, nested, indexed, or
      mapped. Pass the bean object to be modified, the name of the property,
      and the value to <literal moreinfo="none">setProperty( )</literal>; this
      method will call the appropriate setter method on the supplied object.
      The following example demonstrates the use of this method to set two
      properties on a <literal moreinfo="none">Book</literal> bean:</para>

      <programlisting format="linespecific" id="I_3_tt144">import org.apache.commons.beanutils.PropertyUtils;

Person person1 = new Person( );
person1.setName( "Blah" );

Book book1 = new Book( );
book1.setName( "Blah" );
book1.setAuthor( "Blah" );

PropertyUtils.setProperty( book1, "name", "Some Apache Book" );
PropertyUtils.setProperty( book1, "author", new Person( ) );
PropertyUtils.setProperty( book1, "author.name", "Ken Coar" );</programlisting>

      <para>This code created an instance of the <literal
      moreinfo="none">Book</literal> bean and the <literal
      moreinfo="none">Person</literal> bean, and <literal
      moreinfo="none">PropertyUtils.setProperty( )</literal> set both a simple
      and a nested bean property.</para>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>In addition to simple and nested bean properties, this utility can
      populate indexed and mapped properties. The following example
      demonstrates the setting of mapped and indexed bean properties on a
      <literal moreinfo="none">Book</literal> object:</para>

      <programlisting format="linespecific" id="I_3_tt145">Book book1 = new Book( );
book1.getChapters( ).add( new Chapter( ) );
book1.getChapters( ).add( new Chapter( ) );

PropertyUtils.setProperty( book1, "name", "Apache: The Definitive Guide" );
PropertyUtils.setProperty( book1, "author", new Person( ) );
PropertyUtils.setProperty( book1, "author.name", "Laurie" );
PropertyUtils.setProperty( book1, "chapters[0].name", "Introduction" );

Apartment apartment = new Apartment( );
apartment.getRooms( ).put( "livingRoom", new Room( ) );

PropertyUtils.setProperty( apartment, "rooms(livingRoom).length", 
                 new Integer(12) );</programlisting>

      <para>Assume that the <literal moreinfo="none">Book</literal> bean is
      associated with a series of <literal moreinfo="none">Chapter</literal>
      objects each of which have a name property. The <literal
      moreinfo="none">Book</literal> bean has a <literal
      moreinfo="none">chapters</literal> property, which is a list. The name
      of the first chapter is set by referencing the <literal
      moreinfo="none">chapters[0].name</literal> property.</para>
    </sect2>
  </sect1>

  <sect1 id="beans-sect-testing" label="3.14" role="Recipe">
    <title>Testing Property Access</title>

    <sect2>
      <title>Problem</title>

      <para>You need to test a bean property <indexterm id="beans-ITERM-2244"
          significance="normal">
          <primary>JavaBeans</primary>

          <secondary>properties</secondary>

          <tertiary>testing</tertiary>
        </indexterm> <indexterm id="beans-ITERM-2245" significance="normal">
          <primary>beans</primary>

          <secondary>properties</secondary>

          <tertiary>testing</tertiary>
        </indexterm> <indexterm id="beans-ITERM-2246" significance="normal">
          <primary>properties</primary>

          <secondary>beans</secondary>

          <tertiary>testing</tertiary>
        </indexterm> <indexterm id="beans-ITERM-2247" significance="normal">
          <primary>testing</primary>

          <secondary>bean properties</secondary>
        </indexterm> <indexterm id="beans-ITERM-2248" significance="normal">
          <primary>access</primary>

          <secondary>beans</secondary>
        </indexterm>to see if it can be read from or written to.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use <literal moreinfo="none">PropertyUtils.isReadable()</literal>
      <indexterm id="beans-ITERM-2249" significance="normal">
          <primary>PropertyUtils.isReadable( ) method</primary>
        </indexterm> <indexterm id="beans-ITERM-2250" significance="normal">
          <primary>methods</primary>

          <secondary>PropertyUtils.isReadable( )</secondary>
        </indexterm> and <literal moreinfo="none">PropertyUtils.isWritable(
      )</literal> <indexterm id="beans-ITERM-2251" significance="normal">
          <primary>PropertyUtils.isWritable( ) method</primary>
        </indexterm> <indexterm id="beans-ITERM-2252" significance="normal">
          <primary>methods</primary>

          <secondary>PropertyUtils.isWritable( )</secondary>
        </indexterm>to see if a bean property is readable or writable. The
      following code tests the <literal moreinfo="none">name</literal>
      property of the <literal moreinfo="none">Book</literal> bean to see if
      it is readable and writable:</para>

      <programlisting format="linespecific" id="I_3_tt146">import org.apache.commons.beanutils.PropertyUtils;

// Create a Book demonstrating the getter and setter for "name"
Book book1 = new Book( );
book1.setName( "Blah" );
String name = book1.getName( );

// Can we read and write "name"
boolean nameReadable = PropertyUtils.isReadable( book, "name" );
boolean nameWritable = PropertyUtils.isWritable( book, "name" );

System.out.println( "Is name readable? " + nameReadable );
System.out.println( "Is name writable? " + nameWritable );</programlisting>

      <para>The <literal moreinfo="none">name</literal> property is both
      readable and writable, so the <literal
      moreinfo="none">nameReadable</literal> and <literal
      moreinfo="none">nameWritable</literal> variables will both be true. The
      output of this example is as follows:</para>

      <programlisting format="linespecific" id="I_3_tt147">Is name readable? true
Is name writable? true</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>In addition to working with simple properties, <literal
      moreinfo="none">isReadable()</literal> and <literal
      moreinfo="none">isWritable( )</literal> also work on nested, indexed,
      and mapped properties. The following example demonstrates the use of
      these methods to check access to the indexed, quadruple-nested, mapped
      bean property <literal moreinfo="none">length</literal>:</para>

      <programlisting format="linespecific" id="I_3_tt148">Book book1 = new Book( );
book1.getChapters( ).add( new Chapter( ) );

boolean isReadable =
    PropertyUtils.isReadable( book, 
        "chapters[0].author.apartment.rooms(livingRoom).length");

boolean isWritable =
    PropertyUtils.isWritable( book, 
        "chapters[0].author.apartment.rooms(livingRoom).length");</programlisting>

      <para><literal moreinfo="none">PropertyUtils.isReadable( )</literal>
      returns true if a specified bean property can be obtained via a public
      getter method, and <literal moreinfo="none">PropertyUtils.isWritable(
      )</literal> returns true if a specified bean property corresponds to a
      public setter method. This is an overly complex example, but it
      demonstrates the versatility of <literal
      moreinfo="none">PropertyUtils.isReadable( )</literal> and of <literal
      moreinfo="none">PropertyUtils.isWritable( )</literal>.</para>
    </sect2>
  </sect1>

  <sect1 id="beans-sect-validating-predicate" label="3.15" role="Recipe">
    <title>Validating Beans with Predicates</title>

    <sect2>
      <title>Problem</title>

      <para>You need to test the state of a <indexterm id="beans-ITERM-2253"
          significance="normal">
          <primary>JavaBeans</primary>

          <secondary>properties</secondary>

          <tertiary>validation</tertiary>
        </indexterm> <indexterm id="beans-ITERM-2254" significance="normal">
          <primary>beans</primary>

          <secondary>properties</secondary>

          <tertiary>validation</tertiary>
        </indexterm> <indexterm id="beans-ITERM-2255" significance="normal">
          <primary>properties</primary>

          <secondary>beans</secondary>

          <tertiary>validation</tertiary>
        </indexterm> <indexterm id="beans-ITERM-2256" significance="normal">
          <primary>validation</primary>

          <secondary>bean properties</secondary>
        </indexterm> <indexterm id="beans-ITERM-2257" significance="normal">
          <primary>predicates</primary>

          <secondary>bean validation</secondary>
        </indexterm>bean, testing for the presence or absence of simple and
      nested bean properties.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use a <literal moreinfo="none">BeanPredicate</literal> <indexterm
          id="beans-ITERM-2258" significance="normal">
          <primary>BeanPredicate</primary>
        </indexterm> <indexterm id="beans-ITERM-2259" significance="normal">
          <primary>interfaces</primary>

          <secondary>BeanPredicate</secondary>
        </indexterm> from Commons BeanUtils. A <literal
      moreinfo="none">BeanPredicate</literal> is an implementation of the
      <literal moreinfo="none">Predicate</literal> interface defined in
      Commons Collections. As described in <link linkend="functors">Chapter
      4</link>, a <literal moreinfo="none">Predicate</literal>'s <literal
      moreinfo="none">evaluate()</literal> method takes an object and returns
      a <literal moreinfo="none">boolean</literal>; <literal
      moreinfo="none">BeanPredicate</literal> decorates another <literal
      moreinfo="none">Predicate</literal>, allowing that <literal
      moreinfo="none">Predicate</literal> to evaluate a bean property: simple,
      nested, indexed, or mapped. The following code demonstrates the use of
      <literal moreinfo="none">BeanPredicate</literal> to validate the
      condition of a bean:</para>

      <programlisting format="linespecific" id="I_3_tt149">import org.apache.commons.beanutils.*;
import org.apache.commons.collections.*;

<userinput moreinfo="none">// A Predicate that returns true if the "name" property is not null</userinput>
               <userinput moreinfo="none">Predicate teamNotNull = new BeanPredicate( "name", new NotNullPredicate( ) );</userinput>

               <userinput moreinfo="none">// A Predicate that returns true if the "coach.firstName" property</userinput>
               <userinput moreinfo="none">// is "Tom"</userinput>
               <userinput moreinfo="none">Predicate coachFirstName = new BeanPredicate( "coach.firstName", </userinput>
               <userinput moreinfo="none">                                              new EqualsPredicate("Tom") );</userinput>

               <userinput moreinfo="none">// Tie two Predicates together into an AndPredicate</userinput>
               <userinput moreinfo="none">Predicate validateTeam = new AllPredicate( predicateArray );</userinput>

// Create Team Objects
Team fish = new Team( "Swordfish", new Coach( "Tom", "O'Connell") );
Team hens = new Team( "Hens", new Coach( "Bob", "McGarry") );

<userinput moreinfo="none">boolean fishValid = validateTeam.evaluate( fish );</userinput>
               <userinput moreinfo="none">boolean henValid = validateTeam.evaluate( hens );</userinput>

System.out.println( "Is Swordfish team valid? " + fishValid );
System.out.println( "Is Hens team valid? " + hensValid );</programlisting>

      <para>Assume that the two <literal moreinfo="none">Team</literal>
      objects contain two properties: <literal moreinfo="none">name</literal>
      and <literal moreinfo="none">coach</literal>. The <literal
      moreinfo="none">coach</literal> property on <literal
      moreinfo="none">Team</literal> is a <literal
      moreinfo="none">Coach</literal> object with two properties: <literal
      moreinfo="none">firstName</literal> and <literal
      moreinfo="none">lastName</literal>. The first <literal
      moreinfo="none">BeanPredicate</literal>, <literal
      moreinfo="none">teamNotNull</literal>, uses a <literal
      moreinfo="none">NotNullPredicate</literal> to test the simple property
      <literal moreinfo="none">name</literal>. The second <literal
      moreinfo="none">BeanPredicate</literal> uses an <literal
      moreinfo="none">EqualPredicate</literal> to test the nested property
      <literal moreinfo="none">coach.firstName</literal>. In the previous
      example, a <literal moreinfo="none">Team</literal> object is only valid
      if it has a name, and the first name of the coach is "Tom." Two teams
      are created and the following output is printed:</para>

      <programlisting format="linespecific" id="I_3_tt150">Is Swordfish team valid? true
Is Hens team valid? false</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>A <literal moreinfo="none">BeanPredicate</literal> obtains the
      value of the specified bean property using <literal
      moreinfo="none">PropertyUtils</literal> and passes the resulting
      property value to the <literal moreinfo="none">Predicate</literal> it
      was constructed with; <literal moreinfo="none">BeanPredicate</literal>
      decorates another <literal moreinfo="none">Predicate</literal>. The
      following example demonstrates the use of <literal
      moreinfo="none">BeanPredicate</literal>, wrapping an <literal
      moreinfo="none">EqualPredicate</literal>, <literal
      moreinfo="none">InstanceofPredicate</literal>, and a composite <literal
      moreinfo="none">AnyPredicate</literal>:</para>

      <programlisting format="linespecific" id="I_3_tt151">import org.apache.commons.collections.Predicate;
import org.apache.commons.beanutils.BeanPredicate;
import org.apache.commons.collections.functors.AnyPredicate;
import org.apache.commons.collections.functors.EqualPredicate;
import org.apache.commons.collections.functors.InstanceofPredicate;
import org.apache.commons.collections.functors.OrPredicate;

// A predicate to validate the value of the age property
<userinput moreinfo="none">Predicate example1 = new BeanPredicate( "age", </userinput>
               <userinput moreinfo="none">        new EqualPredicate( new Integer( 10 ) );</userinput>

// A predicate to validate the type of the title property
<userinput moreinfo="none">Predicate example2 = new BeanPredicate( "book[4].title", </userinput>
               <userinput moreinfo="none">        new InstanceofPredicate( String.class ) );</userinput>

// A composite predicate definition
Predicate equalA = new EqualsPredicate("A");
Predicate equalB = new EqualsPredicate("B");
Predicate equalC = new EqualsPredicate("C");
Predicate eitherABC = 
    new AnyPredicate( new Predicate[] { equalA, equalB, equalC } );

// A predicate to validate the type of the title property
<userinput moreinfo="none">Predicate example3 = new BeanPredicate( "mode", eitherABC );</userinput>
            </programlisting>

      <para>Predicate <literal moreinfo="none">example1</literal> tests the
      <literal moreinfo="none">age</literal> property of a bean, passing the
      property value to an <literal moreinfo="none">EqualPredicate</literal>,
      which returns true if age is 10. Predicate <literal
      moreinfo="none">example2</literal> tests the property <literal
      moreinfo="none">title</literal> from the fifth element in the <literal
      moreinfo="none">book</literal> property; if the book's title property
      value is of type <literal moreinfo="none">String</literal>, <literal
      moreinfo="none">example2</literal> returns true. Predicate <literal
      moreinfo="none">example3</literal> tests the value of the <literal
      moreinfo="none">mode</literal> property of a bean, it evaluates to true
      if <literal moreinfo="none">mode</literal> equals "A," "B," or "C."
      These three examples demonstrate that a <literal
      moreinfo="none">BeanPredicate</literal> is a simple decorator, which
      allows one to apply any <literal moreinfo="none">Predicate</literal> to
      a bean property.</para>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para><link linkend="functors">Chapter 4</link> contains more recipes
      focused on using <literal moreinfo="none">Predicate</literal>
      implementations to perform complex validation and to create intelligent,
      self-validating collections. This recipe introduces two simple
      predicates; <literal moreinfo="none">EqualPredicate</literal> and
      <literal moreinfo="none">NotNullPredicate</literal> are discussed in
      <link linkend="functors-sect-simple-pred">Recipe 4.7</link>. For more
      information about using predicates, see <link linkend="functors">Chapter
      4</link> and the Commons Collections project site at <ulink
      url="http://commons.apache.org/collections">http://commons.apache.org/collections</ulink>.</para>
    </sect2>
  </sect1>

  <sect1 id="beans-sect-map-props" label="3.16" role="Recipe">
    <title>Creating a Map of Bean Properties</title>

    <sect2>
      <title>Problem</title>

      <para>You need to create a <literal moreinfo="none">Map</literal>
      <indexterm id="beans-ITERM-2260" significance="normal">
          <primary>JavaBeans</primary>

          <secondary>properties</secondary>

          <tertiary>mapping</tertiary>
        </indexterm> <indexterm id="beans-ITERM-2261" significance="normal">
          <primary>beans</primary>

          <secondary>properties</secondary>

          <tertiary>mapping</tertiary>
        </indexterm> <indexterm id="beans-ITERM-2262" significance="normal">
          <primary>properties</primary>

          <secondary>beans</secondary>

          <tertiary>mapping</tertiary>
        </indexterm> <indexterm id="beans-ITERM-2263" significance="normal">
          <primary>mapping</primary>

          <secondary>beans properties</secondary>
        </indexterm> that contains every property in a bean.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use <literal moreinfo="none">PropertyUtils.describe()</literal>
      <indexterm id="beans-ITERM-2264" significance="normal">
          <primary>PropertyUtils.describe( ) method</primary>
        </indexterm> <indexterm id="beans-ITERM-2265" significance="normal">
          <primary>methods</primary>

          <secondary>PropertyUtils.describe( )</secondary>
        </indexterm> to generate a <literal moreinfo="none">Map</literal>
      containing all of the readable bean properties from a bean instance.
      Supply an instance of a bean and this method will return a <literal
      moreinfo="none">Map</literal> containing all readable bean properties.
      The code shown here demonstrates the use of <literal
      moreinfo="none">PropertyUtils.describe( )</literal> to describe a
      <literal moreinfo="none">Person</literal> bean:</para>

      <programlisting format="linespecific" id="I_3_tt152">import java.util.*;
import org.apache.commons.beanutils.PropertyUtils;

// Create a Person and a Book bean instance
Person person = new Person( );
person.setName( "Some Dude" );

Book book = new Book( );
book.setName( "Some Silly Computer Book" );
book.setAuthor( person );

// Describe both beans with a Map
Map bookMap = PropertyUtils.describe( book );
Map authorMap = PropertyUtils.describe( bookMap.get("book") );

System.out.println( "Book Name: " + bookMap.get( "name" ) );
System.out.println( "Author Name: " + authorMap.get( "name" ) );</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>The previous example involves a <literal
      moreinfo="none">Book</literal> bean with a <literal
      moreinfo="none">name</literal> and <literal
      moreinfo="none">author</literal> property; the <literal
      moreinfo="none">author</literal> property is a <literal
      moreinfo="none">Person</literal> bean with one property: <literal
      moreinfo="none">name</literal>. The two maps, <literal
      moreinfo="none">bookMap</literal> and <literal
      moreinfo="none">authorMap</literal>, contain keys for every defined bean
      property, and two of those properties are printed out:</para>

      <programlisting format="linespecific" id="I_3_tt153">Book Name: Some Silly Computer Book
Author Name: Some Dude</programlisting>

      <para>The map returned from <literal
      moreinfo="none">PropertyUtils.describe( )</literal> is a <literal
      moreinfo="none">HashMap</literal> that contains every property from the
      bean to be described. Internally, <literal
      moreinfo="none">PropertyUtils.describe()</literal> uses <literal
      moreinfo="none">PropertyUtils.getPropertyDescriptors( )</literal> to
      obtain the list of properties to put into this map.</para>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para><link linkend="beans-sect-wrap-map">Recipe 3.17</link>
      demonstrates the use of the <literal moreinfo="none">BeanMap</literal>
      to wrap a bean and expose a bean's properties via the <literal
      moreinfo="none">Map</literal> interface.</para>
    </sect2>
  </sect1>

  <sect1 id="beans-sect-wrap-map" label="3.17" role="Recipe">
    <title>Wrapping a Bean with a Map</title>

    <sect2>
      <title>Problem</title>

      <para>You need to expose a bean's properties<indexterm
          class="startofrange" id="beans-ITERM-2266" significance="normal">
          <primary>JavaBeans</primary>

          <secondary>properties</secondary>

          <tertiary>wrapping maps</tertiary>
        </indexterm> <indexterm class="startofrange" id="beans-ITERM-2267"
          significance="normal">
          <primary>beans</primary>

          <secondary>properties</secondary>

          <tertiary>wrapping maps</tertiary>
        </indexterm> <indexterm class="startofrange" id="beans-ITERM-2268"
          significance="normal">
          <primary>properties</primary>

          <secondary>beans</secondary>

          <tertiary>wrapping maps</tertiary>
        </indexterm> <indexterm class="startofrange" id="beans-ITERM-2269"
          significance="normal">
          <primary>wrapping</primary>

          <secondary>bean properties</secondary>
        </indexterm> as a <literal moreinfo="none">Map</literal>, and operate
      on the bean properties as if they were entries in a <literal
      moreinfo="none">Map</literal>.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Wrap any bean in a <literal moreinfo="none">BeanMap</literal>
      <indexterm id="beans-ITERM-2270" significance="normal">
          <primary>BeanMap</primary>
        </indexterm>. This <literal moreinfo="none">Map</literal>
      implementation uses introspection to provide access to bean properties
      as if they were key/value pairs in a map. This code wraps a <literal
      moreinfo="none">Person</literal> bean with <literal
      moreinfo="none">BeanMap</literal>, iterating through every key and
      accessing bean properties with <literal moreinfo="none">get(
      )</literal>:</para>

      <programlisting format="linespecific" id="I_3_tt154">import java.util.*;
import org.apache.commons.collections.BeanMap;

Person person = new Person( );
person.setName( "Jim" );
person.setAge( new Integer( 28 ) );
person.setOccupation( "Developer" );

Map beanMap = new BeanMap( person );

Set keys = beanMap.keySet( );
Iterator keyIterator = keys.iterator( );
while( keyIterator.hasNext( ) ) {
   String propertyName = (String) keyIterator.next( );

   System.out.println( "Property: " + propertyName +
                       ", Value: " + beanMap.get( propertyName ) +
                       ", Type: " + beanMap.getType( propertyName ).
                       toString( ) );
}</programlisting>

      <para>The <literal moreinfo="none">Person</literal> bean has the
      following properties: <literal moreinfo="none">age</literal>, <literal
      moreinfo="none">name</literal>, and <literal
      moreinfo="none">occupation</literal>; an instance of this bean is
      created and passed to the constructor of <literal
      moreinfo="none">BeanMap</literal>. The following output is created by
      iterating over the key set of <literal
      moreinfo="none">beanMap</literal>:</para>

      <programlisting format="linespecific" id="I_3_tt155">Property: Age, Value: 28, Type: java.lang.String
Property: Name, Value: Jim, Type: java.lang.Integer
Property: Occupation, Value: Developer, Type: java.lang.String</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>The previous example demonstrates the use of <literal
      moreinfo="none">PropertyUtils.describe( )</literal> to create a <literal
      moreinfo="none">Map</literal> containing bean properties. <literal
      moreinfo="none">BeanMap</literal> not only exposes bean properties with
      a <literal moreinfo="none">Map</literal> interface, it wraps a bean
      instance, allowing you to alter the contents of the underlying bean via
      <literal moreinfo="none">put()</literal>. In addition to implementing
      the <literal moreinfo="none">Map</literal> interface, <literal
      moreinfo="none">BeanMap</literal> provides a number of additional
      methods for obtaining <literal moreinfo="none">Method</literal> objects
      and the types of bean properties. <link linkend="beans-TABLE-1">Table
      3-1</link> describes a<indexterm id="beans-ITERM-2271"
          significance="normal">
          <primary>methods</primary>

          <secondary>BeanMap</secondary>
        </indexterm> few of these methods.</para>

      <table id="beans-TABLE-1" label="3-1">
        <title>Methods provided by BeanMap</title>

        <tgroup cols="2">
          <colspec colname="col1" colnum="1" />

          <colspec colname="col2" colnum="2" />

          <thead>
            <row>
              <entry><para>Method</para></entry>

              <entry><para>Description</para></entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><para> <literal moreinfo="none">clear( )</literal>
              </para></entry>

              <entry><para>Constructs a new instance of a bean using the
              no-argument constructor of the class that corresponds to
              <literal moreinfo="none">getBean( ).getClass()</literal>
              </para></entry>
            </row>

            <row>
              <entry><para> <literal moreinfo="none">clone( )</literal>
              </para></entry>

              <entry><para>If possible, creates another instance of <literal
              moreinfo="none">BeanMap</literal>, wrapping a copy of the
              wrapped bean</para></entry>
            </row>

            <row>
              <entry><para> <literal moreinfo="none">getBean( )</literal>
              </para></entry>

              <entry><para>Returns the bean wrapped by this <literal
              moreinfo="none">BeanMap</literal> </para></entry>
            </row>

            <row>
              <entry><para> <literal moreinfo="none">setBean(Object
              bean)</literal> </para></entry>

              <entry><para>Causes an instance of <literal
              moreinfo="none">BeanMap</literal> to wrap the supplied
              bean</para></entry>
            </row>

            <row>
              <entry><para> <literal moreinfo="none">getType(String
              name)</literal> </para></entry>

              <entry><para>Retrieves the type of the specified bean
              property</para></entry>
            </row>

            <row>
              <entry><para> <literal moreinfo="none">getReadMethod(String
              name)</literal> </para></entry>

              <entry><para>Retrieves a <literal
              moreinfo="none">Method</literal> object for the read method (or
              getter) of the specified property</para></entry>
            </row>

            <row>
              <entry><para> <literal moreinfo="none">getWriteMethod(String
              name)</literal> </para></entry>

              <entry><para>Retrieves a <literal
              moreinfo="none">Method</literal> object for the write method (or
              setter) of the specified property</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para><link linkend="beans-ex-6">Example 3-6</link> demonstrates the use
      of the methods listed above to manipulate and alter properties of a
      <literal moreinfo="none">Person</literal> bean. Remember, when you alter
      a <literal moreinfo="none">BeanMap</literal>, you are modifying the
      underlying bean.</para>

      <example id="beans-ex-6" label="3-6">
        <title>BeanMap methods getBean( ), setBean( ), getType( ),
        getReadMethod( ), and getWriteMethod( )</title>

        <programlisting format="linespecific">package com.discursive.jccook.collections;

import java.lang.reflect.Method;

import org.apache.commons.collections.BeanMap;

public class BeanMapExample {
    public static void main(String[] args) throws Exception {
        BeanMapExample example = new BeanMapExample( );
        example.start( );
    }

    public void start( ) throws Exception {

        // Create a Person bean
        Person person = new Person( );
        person.setName( "Todd" );
        person.setAge( new Integer( 45 ) );
        person.setOccupation( "Record Collector" );

        // Wrap person with a Map 
        BeanMap map = new BeanMap( person );

<userinput moreinfo="none">        // Set the age to 24 using a Method from this map</userinput>
                  <userinput moreinfo="none">        Method method = map.getWriteMethod( "age" );</userinput>
                  <userinput moreinfo="none">        method.invoke( person, new Integer(24) );        </userinput>

                  <userinput moreinfo="none">        // Set the name to "John" using map.put</userinput>
                  <userinput moreinfo="none">        map.put( "name", "John" );</userinput>

        // Create a Person bean
        Person person2 = new Person( );
        person2.setName( "Cindy" );
        person2.setAge( new Integer( 39 ) );
        person2.setOccupation( "Transcriptionist" );

<userinput moreinfo="none">        // Make the BeanMap operate on another bean</userinput>
                  <userinput moreinfo="none">        map.setBean( person2 );</userinput>

                  <userinput moreinfo="none">        // Get the type of the Age property</userinput>
                  <userinput moreinfo="none">        Class type = map.getType( "age" );</userinput>
    }
}</programlisting>
      </example>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para><literal moreinfo="none">BeanMap</literal> provides a convenient
      shortcut for accessing and manipulating beans, providing the same
      abilities that are provided by <literal
      moreinfo="none">PropertyUtils</literal>. For more information about
      accessing and manipulating <indexterm class="endofrange"
      id="beans-ITERM-2272" significance="normal"
      startref="beans-ITERM-2266"></indexterm> <indexterm class="endofrange"
      id="beans-ITERM-2273" significance="normal"
      startref="beans-ITERM-2267"></indexterm> <indexterm class="endofrange"
      id="beans-ITERM-2274" significance="normal"
      startref="beans-ITERM-2268"></indexterm> <indexterm class="endofrange"
      id="beans-ITERM-2275" significance="normal"
      startref="beans-ITERM-2269"></indexterm>bean properties with <literal
      moreinfo="none">PropertyUtils</literal>, see <link
      linkend="beans-sect-accessing-all">Recipe 3.8</link> and <link
      linkend="beans-sect-setting-property">Recipe 3.13</link>.</para>
    </sect2>
  </sect1>

  <sect1 id="beans-sect-dyna" label="3.18" role="Recipe">
    <title>Creating a Dynamic Bean</title>

    <sect2>
      <title>Problem</title>

      <para>You need to be able to create a bean <indexterm
          id="beans-ITERM-2276" significance="normal">
          <primary>JavaBeans</primary>

          <secondary>dynamic beans</secondary>
        </indexterm> <indexterm id="beans-ITERM-2277" significance="normal">
          <primary>beans</primary>

          <secondary>dynamic</secondary>
        </indexterm> <indexterm id="beans-ITERM-2278" significance="normal">
          <primary>dynamic beans</primary>
        </indexterm>dynamically at runtime.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use a <literal moreinfo="none">DynaBean</literal>. You can create
      a <literal moreinfo="none">DynaBean</literal> with an arbitrary set of
      properties at runtime, and the resulting <literal
      moreinfo="none">DynaBean</literal> object will function properly with
      all Commons BeanUtils utilities, such as <literal
      moreinfo="none">PropertyUtils</literal>. The following example
      demonstrates the use of a <literal
      moreinfo="none">BasicDynaBean</literal> to model a politician:</para>

      <programlisting format="linespecific" id="I_3_tt156">import java.util.*;
import org.apache.commons.beanutils.*;

DynaProperty[] beanProperties = new DynaProperty[]{
    new DynaProperty("name", String.class),
    new DynaProperty("party", Party.class),
    new DynaProperty("votes", Long.class)
};

BasicDynaClass politicianClass = 
    new BasicDynaClass("politician", BasicDynaBean.class, props);

DynaBean politician = politicianClass.newInstance( );

<emphasis role="bold">// Set the properties via DynaBean</emphasis>
politician.set( "name", "Tony Blair" );
politician.set( "party", Party.LABOUR );
politician.set( "votes", new Long( 50000000 ) );

<emphasis role="bold">// Set the properties with PropertyUtils</emphasis>
PropertyUtils.setProperty( politician, "name", "John Major" );
PropertyUtils.setProperty( politician, "party", Party.TORY );
PropertyUtils.setProperty( politician, "votes", new Long( 50000000 ) );</programlisting>

      <para>In this code, the properties of the <literal
      moreinfo="none">politician</literal> bean are set using two different
      methods. The first method is to manipulate properties via the <literal
      moreinfo="none">DynaBean</literal> <indexterm id="beans-ITERM-2279"
          significance="normal">
          <primary>DynaBean interface</primary>
        </indexterm> <indexterm id="beans-ITERM-2280" significance="normal">
          <primary>interfaces</primary>

          <secondary>DynaBean</secondary>
        </indexterm> <indexterm id="beans-ITERM-2281" significance="normal">
          <primary>objects</primary>

          <secondary>DynaBean</secondary>
        </indexterm> interface, and the second method involves using <literal
      moreinfo="none">PropertyUtils.setProperty( )</literal>. Both regions of
      code accomplish the same goal, and <literal
      moreinfo="none">PropertyUtils</literal> was included to emphasize the
      fact that most utilities in BeanUtils will understand how to work with
      <literal moreinfo="none">DynaBean</literal> implementations.</para>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para><literal moreinfo="none">DynaBean</literal> objects come in handy
      when your system uses beans to represent a data model. Since a bean is
      just a collection of properties, you can avoid having to maintain a bean
      class by automatically generating a bean from a description of the
      objects and properties; for example, a complex data model could be
      described in an XML document, and a utility would parse such a document
      and create a number of <literal moreinfo="none">DynaClass</literal>
      objects at runtime.</para>

      <para>A <literal moreinfo="none">DynaBean</literal> contains the methods
      listed in <link linkend="beans-TABLE-2">Table 3-2</link>. There are
      methods to get and set indexed and mapped properties, and two
      operations—<literal moreinfo="none">remove()</literal> and <literal
      moreinfo="none">contains( )</literal>—allow you to manipulate the
      contents of a <literal moreinfo="none">Map</literal> property.</para>

      <table id="beans-TABLE-2" label="3-2">
        <title>Methods available on a DynaBean</title>

        <tgroup cols="2">
          <colspec colname="col1" colnum="1" />

          <colspec colname="col2" colnum="2" />

          <thead>
            <row>
              <entry><para>Method</para></entry>

              <entry><para>Description</para></entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><para> <literal moreinfo="none">get(String
              name)</literal> </para></entry>

              <entry><para>Retrieves a simple bean property</para></entry>
            </row>

            <row>
              <entry><para> <literal moreinfo="none">get(String name, int
              i)</literal> </para></entry>

              <entry><para>Retrieves an indexed been property</para></entry>
            </row>

            <row>
              <entry><para> <literal moreinfo="none">get(String name, String
              key)</literal> </para></entry>

              <entry><para>Retrieves a mapped bean property</para></entry>
            </row>

            <row>
              <entry><para> <literal moreinfo="none">set(String name, Object
              value)</literal> </para></entry>

              <entry><para>Sets a simple bean property</para></entry>
            </row>

            <row>
              <entry><para> <literal moreinfo="none">set(String name, int i,
              Object value)</literal> </para></entry>

              <entry><para>Sets an indexed bean property</para></entry>
            </row>

            <row>
              <entry><para> <literal moreinfo="none">set(String name, String
              key, Object value)</literal> </para></entry>

              <entry><para>Sets a mapped bean property</para></entry>
            </row>

            <row>
              <entry><para> <literal moreinfo="none">remove(String name,
              String key)</literal> </para></entry>

              <entry><para>Removes a key from a mapped bean
              property</para></entry>
            </row>

            <row>
              <entry><para> <literal moreinfo="none">contains(String name,
              String key)</literal> </para></entry>

              <entry><para>Tests a map property for the presence of a
              key</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para><link linkend="xml">Chapter 6</link> combines the power of Commons
      Digester and Commons BeanUtils to create a utility that reads in bean
      definitions from an XML document. A data model is described using an XML
      document, and it is realized into a set of <literal
      moreinfo="none">DynaClass</literal> objects.</para>

      <para><link linkend="searching-filtering">Chapter 12</link> discusses
      the power of Commons BeanUtils as it relates to working with a database.
      A <literal moreinfo="none">ResultSetDynaClass</literal> enables you to
      wrap a JDBC <literal moreinfo="none">ResultSet</literal>.</para>
    </sect2>
  </sect1>

  <sect1 id="beans-sect-getting-setting-string" label="3.19" role="Recipe">
    <title>Getting and Setting Properties as Strings</title>

    <sect2>
      <title>Problem</title>

      <para>You need to persist a bean to a<indexterm id="beans-ITERM-2283"
          significance="normal">
          <primary>JavaBeans</primary>

          <secondary>properties</secondary>

          <tertiary>strings</tertiary>
        </indexterm> <indexterm id="beans-ITERM-2284" significance="normal">
          <primary>beans</primary>

          <secondary>properties</secondary>

          <tertiary>strings</tertiary>
        </indexterm> <indexterm id="beans-ITERM-2285" significance="normal">
          <primary>properties</primary>

          <secondary>beans</secondary>

          <tertiary>strings</tertiary>
        </indexterm> <indexterm id="beans-ITERM-2286" significance="normal">
          <primary>strings</primary>

          <secondary>beans properties</secondary>
        </indexterm> text file, or populate a bean's properties from a
      <literal moreinfo="none">String</literal>.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use <literal moreinfo="none">BeanUtils</literal> to get and set
      bean properties with strings. This utility contains many of the same
      functions as <literal moreinfo="none">PropertyUtils</literal> with one
      major exception; instead of returning the <literal
      moreinfo="none">Object</literal> value of the property, <literal
      moreinfo="none">BeanUtils</literal> returns and expects a string
      representation of a value. The following code uses <literal
      moreinfo="none">BeanUtils</literal> to populate a bean that is dependent
      on user input:</para>

      <programlisting format="linespecific" id="I_3_tt157">import java.util.*;
import org.apache.commons.beanutils.*;

Person person = new Person( );
person.setAge( new Integer( 45 ) );
person.setName( "Donald" );
person.setOccupation( "Salesman" );

<userinput moreinfo="none">// Get the Age as a String</userinput>
               <userinput moreinfo="none">String ageString = BeanUtils.getProperty( person, "age" );</userinput>

               <userinput moreinfo="none">// Set the Age from a String</userinput>
               <userinput moreinfo="none">BeanUtils.setProperty( person, "age", "50" );</userinput>
            </programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para><literal moreinfo="none">BeanUtils</literal> come in handy when a
      bean is populated from a user-supplied input like standard input or the
      parameters of an HTTP request. In fact, <literal
      moreinfo="none">BeanUtils</literal> started as the mechanism used to
      populate a Struts <literal moreinfo="none">ActionForm</literal> from the
      contents of an HTTP request. When the Struts <literal
      moreinfo="none">ActionServlet</literal> receives a request that is
      mapped to an <literal moreinfo="none">Action</literal>, the <literal
      moreinfo="none">ActionServlet</literal> calls a method in <literal
      moreinfo="none">RequestUtils</literal>, which examines the request and
      sets any properties on the relevant <literal
      moreinfo="none">ActionForm</literal>. Because the inner workings of
      Struts are outside the scope of this book, <link
      linkend="beans-ex-7">Example 3-7</link> takes a <literal
      moreinfo="none">String</literal> input from <literal
      moreinfo="none">System.in</literal> and sets the <literal
      moreinfo="none">age</literal> property of <literal
      moreinfo="none">Person</literal>.</para>

      <example id="beans-ex-7" label="3-7">
        <title>Using BeanUtils to populate a bean from user input</title>

        <indexterm id="beans-ITERM-2287" significance="normal">
          <primary>beans</primary>

          <secondary>populating</secondary>
        </indexterm>

        <indexterm id="beans-ITERM-2288" significance="normal">
          <primary>populating</primary>

          <secondary>beans</secondary>
        </indexterm>

        <indexterm id="beans-ITERM-2289" significance="normal">
          <primary>JavaBeans</primary>

          <secondary>populating</secondary>
        </indexterm>

        <programlisting format="linespecific">import java.io.*; 

public class ReadAge { 
    public static void main (String[] args) throw Exception { 
        //  Prompt for an Age
        System.out.print("Enter Age: "); 

        //  open up standard input 
        BufferedReader br = 
            new BufferedReader(new InputStreamReader(System.in)); 

        String ageString = null; 
        ageString = br.readLine( ); 

<userinput moreinfo="none">        // Set the Integer property with a String</userinput>
                  <userinput moreinfo="none">        Person person = new Person( );</userinput>
                  <userinput moreinfo="none">        BeanUtils.setProperty( person, "age", ageString );</userinput>
   } 
}</programlisting>
      </example>

      <para>When <literal moreinfo="none">BeanUtils</literal> sets the
      <literal moreinfo="none">age</literal> property, it uses a set of
      registered <literal moreinfo="none">Converter</literal> instances that
      are available to translate between a <literal
      moreinfo="none">String</literal> and an <literal
      moreinfo="none">Object</literal>. Behind the scenes, <literal
      moreinfo="none">BeanUtils</literal> used the <literal
      moreinfo="none">IntegerConverter</literal> class to convert the
      user-supplied <literal moreinfo="none">String</literal> to an <literal
      moreinfo="none">Integer</literal> object. For a full list of converters,
      read the documentation for the <literal
      moreinfo="none">org.apache.commons.beanutils.converters</literal>
      package.</para>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>The BeanUtils Javadoc is available at <ulink
      url="http://commons.apache.org/beanutils/api/index.html">http://commons.apache.org/beanutils/api/index.html</ulink>.</para>
    </sect2>
  </sect1>
</chapter>
