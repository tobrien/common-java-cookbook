<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://mars.discursive.com/docbook/xml/4.5/docbookx.dtd">
<chapter id="json">
  <title>JSON</title>

  <sect1 id="json-sect-intro">
    <title>Introduction</title>

    <para>What is JSON? Here's a formal definition of the JSON format from
    <ulink url="http://www.json.org/">http://www.json.org</ulink>:</para>

    <blockquote>
      <para>"JSON (JavaScript Object Notation) is a lightweight
      data-interchange format. It is easy for humans to read and write. It is
      easy for machines to parse and generate. It is based on a subset of the
      JavaScript Programming Language, Standard ECMA-262 3rd Edition -
      December 1999. JSON is a text format that is completely language
      independent but uses conventions that are familiar to programmers of the
      C-family of languages, including C, C++, C#, Java, JavaScript, Perl,
      Python, and many others. These properties make JSON an ideal
      data-interchange language." - from <ulink
      url="http://www.json.org/">http://www.json.org</ulink>.</para>
    </blockquote>

    <para>JSON is best explained by using an example. The following is an
    example of data encoding in a JSON format:</para>

    <programlisting language="java">{
  "person": {
    "Gender": "male",
    "FirstName": "Zach",
    "LastName": "Anner",
    "Occupation": "Television Host",
    "Employer": "Harpo Productions, Inc.",
    "Salary": 2330000
   }
}</programlisting>

    <para>That same data could also be represented in XML:</para>

    <programlisting language="xml">&lt;person gender="male"&gt;
  &lt;firstName&gt;Zach&lt;/firstName&gt;
  &lt;lastName&gt;Anner&lt;/lastName&gt;
  &lt;occupation&gt;Television Host&lt;/occupation&gt;
  &lt;employer&gt;Harpo Producitons, Inc.&lt;/employer&gt;
  &lt;salary&gt;2330000&lt;/salary&gt;
&lt;/person&gt;</programlisting>

    <para>Just in this simple comparison, you can see that JSON isn't as
    redundant as XML and it is a slightly more readable format. Many
    developers have been moving to JSON from XML because they are looking for a 
    lightweight alternative. JSON is generally easier to parse than XML, and
    when you are parsing JSON, you don't have to worry about the often
    confusing sea of standards that surround XML.</para>

    <para>XML is still an appropriate format for data in
    many situations, but if you are trying to write a lightweight REST service
    which needs to be consumed by a mobile device or a web browser, you often
    want to make sure that the format you are sending down the wire can be
    parsed with a minimum amount of effort. JSON is that format, it is both
    lightweight and widely embraced as a standard. If you are building
    a REST service, producing data which needs to be consumed by a mobile
    device like an iPhone, interacting with a 3rd party API like PayPal or
    Google, or just looking for a simple way to store and communicate
    structured data, JSON is something you should evaluate alongside
    XML.</para>

    <para>JSON can be parsed in every language, from Pike to C# to R to Ruby,
    and, of course, Java. While there are a few options available for parsing
    JSON in Java, this chapter is focused on the <ulink
    url="http://json-lib.sourceforge.net/">JSON-lib</ulink> library. The
    JSON-lib library is available under the Apache Software License, Version
    2.0, it is built with Maven, it is readily available in the Maven Central
    repository, and it is the most well documented of the Java JSON libraries
    with a very <ulink url="http://json-lib.sourceforge.net/">well maintained
    project website</ulink>. This library is based on the
    original org.json package maintained by Douglas Crockford, and it is
    packaged into an library that is easy to use.</para>
  </sect1>

  <sect1 id="json-sect-obtaining-jsonlib" role="Recipe">
    <title>Obtaining JSON-lib</title>

    <sect2>
      <title>Problem</title>

      <para>You need to add a dependency on JSON-lib in a Java project.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>To use json-lib in a Maven 2 project, add the following dependency
      to your project's <filename>pom.xml</filename>:</para>

      <example id="json-ex-adding-depend">
        <title>Adding a Dependency on Commons Digester</title>

        <programlisting language="xml">&lt;dependency&gt;
  &lt;groupId&gt;net.sf.json-lib&lt;/groupId&gt;
  &lt;artifactId&gt;json-lib&lt;/artifactId&gt;
  &lt;version&gt;2.3&lt;/version&gt;
  &lt;classifier&gt;jdk15&lt;/classifier&gt;
  &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
</programlisting>
      </example>

      <para>If you are not sure what this means, I'd suggest reading <ulink
      url="http://www.sonatype.com/books/maven-book">Maven: The Complete Reference</ulink>. When you depend on a library in Maven 2, all you need to
      do is add the dependency <varname>groupId</varname>,
      <varname>artifactId</varname>, and <varname>version</varname> to your
      project's dependencies. Once you do this, Maven 2 will download the
      dependency and make it available on your project's classpath.</para>

      <para>To use all of the features of JSON-lib, you will also need to
      declare a dependency on Commons Lang 2.4 or higher, Commons BeanUtils
      1.7.0 or higher, Commons Collections 3.2 or higher, Commons Logging
      1.0.4 or higher, and ezmorph 1.0.6. If you are using Apache Maven to
      manage your dependencies, these transitive dependencies will be
      automatically added to your classpath. The Dependency Hierarchy for
      JSON-lib in the m2eclipse plugin is shown in <xref
      linkend="json-fig-dependencies" />.</para>

      <figure float="0" id="json-fig-dependencies">
        <title>Transitive Dependencies for JSON-lib</title>

        <mediaobject>
          <imageobject role="print">
            <imagedata align="center"
                       fileref="figs/print/json-dependencies.pdf" format="PDF"
                       scalefit="0" width="100%" />
          </imageobject>

          <imageobject role="web">
            <imagedata fileref="figs/web/json-dependencies.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>the JSON-lib project's home page can be found at <ulink
      url="http://json-lib.sourceforge.net/">http://json-lib.sourceforge.net/</ulink>.</para>
    </sect2>
  </sect1>

  <sect1 id="json-sect-creating-json">
    <title>Creating JSON</title>

    <sect2>
      <title>Problem</title>

      <para>You need to create some JSON.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Create a <classname>JSONObject</classname> and add elements to it
      as shown in the following class:</para>

      <example id="json-ex-generating">
        <title>Generating JSON from Java</title>

        <programlisting language="java">package com.discursive.cjcook.json;

import net.sf.json.JSONObject;

public class GeneratingJSON {

    public static void main(String[] args) throws Exception {

        JSONObject json = new JSONObject();
        
        // Put a simple element
        json.put( "aircraft", "A320");
        
        // Add a JSON Object
        JSONObject pilot = new JSONObject();
        pilot.put( "firstName", "John");
        pilot.put( "lastName", "Adams");
        json.put( "pilot", pilot);

        // Accumulate values in an array
        json.accumulate("passenger", "George Washington");
        json.accumulate("passenger", "Thomas Jefferson");
        
        // Passing a number to toString() adds indentation
        System.out.printf( "JSON: %s", json.toString(2) );
    }
}
</programlisting>
      </example>

      <para>The <methodname>put()</methodname> function adds an element the
      JSON object, you can put a simple value like a
      <classname>String</classname> or a primitive, or you can add another
      <classname>JSONObject</classname>. The
      <methodname>accumulate()</methodname> method collects values and
      assembles them into a <classname>JSONArray</classname>.</para>

      <para>Running this example will produce the following JSON
      output:</para>

      <programlisting language="java">JSON: {
  "aircraft": "A320",
  "pilot":   {
    "firstName": "John",
    "lastName": "Adams"
  },
  "passenger":   [
    "George Washington",
    "Thomas Jefferson"
  ]
}</programlisting>
    </sect2>
  </sect1>

  <sect1>
    <title>Converting a Map to JSON</title>

    <sect2>
      <title>Problem</title>

      <para>You need to convert a Map to JSON.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>That's easy. Since <classname>net.sf.json.JSONObject</classname>
      implements the <classname>java.util.Map</classname> interface, all you
      need to do is create a <classname>JSONObject</classname> and pass the
      map to the <methodname>putAll()</methodname> method.</para>

      <example id="json-ex-convert-map">
        <title>Converting a Map to JSON</title>

        <programlisting language="java">package com.discursive.cjcook.json;

import java.util.HashMap;
import java.util.Map;

import net.sf.json.JSONObject;

public class ConvertMaptoJSON {

  public static void main(String[] args) throws Exception {
    Map&lt;String, Object&gt; data = new HashMap&lt;String, Object&gt;();
    data.put( "name", "Marshall Mathers" );
    data.put( "age", 37 );
    data.put( "city", "Detroit" );

    JSONObject json = new JSONObject();
    json.putAll( data );
    System.out.printf( "JSON: %s", json.toString(2) );
  }
}
</programlisting>
      </example>

      <para>Running the class shown in <xref linkend="json-ex-convert-map" />
      produces the following output:</para>

      <screen>JSON: {
  "age": 37,
  "name": "Marshall Mathers",
  "city": "Detroit"
}</screen>
    </sect2>
  </sect1>

  <sect1>
    <title>Converting a Bean to JSON</title>

    <sect2>
      <title>Problem</title>

      <para>You need to convert a Java bean to JSON.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use the static <classname>JSONObject</classname> method
      <methodname>fromObject()</methodname> to convert a Java bean to
      JSON.</para>

      <example id="json-ex-convert-bean">
        <title>Converting a Bean to JSON</title>

        <programlisting langauge="java">package com.discursive.cjcook.json;

import java.util.HashMap;
import java.util.Map;

import net.sf.json.JSONObject;
import net.sf.json.util.JSONBuilder;

public class ConvertBeantoJSON {

  public static void main(String[] args) throws Exception {
    Person person = new Person("Marshall Mathers", 37, "Detroit");

    JSONObject json = JSONObject.fromObject( person );
    System.out.printf("JSON: %s", json.toString(2));
  }
}
</programlisting>
      </example>

      <para>Where the Person class is a Java bean defined in the following
      class:</para>

      <programlisting language="java">package com.discursive.cjcook.json;

public class Person {

  private String name;
  private Integer age;
  private String city;  

  public Person() {} 
  
  public Person(String name, Integer age, String city) {
    setName( name );
    setAge( age );
    setCity( city );
  }

  public String getName() { return name; }
  public void setName(String name) {
    this.name = name;
  }

  public Integer getAge() { return age; }
  public void setAge(Integer age) {
    this.age = age;
  }

  public String getCity() { return city; }
  public void setCity(String city) { this.city = city; }
}
</programlisting>
    </sect2>
  </sect1>

  <sect1 id="json-sect-parsing-json">
    <title>Parsing JSON</title>

    <sect2>
      <title>Problem</title>

      <para>You need to parse the following JSON.</para>

      <programlisting language="java">{
  'foo':'bar',
  'coolness':2.0,
  'altitude':39000,
  'pilot': {
    'firstName':'Buzz',
    'lastName':'Aldrin'
   },
   'mission':'apollo 11'
}</programlisting>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Load the resource from the classpath and parse this JSON as shown
      in <xref linkend="json-ex-parsing" />.</para>

      <example id="json-ex-parsing">
        <title>Parsing JSON in Java</title>

        <programlisting language="java">package com.discursive.cjcook.json;

import java.io.InputStream;

import net.sf.json.JSONObject;
import net.sf.json.JSONSerializer;

import org.apache.commons.io.IOUtils;

public class ParsingJSON {

    public static void main(String[] args) throws Exception {
        InputStream is = 
                ParsingJSON.class.getResourceAsStream( "sample-json.txt");
        String jsonTxt = IOUtils.toString( is );
        
        JSONObject json = (JSONObject) JSONSerializer.toJSON( jsonTxt );        
        double coolness = json.getDouble( "coolness" );
        int altitude = json.getInt( "altitude" );
        JSONObject pilot = json.getJSONObject("pilot");
        String firstName = pilot.getString("firstName");
        String lastName = pilot.getString("lastName");
        
        System.out.printf( "Coolness: %f\n", coolness );
        System.out.printf( "Altitude: %d\n", altitude );
        System.out.printf( "Pilot: %s %s\n", firstName, lastName );
    }
}
</programlisting>
      </example>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>Note that JSONSerializer returns a JSON object. This is a general
      object which could be a JSONObject or a JSONArray depending on the JSON
      you are trying to parse. In this example, since I know that the JSON is
      a JSONObject, I can cast the result directly to a JSONObject. If you are
      dealing with JSON that could return a JSONArray, you'll likely want to
      check the type of the object that is returned by toJSON.</para>
    </sect2>
  </sect1>

  <sect1 id="json-sect-convert-xml-json">
    <title>Converting XML to JSON</title>

    <sect2>
      <title>Problem</title>

      <para>You need to convert the following XML file to JSON:</para>

      <programlisting language="xml">&lt;important-data certified="true" processed="true"&gt;
  &lt;timestamp&gt;232423423423&lt;/timestamp&gt;
  &lt;authors&gt;
    &lt;author&gt;
      &lt;firstName&gt;Tim&lt;/firstName&gt;
      &lt;lastName&gt;Leary&lt;/lastName&gt;
    &lt;/author&gt;
  &lt;/authors&gt;
  &lt;title&gt;Flashbacks&lt;/title&gt;
  &lt;shippingWeight&gt;1.4 pounds&lt;/shippingWeight&gt;
  &lt;isbn&gt;978-0874778700&lt;/isbn&gt;
&lt;/important-data&gt;</programlisting>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>First you must add the following dependencies: json-lib,
      commons-io, and xom. Here is the syntax for adding these dependencies to
      a Maven POM.</para>

      <example id="json-ex-xml-json-depend">
        <title>Adding Dependencies to Parse XML and Generate JSON</title>

        <programlisting language="xml">&lt;dependency&gt;
  &lt;groupId&gt;net.sf.json-lib&lt;/groupId&gt;
  &lt;artifactId&gt;json-lib&lt;/artifactId&gt;
  &lt;version&gt;2.3&lt;/version&gt;
  &lt;type&gt;jar&lt;/type&gt;
  &lt;classifier&gt;jdk15&lt;/classifier&gt;
  &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
  &lt;artifactId&gt;commons-io&lt;/artifactId&gt;
  &lt;version&gt;1.3.2&lt;/version&gt;
  &lt;type&gt;jar&lt;/type&gt;
  &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;xom&lt;/groupId&gt;
  &lt;artifactId&gt;xom&lt;/artifactId&gt;
  &lt;version&gt;1.1&lt;/version&gt;
&lt;/dependency&gt;
</programlisting>
      </example>

      <para>Load the resource from the classpath and parse this XML into JSON
      as follows:</para>

      <example id="json-ex-xml-json">
        <title>Converting XML to JSON</title>

        <programlisting language="java">package com.discursive.cjcook.json;

import java.io.InputStream;

import net.sf.json.JSON;
import net.sf.json.xml.XMLSerializer;

import org.apache.commons.io.IOUtils;

public class ConvertXMLtoJSON {

  public static void main(String[] args) throws Exception {
    InputStream is = ConvertXMLtoJSON.class
        .getResourceAsStream("sample-xml.xml");
    String xml = IOUtils.toString(is);

    XMLSerializer xmlSerializer = new XMLSerializer();
    JSON json = xmlSerializer.read(xml);
    System.out.println(json.toString(2));
  }
}
</programlisting>
      </example>

      <para>This should produce the following JSON output:</para>

      <programlisting language="java">{
  "@certified": "true",
  "@processed": "true",
  "timestamp": "232423423423",
  "authors": [  {
    "firstName": "Tim",
    "lastName": "Leary"
  }],
  "title": "Flashbacks",
  "shippingWeight": "1.4 pounds",
  "isbn": "978-0874778700"
}</programlisting>
    </sect2>
  </sect1>

  <sect1 id="json-sect-convert-json-xml">
    <title>Converting JSON to XML</title>

    <sect2>
      <title>Problem</title>

      <para>You need to convert the following JSON to XML:</para>

      <programlisting language="java">{'foo':'bar',
 'coolness':2.0,
 'altitude':39000,
 'pilot':{'firstName':'Buzz',
          'lastName':'Aldrin'},
 'mission':'apollo 11'}</programlisting>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>First you must add the following dependencies: json-lib,
      commons-io, and xom. Here is the syntax for adding these dependencies to
      a Maven POM.</para>

      <example id="json-ex-json-xml-depend">
        <title>Adding Dependencies to Parse JSON and Generate XML</title>

        <programlisting language="xml">&lt;dependency&gt;
  &lt;groupId&gt;net.sf.json-lib&lt;/groupId&gt;
  &lt;artifactId&gt;json-lib&lt;/artifactId&gt;
  &lt;version&gt;2.3&lt;/version&gt;
  &lt;type&gt;jar&lt;/type&gt;
  &lt;classifier&gt;jdk15&lt;/classifier&gt;
  &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
  &lt;artifactId&gt;commons-io&lt;/artifactId&gt;
  &lt;version&gt;1.3.2&lt;/version&gt;
  &lt;type&gt;jar&lt;/type&gt;
  &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;xom&lt;/groupId&gt;
  &lt;artifactId&gt;xom&lt;/artifactId&gt;
  &lt;version&gt;1.1&lt;/version&gt;
&lt;/dependency&gt;
</programlisting>
      </example>

      <para>Load the resource from the classpath and parse this XML into JSON
      as follows:</para>

      <example id="json-ex-json-xml">
        <title>Converting JSON to XML</title>

        <programlisting language="java">package com.discursive.cjcook.json;

import java.io.InputStream;

import net.sf.json.JSON;
import net.sf.json.JSONSerializer;
import net.sf.json.xml.XMLSerializer;

import org.apache.commons.io.IOUtils;

public class ConvertJSONtoXML {

  public static void main(String[] args) throws Exception {
    InputStream is = ConvertJSONtoXML.class
        .getResourceAsStream("sample-json.txt");
    String jsonData = IOUtils.toString(is);

    XMLSerializer serializer = new XMLSerializer();
    JSON json = JSONSerializer.toJSON(jsonData);
    String xml = serializer.write(json);
    System.out.println(xml);
  }
}</programlisting>
      </example>

      <para>This should produce the following XML output:</para>

      <programlisting language="xml">&lt;o&gt;
  &lt;altitude type="number"&gt;39000&lt;/altitude&gt;
  &lt;coolness type="number"&gt;2.0&lt;/coolness&gt;
  &lt;foo type="string"&gt;bar&lt;/foo&gt;
  &lt;mission type="string"&gt;apollo 11&lt;/mission&gt;
  &lt;pilot class="object"&gt;
    &lt;firstName type="string"&gt;Buzz&lt;/firstName&gt;
    &lt;lastName type="string"&gt;Aldrin&lt;/lastName&gt;
  &lt;/pilot&gt;
&lt;/o&gt;</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>To get rid of the type hints, use this code instead:</para>

      <example id="json-ex-type-hints">
        <title>Generating XML from JSON without Type Hints</title>

        <programlisting language="java">package com.discursive.cjcook.json;

import java.io.InputStream;

import net.sf.json.JSON;
import net.sf.json.JSONSerializer;
import net.sf.json.xml.XMLSerializer;

import org.apache.commons.io.IOUtils;

public class ConvertJSONtoXMLNoHints {

  public static void main(String[] args) throws Exception {
    InputStream is = ConvertJSONtoXMLNoHints.class
        .getResourceAsStream("sample-json.txt");
    String jsonData = IOUtils.toString(is);

    XMLSerializer serializer = new XMLSerializer();
    JSON json = JSONSerializer.toJSON(jsonData);
    serializer.setTypeHintsEnabled(false);
    String xml = serializer.write(json);
    System.out.println(xml);
  }
}
</programlisting>
      </example>

      <para>The previous class will produce the following XML without type
      hints:</para>

      <programlisting language="xml">&lt;o&gt;
  &lt;altitude&gt;39000&lt;/altitude&gt;
  &lt;coolness&gt;2.0&lt;/coolness&gt;
  &lt;foo&gt;bar&lt;/foo&gt;
  &lt;mission&gt;apollo 11&lt;/mission&gt;
  &lt;pilot&gt;
    &lt;firstName&gt;Buzz&lt;/firstName&gt;
    &lt;lastName&gt;Aldrin&lt;/lastName&gt;
  &lt;/pilot&gt;
&lt;/o&gt;</programlisting>

      <para>"o" isn't a very friendly root node name, is it? To change the
      root node name, use the following code:</para>

      <example id="json-ex-root-name">
        <title>Supplying a Root Name to the XMLSerializer</title>

        <programlisting language="java">package com.discursive.cjcook.json;

import java.io.InputStream;

import net.sf.json.JSON;
import net.sf.json.JSONSerializer;
import net.sf.json.xml.XMLSerializer;

import org.apache.commons.io.IOUtils;

public class ConvertJSONtoXMLSetRoot {

  public static void main(String[] args) throws Exception {
    InputStream is = ConvertJSONtoXMLNoHints.class
        .getResourceAsStream("sample-json.txt");
    String jsonData = IOUtils.toString(is);

    XMLSerializer serializer = new XMLSerializer();
    JSON json = JSONSerializer.toJSON(jsonData);
    serializer.setRootName("SampleJSON");
    serializer.setTypeHintsEnabled(false);
    String xml = serializer.write(json);
    System.out.println(xml);
  }
}
</programlisting>
      </example>

      <para>This previous class will produce the following XML:</para>

      <programlisting language="xml">&lt;SampleJSON&gt;
  &lt;altitude&gt;39000&lt;/altitude&gt;
  &lt;coolness&gt;2.0&lt;/coolness&gt;
  &lt;foo&gt;bar&lt;/foo&gt;
  &lt;mission&gt;apollo 11&lt;/mission&gt;
  &lt;pilot&gt;
    &lt;firstName&gt;Buzz&lt;/firstName&gt;
    &lt;lastName&gt;Aldrin&lt;/lastName&gt;
  &lt;/pilot&gt;
&lt;/SampleJSON&gt;</programlisting>
    </sect2>
  </sect1>

  <sect1>
    <title>Measuring JSON Encoding and Parsing Performance</title>

    <sect2>
      <title>Problem</title>

      <para>You need to justify using JSON in a critical part of your
      architecture. To prove that JSON is an acceptable approach, you will
      need to supply average encoding and parsing times for JSON to and from a
      Java bean.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use the following class to generate simple performance metrics for
      JSON.</para>

      <example id="json-ex-performance">
        <title>Mesuring the Performance of Simple JSON Operations</title>

        <programlisting language="java">package com.discursive.cjcook.json;

import java.util.Date;

import net.sf.json.JSONObject;

public class JSONTiming {

  public static void main(String[] arg) {

    int size = 500000;

    PositionData[] pArray = new PositionData[size];

    long preCreate = (new Date()).getTime();
    for (int i = 0; i &lt; size; i++) {
      PositionData pData = new PositionData();
      pData.setVehicleId(1);
      pData.setTimestamp((new Date()).getTime());
      pData.setAltitude(123.0f);
      pData.setLatitude(1.0f);
      pData.setLongitude(1.0f);
      pData.setSpeed(120);
      pArray[i] = pData;
    }
    long postCreate = (new Date()).getTime();
    float createTime = ((float) (postCreate - preCreate) / (float) size) * 1000 * 1000;

    System.out.printf("Create One PositionData %.0f nanoseconds\n",
        createTime);

    String[] encodedArray = new String[size];
    long preEncode = (new Date()).getTime();
    for (int i = 0; i &lt; size; i++) {
      JSONObject obj = JSONObject.fromObject(pArray[i]);
      String encoded = obj.toString();
      encodedArray[i] = encoded;

    }
    long postEncode = (new Date()).getTime();
    float encodeTime = ((float) (postEncode - preEncode) / (float) size) * 1000;
    System.out.printf(
        "Encode One PositionData to String %.0f microseconds\n",
        encodeTime);

    PositionData[] decodedArray = new PositionData[size];
    long preDecode = (new Date()).getTime();
    for (int i = 0; i &lt; size; i++) {
      JSONObject obj = JSONObject.fromObject( encodedArray[i] );
      PositionData pData = (PositionData) JSONObject.toBean(obj,
          PositionData.class);
      decodedArray[i] = pData;
    }
    long postDecode = (new Date()).getTime();
    float decodeTime = ((float) (postDecode - preDecode) / (float) size) * 1000;
    System.out.printf("Decode One PositionData from String %.0f microseconds\n",
        decodeTime);
  }
}
</programlisting>
      </example>

      <para>Where PositionData is a bean defined in the following
      class:</para>

      <programlisting language="java">package com.discursive.cjcook.json;

public class PositionData {

  private Integer vehicleId;
  private Float latitude;
  private Float longitude;
  private Float altitude;
  private Integer speed;
  private Long timestamp;
  private String status;

  public PositionData() {}

  // Getters and Setters omitted for brevity
}
</programlisting>

      <para>Running this test class will produce the following
      results<footnote>
          <para>...on a mid-level MacBook Pro running JDK 1.6 with a 2 GB
          min/max heap. This performance test is by no means
          scientific.</para>
        </footnote>:</para>

      <screen>Create One PositionData 1234 nanoseconds
Encode One PositionData to String 30 microseconds
Decode One PositionData from String 41 microseconds</screen>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>It takes about a microsecond to create an object and populate a
      few properties. That first number doesn't reflect much beyond simple
      object instantiation and a few setter methods. The interesting numbers
      for JSON performance are the times to encode and decode JSON data to and
      from String objects. Running half a million operations yields a number
      of ~30 microseconds to encode a bean to a JSON string and ~41
      microseconds to parse that string back into a bean instance.</para>

      <para>Comparing these numbers to the performance measurements shown in
      <xref linkend="proto-sect-performance" /> for a similar data element
      encoded and decoded with Protocol Buffers. Protocol Buffers can encode
      data 50x faster than json-lib, and it can decode data 42x faster than
      json-lib. Granted, this isn't an apples to apples comparison. json-lib
      is using reflection to scan the object for properties, and Protocol
      Buffers is using an optimized approach to encoding and decoding.
      json-lib is also storing data as a String where Protocol Buffers is
      storing data in a seriously optimized binary format.</para>

      <para>These performance numbers are certainly not scientific. They were
      not created in a laboratory with a rigorous controls and isolated
      hardware, but they are meant to give you an idea of the relative
      performance of these different tools and parsing libraries.</para>
    </sect2>
  </sect1>
</chapter>
