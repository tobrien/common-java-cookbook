<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.discursive.com/docbook/xml/4.5/docbookx.dtd">
<chapter id="manipulate-text" label="2">
  <title>Manipulating Text</title>

  <sect1 id="manipulate-text-sect-intro">
    <title>Introduction</title>

    <para>Parsing text fell out of fashion when Extensible Markup Language
    (XML) came to town. Java's text manipulation capabilities have only
    recently received some badly overdue attention, with the addition of
    regular expressions and numerous improvements in Java 1.5. Despite the
    improvements, using Java to<indexterm id="manipulate-text-ITERM-1949"
        significance="normal">
        <primary>plain text</primary>

        <seealso>text</seealso>
      </indexterm> manipulate <indexterm id="manipulate-text-ITERM-1950"
        significance="normal">
        <primary>plain text</primary>
      </indexterm>plain text can inspire frustration. Hand a developer a
    fixed-length text file format to parse, and you will hear the groans—"Why
    can't we use something `modern' like XML? I don't want to parse text." And
    while parsing and manipulating text may not build you a sexy resume, there
    is still a need to work with text in any program. For every snazzy XML
    file format, there is a widely accepted text file format with fixed-length
    fields; and for every XML web service, a vendor sends a proprietary feed
    that must be parsed character by character. Text manipulation is a must,
    but the Java 2 Standard Edition (J2SE) leaves developers wanting for more
    convenient ways to slice, dice, chomp, and manipulate text. This chapter
    introduces some simple utilities, which fill a few of Java's many
    gaps.</para>

    <para>The recipes in this chapter deal with a collection of static methods
    on two classes in Commons Lang—<literal
    moreinfo="none">StringUtils</literal> and <literal
    moreinfo="none">WordUtils</literal>. Some of the methods on <literal
    moreinfo="none">StringUtils</literal> have been made obsolete by changes
    introduced in Java 1.4 and Java 1.5, but, regardless, there are times when
    you will want to split a string without regular expressions. Using
    <literal moreinfo="none">StringUtils.chomp( )</literal> achieves more
    readable logic than writing the equivalent logic using the <literal
    moreinfo="none">String.indexOf( )</literal> and <literal
    moreinfo="none">String.substring()</literal> methods. These recipes will
    not change the basic architecture of a system with new, groundbreaking
    technology, but they are valuable "shortcuts" whose benefits will add up
    over time. Simple solutions to common tasks will save minutes of coding
    and hours of maintenance in the long run. Over time, many grow so
    accustomed to the efficiencies gained with Commons Lang, they consider it
    an indispensable supplement to the Java language.</para>

    <para>Read the recipes in this chapter, and take some time to read the
    Javadoc for <literal moreinfo="none">StringUtils</literal> and <literal
    moreinfo="none">WordUtils</literal>. These utility classes provide some
    common string operations missing in Java, and they are simple and
    well-documented. These utilities are so simple that, throughout this
    chapter, you will notice recipes without a Discussion or See Also
    section—it's just not needed! These simple recipes have relevance to all
    skill levels; even if you are an experienced developer, you may be
    surprised at what Commons Lang string manipulation has to offer.</para>
  </sect1>

  <sect1 id="manipulate-text-sect-setting-up" label="2.1" role="Recipe">
    <title>Setting Up StringUtils and WordUtils</title>

    <sect2>
      <title>Problem</title>

      <para>You want the ability to use <literal
      moreinfo="none">StringUtils</literal> <indexterm
          id="manipulate-text-ITERM-1951" significance="normal">
          <primary>StringUtils class</primary>

          <secondary>configuration</secondary>
        </indexterm> <indexterm id="manipulate-text-ITERM-1952"
          significance="normal">
          <primary>classes</primary>

          <secondary>StringUtils</secondary>
        </indexterm> <indexterm id="manipulate-text-ITERM-1953"
          significance="normal">
          <primary>WordUtils class</primary>

          <secondary>configuration</secondary>
        </indexterm> <indexterm id="manipulate-text-ITERM-1954"
          significance="normal">
          <primary>classes</primary>

          <secondary>WordUtils</secondary>
        </indexterm> <indexterm id="manipulate-text-ITERM-1955"
          significance="normal">
          <primary>configuration</primary>

          <secondary>WordUtils class</secondary>
        </indexterm> <indexterm id="manipulate-text-ITERM-1956"
          significance="normal">
          <primary>configuration</primary>

          <secondary>StringUtils class</secondary>
        </indexterm> <indexterm id="manipulate-text-ITERM-1957"
          significance="normal">
          <primary>text</primary>

          <secondary>WordUtils class</secondary>
        </indexterm> <indexterm id="manipulate-text-ITERM-1958"
          significance="normal">
          <primary>text</primary>

          <secondary>StringUtils class</secondary>
        </indexterm> and <literal moreinfo="none">WordUtils</literal> to
      manipulate text.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>To download the latest version of Commons Lang, refer to the steps
      outlined in <link linkend="lang-sect-obtaining">Recipe
      1.1</link>.</para>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>This chapter focuses on a very small subset of the Commons Lang
      project—<literal moreinfo="none">StringUtils</literal> and <literal
      moreinfo="none">WordUtils</literal>. To use either <literal
      moreinfo="none">StringUtils</literal> or <literal
      moreinfo="none">WordUtils</literal> in a Java class, add the following
      lines to your import statements:</para>

      <programlisting language="java" format="linespecific" id="I_2_tt50">import org.apache.commons.lang.StringUtils;
import org.apache.commons.lang.WordUtils;</programlisting>

      <para>Recipes that use <literal moreinfo="none">StringUtils</literal>
      and <literal moreinfo="none">WordUtils</literal> in this chapter will
      omit these import statements in code fragments. When <literal
      moreinfo="none">StringUtils</literal> or <literal
      moreinfo="none">WordUtils</literal> appears in an example, assume that
      it has already been imported.</para>
    </sect2>
  </sect1>

  <sect1 id="manipulate-text-sect-checking-empty" label="2.2" role="Recipe">
    <title>Checking for an Empty String</title>

    <sect2>
      <title>Problem</title>

      <para>You need to test for an empty or<indexterm class="startofrange"
          id="manipulate-text-ITERM-1959" significance="normal">
          <primary>text</primary>

          <secondary>StringUtils class</secondary>

          <tertiary>testing empty strings</tertiary>
        </indexterm> <indexterm class="startofrange"
          id="manipulate-text-ITERM-1960" significance="normal">
          <primary>StringUtils class</primary>

          <secondary>text</secondary>

          <tertiary>testing empty strings</tertiary>
        </indexterm> <indexterm class="startofrange"
          id="manipulate-text-ITERM-1961" significance="normal">
          <primary>testing</primary>

          <secondary>empty strings</secondary>
        </indexterm> <indexterm class="startofrange"
          id="manipulate-text-ITERM-1962" significance="normal">
          <primary>empty strings, testing</primary>
        </indexterm> <indexterm class="startofrange"
          id="manipulate-text-ITERM-1963" significance="normal">
          <primary>strings</primary>

          <secondary>empty, testing</secondary>
        </indexterm> <indexterm class="startofrange"
          id="manipulate-text-ITERM-1964" significance="normal">
          <primary>null strings, testing</primary>
        </indexterm> <literal moreinfo="none">null</literal> string.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use <literal moreinfo="none">StringUtils.isBlank()</literal>
      <indexterm id="manipulate-text-ITERM-1965" significance="normal">
          <primary>StringUtils.isBlank( ) method</primary>
        </indexterm> <indexterm id="manipulate-text-ITERM-1966"
          significance="normal">
          <primary>methods</primary>

          <secondary>StringUtils.isBlank( )</secondary>
        </indexterm>. This method will return true if it is supplied with an
      empty, zero length, or whitespace-only string. This method gracefully
      handles a <literal moreinfo="none">null</literal> input by returning
      true. The following example demonstrates <literal
      moreinfo="none">isBlank( )</literal> with four strings:</para>

      <programlisting language="java" format="linespecific" id="I_2_tt51">String test = "";
String test2 = "\n\n\t";
String test3 = null;
String test4 = "Test";

System.out.println( "test blank? " + StringUtils.isBlank( test ) );
System.out.println( "test2 blank? " + StringUtils.isBlank( test2 ) );
System.out.println( "test3 blank? " + StringUtils.isBlank( test3 ) );
System.out.println( "test4 blank? " + StringUtils.isBlank( test4 ) );</programlisting>

      <para>All four strings are tested, and the following output is
      produced:</para>

      <programlisting format="linespecific" id="I_2_tt52">test blank? true
test2 blank? true
test3 blank? true
test4 blank? false</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>Checking for nonblank strings is just as easy; <literal
      moreinfo="none">StringUtils.isNotBlank( )</literal> will return the
      compliment of <literal moreinfo="none">isBlank( )</literal>. If a string
      is empty, contains only whitespace, or is <literal
      moreinfo="none">null</literal>, the <literal
      moreinfo="none">StringUtils.isNotBlank( )</literal> method will return
      false. This method comes in handy when a process expects a certain
      string to have content, and it gracefully handles a <literal
      moreinfo="none">null</literal> input by returning false:</para>

      <programlisting language="java" format="linespecific" id="I_2_tt53">String test = "\t\t";
String test2 = "Test";

System.out.println( "test is not blank? " + StringUtils.isNotBlank( test ) );
System.out.println( "test2 is not blank? " + StringUtils.isNotBlank( test2 ) );</programlisting>

      <para>This produces the following output, which shows that a string
      containing only whitespace is considered blank:</para>

      <programlisting format="linespecific" id="I_2_tt54">test is not blank? false
test2 is not blank? true</programlisting>

      <para>Another method to test for an empty string is to "trim" a string
      to <literal moreinfo="none">null</literal> if it contains only
      whitespace, and then test to see if the trimmed result is <literal
      moreinfo="none">null</literal>. Use <literal
      moreinfo="none">StringUtils.trimToNull( )</literal> to transform empty
      strings to <literal moreinfo="none">null</literal>. This method handles
      a <literal moreinfo="none">null</literal> parameter value by returning
      <literal moreinfo="none">null</literal>.</para>

      <programlisting language="java" format="linespecific" id="I_2_tt55">String test1 = "\t";
String test2 = "Test";
String test3 = null;

System.out.println( "test1 trimToNull: " + StringUtils.trimToNull( test1 ) );
System.out.println( "test2 trimToNull: " + StringUtils.trimToNull( test2 ) );
System.out.println( "test3 trimToNull: " + StringUtils.trimToNull( test3 ) );</programlisting>

      <para>This produces the following output, which shows that a string
      containing only whitespace is trimmed to <literal
      moreinfo="none">null</literal>:</para>

      <programlisting format="linespecific" id="I_2_tt56">test1 trimToNull: null
test2 trimToNull: Test
test3 trimToNull: null</programlisting>

      <para>These three methods are laughably simple, but they will serve to
      reduce the amount of complexity in a system that needs to test strings.
      Use the methods from this recipe to avoid writing code to test for a
      <literal moreinfo="none">null</literal>, and check the length of a
      string:</para>

      <programlisting language="java" format="linespecific" id="I_2_tt57">if( variable != null &amp;&amp; 
    variable.length( ) &gt; 0 &amp;&amp; 
    !variable.trim( ).equals("") ) {
        // Do something
}</programlisting>

      <para>The code above can be rewritten with one call to <literal
      moreinfo="none">StringUtils.isNotBlank( )</literal>:</para>

      <programlisting language="java" format="linespecific" id="I_2_tt58">if( StringUtils.isNotBlank( variable ) ) {
    // Do something
}</programlisting>

      <para>It is good practice to avoid using <literal
      moreinfo="none">null</literal> whenever possible; code that uses
      <literal moreinfo="none">null</literal> to signify emptiness or an error
      condition is harder to maintain and more likely to throw a nasty
      <literal moreinfo="none">NullPointerException</literal>. Worse yet are
      methods that return a <literal moreinfo="none">null</literal> whenever a
      problem occurs or an exception is thrown. While <literal
      moreinfo="none">trimToNull()</literal> can accomplish the goal, it does
      increase the occurrence of <literal moreinfo="none">null</literal>s in
      code; <indexterm class="endofrange" id="manipulate-text-ITERM-1967"
      significance="normal" startref="manipulate-text-ITERM-1959"></indexterm>
      <indexterm class="endofrange" id="manipulate-text-ITERM-1968"
      significance="normal" startref="manipulate-text-ITERM-1960"></indexterm>
      <indexterm class="endofrange" id="manipulate-text-ITERM-1969"
      significance="normal" startref="manipulate-text-ITERM-1961"></indexterm>
      <indexterm class="endofrange" id="manipulate-text-ITERM-1970"
      significance="normal" startref="manipulate-text-ITERM-1962"></indexterm>
      <indexterm class="endofrange" id="manipulate-text-ITERM-1971"
      significance="normal" startref="manipulate-text-ITERM-1963"></indexterm>
      <indexterm class="endofrange" id="manipulate-text-ITERM-1972"
      significance="normal"
      startref="manipulate-text-ITERM-1964"></indexterm>use <literal
      moreinfo="none">isBlank( )</literal> and <literal
      moreinfo="none">isNotBlank( )</literal> to excise dangerous <literal
      moreinfo="none">null</literal>s from your code.</para>
    </sect2>
  </sect1>

  <sect1 id="manipulate-text-sect-abbreviating" label="2.3" role="Recipe">
    <title>Abbreviating Strings</title>

    <sect2>
      <title>Problem</title>

      <para>You want to abbreviate a string.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use <literal moreinfo="none">StringUtils.abbreviate()</literal>
      <indexterm id="manipulate-text-ITERM-1973" significance="normal">
          <primary>StringUtils.abbreviate( ) method</primary>
        </indexterm> <indexterm id="manipulate-text-ITERM-1974"
          significance="normal">
          <primary>methods</primary>

          <secondary>StringUtils.abbreviate( )</secondary>
        </indexterm>. Supply<indexterm id="manipulate-text-ITERM-1975"
          significance="normal">
          <primary>text</primary>

          <secondary>StringUtils class</secondary>

          <tertiary>abbreviating strings</tertiary>
        </indexterm> <indexterm id="manipulate-text-ITERM-1976"
          significance="normal">
          <primary>StringUtils class</primary>

          <secondary>text</secondary>

          <tertiary>abbreviating strings</tertiary>
        </indexterm> <indexterm id="manipulate-text-ITERM-1977"
          significance="normal">
          <primary>abbreviating strings</primary>
        </indexterm> <indexterm id="manipulate-text-ITERM-1978"
          significance="normal">
          <primary>strings</primary>

          <secondary>abbreviating</secondary>
        </indexterm> <indexterm id="manipulate-text-ITERM-1979"
          significance="normal">
          <primary>characters</primary>

          <secondary>abbreviating</secondary>
        </indexterm> the string to abbreviate, and the maximum allowed length
      for the abbreviation. The following example will abbreviate the supplied
      text messages to 10 characters:</para>

      <programlisting language="java" format="linespecific" id="I_2_tt59">String test = "This is a test of the abbreviation."
String test2 = "Test"

System.out.println( StringUtils.abbreviate( test, 10 ) );
System.out.println( StringUtils.abbreviate( test2, 10 ) );</programlisting>

      <para>Here is the output of two string abbreviations:</para>

      <programlisting format="linespecific" id="I_2_tt60">This is...
Test</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para><literal moreinfo="none">StringUtils.abbreviate( )</literal> takes
      a string and abbreviates it, if necessary. When abbreviating to 20
      characters, if the text is less than 20 characters, the method simply
      returns the original text. If the text is greater than 20 characters,
      the method displays 17 characters followed by three ellipses.
      Abbreviating a piece of text to 20 characters guarantees that the text
      will occupy 20 characters or less:</para>

      <programlisting language="java" format="linespecific" id="I_2_tt61">String message = "Who do you think you are?";
String abbrev = StringUtils.abbreviate( message, 20 );
String message2 = "Testing";
String abbrev2 = StringUtils.abbreviate( message, 40 );
System.out.println( "Subject: " + message );
System.out.println( "Subject2: " + messages2);</programlisting>

      <para>This simple example abbreviates the first message variable,
      <literal moreinfo="none">message</literal>, to "Who do you think...?"
      The second message variable, <literal
      moreinfo="none">message2</literal>, is not affected by the abbreviation
      because it is less than 40 characters long; <literal
      moreinfo="none">abbrev2</literal> will equal the contents of <literal
      moreinfo="none">message2</literal>.</para>

      <para><literal moreinfo="none">StringUtils.abbreviate( )</literal> can
      also abbreviate text at an offset within a string. If you are writing an
      application that searches for a given word and prints that word out in
      context, you can use the <literal
      moreinfo="none">StringUtils.abbreviate( )</literal> method to print the
      context in which a word appears:</para>

      <programlisting language="java" format="linespecific" id="I_2_tt62">String message = "There was a palpable sense that the rest of the world " +
                 "might, one day, cease to exist. In the midst of the " +
                 "confusion - the absence of firm ground - something would " +
                 "fail to recover. The whole city is still, in a way, " +
                 "holding it's breath, hoping the the worst has come and " +
                 "gone.";
int index = message.indexOf( "ground" );
int offset = index - 20;
int width = 20 + message.length( );

<userinput moreinfo="none">String context = StringUtils.abbreviate(message, offset, width); </userinput>
               <userinput moreinfo="none">System.out.println( "The word 'ground' in context: " + context );</userinput>
            </programlisting>

      <para>The output of this example is:</para>

      <programlisting format="linespecific" id="I_2_tt63">The word 'ground' in context: ... absence of firm ground, something would...</programlisting>

      <para>This code attempts to locate "ground." Once the index of the word
      has been located, an offset abbreviation is used to show the context of
      the word. The <literal moreinfo="none">offset</literal> parameter tells
      <literal moreinfo="none">StringUtils.abbreviate( )</literal> to start at
      a specific index in the string. Once the index of "ground" has been
      found, an offset and a width are computed to print 20 characters before
      and after the word "ground."</para>

      <para>If an offset is less than four, output will start from the
      beginning of a string. If the offset is greater than four, the first
      three characters will be ellipses.</para>

      <warning id="manipulate-text-NOTE-51" role="ora">
        <para>If a width less than four is specified, <literal
        moreinfo="none">abbreviate()</literal> will throw an <literal
        moreinfo="none">IllegalArgumentException</literal>. A width less than
        four does not give the <literal moreinfo="none">abbreviate(
        )</literal> method enough room to print ellipses and content.</para>
      </warning>
    </sect2>
  </sect1>

  <sect1 id="manipulate-text-sect-splitting" label="2.4" role="Recipe">
    <title>Splitting a String</title>

    <sect2>
      <title>Problem</title>

      <para>You want to split a string on a<indexterm
          id="manipulate-text-ITERM-1980" significance="normal">
          <primary>text</primary>

          <secondary>StringUtils class</secondary>

          <tertiary>splitting strings</tertiary>
        </indexterm> <indexterm id="manipulate-text-ITERM-1981"
          significance="normal">
          <primary>StringUtils class</primary>

          <secondary>text</secondary>

          <tertiary>splitting strings</tertiary>
        </indexterm> <indexterm id="manipulate-text-ITERM-1982"
          significance="normal">
          <primary>splitting</primary>

          <secondary>strings</secondary>
        </indexterm> <indexterm id="manipulate-text-ITERM-1983"
          significance="normal">
          <primary>strings</primary>

          <secondary>splitting</secondary>
        </indexterm> <indexterm id="manipulate-text-ITERM-1984"
          significance="normal">
          <primary>characters</primary>

          <secondary>splitting</secondary>
        </indexterm> number of different character delimiters.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use <literal moreinfo="none">StringUtils.split()</literal>
      <indexterm id="manipulate-text-ITERM-1985" significance="normal">
          <primary>StringUtils.split( ) method</primary>
        </indexterm> <indexterm id="manipulate-text-ITERM-1986"
          significance="normal">
          <primary>methods</primary>

          <secondary>StringUtils.split( )</secondary>
        </indexterm>, and supply a series of characters to split upon. The
      following example demonstrates splitting strings of a comma and a
      space:</para>

      <programlisting language="java" format="linespecific" id="I_2_tt64">import org.apache.commons.lang.ArrayUtils;

String input = "Frantically oblong";
String input2 = "Pharmacy, basketball,funky";
 
String[] array1 = StringUtils.split( input, " ,", 2 );
String[] array2 = StringUtils.split( input2, " ,", 2 );

System.out.println( ArrayUtils.toString( array1 ) );
System.out.println( ArrayUtils.toString( array2 ) );</programlisting>

      <para>This produces the output:</para>

      <programlisting format="linespecific" id="I_2_tt65">{ "Frantically", "oblong" }
{ "Pharmacy", "basketball" }</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>The <literal moreinfo="none">StringUtils.split( )</literal>
      function does not return empty strings for adjacent delimiters. A number
      of different delimiters can be specified by passing in a string with a
      space and a comma. This last example limited the number of tokens
      returned by split with a third parameter to <literal
      moreinfo="none">StringUtils.split()</literal>. The <literal
      moreinfo="none">input2</literal> variable contains three possible
      tokens, but the split function only returns an array of two
      elements.</para>

      <para>The most recent version of J2SE 1.4 has a <literal
      moreinfo="none">String.split()</literal> method, but the lack of
      <literal moreinfo="none">split( )</literal> in previous versions was an
      annoyance. To split a string in the old days, one had to instantiate a
      <literal moreinfo="none">StringTokenizer</literal>, and iterate through
      an <literal moreinfo="none">Enumeration</literal> to get the components
      of a delimited string. Anyone who has programmed in Perl and then had to
      use the <literal moreinfo="none">StringTokenizer</literal> class will
      tell you that programming without <literal moreinfo="none">split(
      )</literal> is time consuming and frustrating. If you are stuck with an
      older Java Development Kit (JDK), <literal
      moreinfo="none">StringUtils</literal> adds a split function that returns
      an <literal moreinfo="none">Object</literal> array. Keep this in mind
      when you question the need for <literal
      moreinfo="none">StringUtils.split()</literal>; there are still
      applications and platforms that do not have a stable 1.4 virtual
      machine.</para>

      <para>The J2SE 1.4 <literal moreinfo="none">String</literal> class has a
      <literal moreinfo="none">split()</literal> method, but it takes a
      regular expression. Regular expressions are exceedingly powerful tools,
      but, for some tasks, regular expressions are needlessly complex. One
      regular expression to match either a space character or a comma
      character is <literal moreinfo="none">[' '',']</literal>. I'm sure there
      are a thousand other ways to match a space or a comma in a regular
      expression, but, in this example, you simply want to split a string on
      one of two characters:</para>

      <programlisting language="java" format="linespecific" id="I_2_tt66">String test = "One, Two Three, Four Five";
String[] tokens = test.split( "[' '',']" );

System.out.println( ArrayUtils.toString( tokens );</programlisting>

      <para>This example prints out the tokens array:</para>

      <programlisting format="linespecific" id="I_2_tt67">{ "One", "", "Two", "Three", "", "Four", "Five" }</programlisting>

      <para>The array the previous example returns has blanks; the <literal
      moreinfo="none">String.split( )</literal> method returns empty strings
      for adjacent delimiters. This example also uses a rather ugly regular
      expression involving brackets and single quotes. Don't get me wrong,
      regular expressions are a welcome addition in Java 1.4, but the same
      requirements can be satisfied using <literal
      moreinfo="none">StringUtils.split(" .")</literal>—a simpler way to split
      a piece of text.</para>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>Note the use of <literal moreinfo="none">ArrayUtils.toString(
      )</literal> in the solution section. See <link linkend="lang">Chapter
      1</link> for more information about <literal
      moreinfo="none">ArrayUtils</literal> in Commons Lang.</para>
    </sect2>
  </sect1>

  <sect1 id="manipulate-text-sect-finding-nested" label="2.5" role="Recipe">
    <title>Finding Nested Strings</title>

    <sect2>
      <title>Problem</title>

      <para>You want to locate strings nested <indexterm
          id="manipulate-text-ITERM-1987" significance="normal">
          <primary>text</primary>

          <secondary>StringUtils class</secondary>

          <tertiary>searching nested strings</tertiary>
        </indexterm> <indexterm id="manipulate-text-ITERM-1988"
          significance="normal">
          <primary>StringUtils class</primary>

          <secondary>text</secondary>

          <tertiary>searching nested strings</tertiary>
        </indexterm> <indexterm id="manipulate-text-ITERM-1989"
          significance="normal">
          <primary>searching</primary>

          <secondary>strings</secondary>
        </indexterm> <indexterm id="manipulate-text-ITERM-1990"
          significance="normal">
          <primary>strings</primary>

          <secondary>searching</secondary>
        </indexterm> <indexterm id="manipulate-text-ITERM-1991"
          significance="normal">
          <primary>nested strings, searching</primary>
        </indexterm>within other strings.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use <literal moreinfo="none">StringUtils.substringBetween(
      )</literal>. This method will return a string surrounded by two strings,
      which are supplied as parameters. The following example demonstrates the
      use of this method to extract content from HTML:</para>

      <programlisting language="java" format="linespecific" id="I_2_tt68">String htmlContent = "&lt;html&gt;\n" +
                     "  &lt;head&gt;\n" +
                     "    &lt;title&gt;Test Page&lt;/title&gt;\n" +
                     "  &lt;/head&gt;\n" +
                     "  &lt;body&gt;\n" +
                     "    &lt;p&gt;This is a TEST!&lt;/p&gt;\n" +
                     "  &lt;/body&gt;\n" +
                     "&lt;/html&gt;";

// Extract the title from this XHTML content 
<emphasis role="bold">String title = StringUtils.substringBetween(htmlContent, "&lt;title&gt;", 
"&lt;/title&gt;");</emphasis>

System.out.println( "Title: " + title );</programlisting>

      <para>This code extracts the title from this HTML document and prints
      the following:</para>

      <programlisting format="linespecific" id="I_2_tt69">Title: Test Page</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>In the Solution section, the <literal
      moreinfo="none">substringBetween()</literal> <indexterm
          id="manipulate-text-ITERM-1992" significance="normal">
          <primary>substringBetween( ) method</primary>
        </indexterm> <indexterm id="manipulate-text-ITERM-1993"
          significance="normal">
          <primary>methods</primary>

          <secondary>substringBetween( )</secondary>
        </indexterm> method returns the first string between the <literal
      moreinfo="none">open</literal> and <literal
      moreinfo="none">close</literal> strings—the title of an HTML document.
      The previous example only contained one nested element, but what happens
      when a string contains multiple elements nested in the same two strings?
      In the following example, three variables are extracted from a string
      using <literal moreinfo="none">substringBetween( )</literal>:</para>

      <programlisting language="java" format="linespecific" id="I_2_tt70">String variables = "{45}, {35}, {120}" ;
List numbers = new ArrayList( );

String variablesTemp = variables;
while( StringUtils.substringBetween( variablesTemp, "{", "}" ) != null ) {
    String numberStr = StringUtils.substringBetween( variables, "{", "}" );
    Double number = new Double( numberStr );
    numbers.add( number );
    variablesTemp = variablesTemp.substring( variablesTemp.indexOf(",") );
}

double sum = StatUtil.sum( ArrayUtils.toPrimitive( numbers.toArray( ) ) );
System.out.println( "Variables: " + variables + ", Sum: " + sum );</programlisting>

      <para>The output of this example is:</para>

      <programlisting format="linespecific" id="I_2_tt71">Variable: {45}, {35}, {120}, Sum: 200</programlisting>

      <para>After each number is extracted from the curly braces, the system
      finds the index of the next comma and reduces the size of the string to
      search for the next call to <literal
      moreinfo="none">StringUtils</literal>.</para>

      <para><literal moreinfo="none">StringUtils.substringBetween( )</literal>
      can also find text that is delimited by the same character:</para>

      <programlisting language="java" format="linespecific" id="I_2_tt72">String message = "|TESTING| BOUNDARYExampleBOUNDARY";
String first = StringUtils.substringBetween( message, "|"); 
String second = StringUtils.substringBetween( message, "BOUNDARY");</programlisting>

      <para>The first string would return "TESTING" as it is between the
      <literal moreinfo="none">|</literal> characters, and the second string
      would contain "Example."</para>
    </sect2>
  </sect1>

  <sect1 id="manipulate-text-sect-stripping-trimming" label="2.6"
         role="Recipe">
    <title>Stripping and Trimming a String</title>

    <sect2>
      <title>Problem</title>

      <para>You need to strip or trim a string<indexterm
          id="manipulate-text-ITERM-1994" significance="normal">
          <primary>text</primary>

          <secondary>StringUtils class</secondary>

          <tertiary>stripping strings</tertiary>
        </indexterm> <indexterm id="manipulate-text-ITERM-1995"
          significance="normal">
          <primary>StringUtils class</primary>

          <secondary>text</secondary>

          <tertiary>stripping strings</tertiary>
        </indexterm> <indexterm id="manipulate-text-ITERM-1996"
          significance="normal">
          <primary>stripping strings</primary>
        </indexterm> <indexterm id="manipulate-text-ITERM-1997"
          significance="normal">
          <primary>strings</primary>

          <secondary>stripping</secondary>
        </indexterm> <indexterm id="manipulate-text-ITERM-1998"
          significance="normal">
          <primary>whitespace</primary>

          <secondary>stripping</secondary>
        </indexterm> <indexterm id="manipulate-text-ITERM-1999"
          significance="normal">
          <primary>characters</primary>

          <secondary>stripping</secondary>
        </indexterm> of extraneous <indexterm id="manipulate-text-ITERM-2000"
          significance="normal">
          <primary>text</primary>

          <secondary>StringUtils class</secondary>

          <tertiary>trimming strings</tertiary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2001"
          significance="normal">
          <primary>StringUtils class</primary>

          <secondary>text</secondary>

          <tertiary>trimming strings</tertiary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2002"
          significance="normal">
          <primary>trimming strings</primary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2003"
          significance="normal">
          <primary>strings</primary>

          <secondary>trimming</secondary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2004"
          significance="normal">
          <primary>whitespace</primary>

          <secondary>trimming</secondary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2005"
          significance="normal">
          <primary>characters</primary>

          <secondary>trimming</secondary>
        </indexterm>whitespace, control characters, or other specified
      characters.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para><literal moreinfo="none">StringUtils.trim()</literal> <indexterm
          id="manipulate-text-ITERM-2006" significance="normal">
          <primary>StringUtils.trim( ) method</primary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2007"
          significance="normal">
          <primary>methods</primary>

          <secondary>StringUtils.trim( )</secondary>
        </indexterm> takes a string and removes every whitespace and control
      character from the beginning and the end:</para>

      <programlisting language="java" format="linespecific" id="I_2_tt73">String test1 = " \a\r Testing 1 2 3 ";
String test2 = " \r\n ";
 
String trimTest1 = StringUtils.trim( test1 );
String trimTest2 = StringUtils.trimToNull( test2 );

System.out.println( trimTest1 );
System.out.println( trimTest2 );</programlisting>

      <para>This code produces the following result. The <literal
      moreinfo="none">test1</literal> variable is trimmed of leading and
      trailing whitespace, and the <literal moreinfo="none">test2</literal>
      variable is trimmed to <literal moreinfo="none">null</literal>:</para>

      <programlisting format="linespecific" id="I_2_tt74">Testing 1 2 3
null</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>A <filename moreinfo="none">control character</filename>
      <indexterm id="manipulate-text-ITERM-2008" significance="normal">
          <primary>control characters</primary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2009"
          significance="normal">
          <primary>characters</primary>

          <secondary>control</secondary>
        </indexterm> is defined as all characters below 32 on the ASCII
      table—everything from <literal moreinfo="none">0</literal> <literal
      moreinfo="none">(NUL)</literal> to <literal moreinfo="none">31</literal>
      <literal moreinfo="none">(unit</literal> <literal
      moreinfo="none">separator)</literal>. <literal
      moreinfo="none">StringUtils.trim( )</literal> delegates to the <literal
      moreinfo="none">trim( )</literal> function on <literal
      moreinfo="none">String</literal> and gracefully handles <literal
      moreinfo="none">null</literal>. When you pass a <literal
      moreinfo="none">null</literal> to <literal
      moreinfo="none">StringUtils.trim( )</literal>, it returns a <literal
      moreinfo="none">null</literal>.</para>

      <sect3>
        <title>Stripping a string</title>

        <para>If a string contains leading and trailing characters to be
        removed, you can remove them with <literal
        moreinfo="none">StringUtils.strip( )</literal>. The <literal
        moreinfo="none">strip( )</literal> method differs from <literal
        moreinfo="none">trim( )</literal> in that you can specify a set of
        characters to strip from the beginning and end of a string. In this
        example, dashes and asterisks are stripped from the start and end of a
        string:</para>

        <programlisting language="java" format="linespecific" id="I_2_tt75">String original = "-------***---SHAZAM!---***-------";
String stripped = StringUtils.strip( original, "-*" );

System.out.println( "Stripped: " + stripped )</programlisting>

        <para>This produces the following output:</para>

        <programlisting format="linespecific" id="I_2_tt76">Stripped: SHAZAM!</programlisting>
      </sect3>

      <sect3>
        <title>Trimming to null</title>

        <para>Use <literal moreinfo="none">trimToNull( )</literal> <indexterm
            id="manipulate-text-ITERM-2010" significance="normal">
            <primary>trimToNull( ) method</primary>
          </indexterm> <indexterm id="manipulate-text-ITERM-2011"
            significance="normal">
            <primary>methods</primary>

            <secondary>trimToNull( )</secondary>
          </indexterm> <indexterm id="manipulate-text-ITERM-2012"
            significance="normal">
            <primary>nulls</primary>

            <secondary>trimming to</secondary>
          </indexterm> to test if a given parameter is present. Take the
        following servlet code as an example:</para>

        <programlisting language="java" format="linespecific" id="I_2_tt77">public void doGet(HttpServletRequest request, HttpServletResponse response)
    throws IOException, ServletException {

    String companyName = 
        StringUtils.trimToNull( request.getParameter("companyName") );
    if( companyName != null ) {
        response.getWriter( ).write( "You supplied a company name!" );
    }
}</programlisting>

        <para>Using <literal moreinfo="none">StringUtils</literal> reduces
        code complexity incrementally—four or five lines of code at a time.
        Testing for the absence or emptiness of a string usually entails
        checking to see if a string is empty or of zero length, and because a
        string could be <literal moreinfo="none">null</literal>, you always
        need to check for <literal moreinfo="none">null</literal> to avoid
        throwing a <literal moreinfo="none">NullPointerException</literal>. In
        this last example, empty has the same meaning as <literal
        moreinfo="none">null</literal>—the <literal
        moreinfo="none">StringUtils.trimToNull( )</literal> method takes a
        string as a parameter, and if it is <literal
        moreinfo="none">null</literal> or empty, the method returns a <literal
        moreinfo="none">null</literal>.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="manipulate-text-sect-chomping" label="2.7" role="Recipe">
    <title>Chomping a String</title>

    <sect2>
      <title>Problem</title>

      <para>You need to remove a<indexterm id="manipulate-text-ITERM-2013"
          significance="normal">
          <primary>text</primary>

          <secondary>StringUtils class</secondary>

          <tertiary>chomping strings</tertiary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2014"
          significance="normal">
          <primary>StringUtils class</primary>

          <secondary>text</secondary>

          <tertiary>chomping strings</tertiary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2015"
          significance="normal">
          <primary>chomping strings</primary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2016"
          significance="normal">
          <primary>strings</primary>

          <secondary>chomping</secondary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2017"
          significance="normal">
          <primary>deleting</primary>

          <secondary>newlines</secondary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2018"
          significance="normal">
          <primary>newlines, deleting</primary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2019"
          significance="normal">
          <primary>carriage returns, deleting</primary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2020"
          significance="normal">
          <primary>deleting</primary>

          <secondary>carriage returns</secondary>
        </indexterm> trailing <indexterm id="manipulate-text-ITERM-2021"
          significance="normal">
          <primary>trailing newlines, deleting</primary>
        </indexterm>newline or carriage return from a string.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use<indexterm id="manipulate-text-ITERM-2022"
          significance="normal">
          <primary>StringUtils.chomp( ) method</primary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2023"
          significance="normal">
          <primary>methods</primary>

          <secondary>StringUtils.chomp( )</secondary>
        </indexterm> <literal moreinfo="none">StringUtils.chomp( )</literal>
      to remove the last line termination sequence from a string:</para>

      <programlisting language="java" format="linespecific" id="I_2_tt78">String input = "Hello\n";
String chomped = StringUtils.chomp( input );
// chomped equals "Hello"

String input2 = "Another test\r\n";
String chomped2 = StringUtils.chomp( input2 );
// chomped2 equals "Another test";</programlisting>
    </sect2>
  </sect1>

  <sect1 id="manipulate-text-sect-emphasis" label="2.8" role="Recipe">
    <title>Creating an Emphasized Header</title>

    <sect2>
      <title>Problem</title>

      <para>You would like to print an <indexterm
          id="manipulate-text-ITERM-2024" significance="normal">
          <primary>text</primary>

          <secondary>StringUtils class</secondary>

          <tertiary>printing headers</tertiary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2025"
          significance="normal">
          <primary>StringUtils class</primary>

          <secondary>text</secondary>

          <tertiary>printing headers</tertiary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2026"
          significance="normal">
          <primary>headers</primary>

          <secondary>printing</secondary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2027"
          significance="normal">
          <primary>printing</primary>

          <secondary>headers</secondary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2028"
          significance="normal">
          <primary>emphasized headers, creating</primary>
        </indexterm>attention-grabbing header.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Combine the powers of <literal
      moreinfo="none">StringUtils.repeat()</literal> <indexterm
          id="manipulate-text-ITERM-2029" significance="normal">
          <primary>StringUtils.repeat( ) method</primary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2030"
          significance="normal">
          <primary>methods</primary>

          <secondary>StringUtils.repeat( )</secondary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2031"
          significance="normal">
          <primary>StringUtils.center( ) method</primary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2032"
          significance="normal">
          <primary>methods</primary>

          <secondary>StringUtils.center( )</secondary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2033"
          significance="normal">
          <primary>StringUtils.join( ) method</primary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2034"
          significance="normal">
          <primary>methods</primary>

          <secondary>StringUtils.join( )</secondary>
        </indexterm>, <literal moreinfo="none">StringUtils.center(
      )</literal>, and <literal moreinfo="none">StringUtils.join( )</literal>
      to create a textual header. The following example demonstrates the use
      of these three methods to create a header:</para>

      <programlisting language="java" format="linespecific" id="I_2_tt79">public String createHeader( String title ) {
    int width = 30;
    // Construct heading using StringUtils: repeat( ), center( ), and join( )
    String stars = StringUtils.repeat( "*", width);
    String centered = StringUtils.center( title, width, "*" );
    String heading = 
        StringUtils.join(new Object[]{stars, centered, stars}, "\n");
    return heading;
}</programlisting>

      <para>Here's the output of <literal
      moreinfo="none">createHeader("TEST")</literal>:</para>

      <programlisting format="linespecific" id="I_2_tt80">******************************
************ TEST ************
******************************</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>In the example, <literal moreinfo="none">StringUtils.repeat(
      )</literal> creates the top and bottom rows with <literal
      moreinfo="none">StringUtils.repeat("*", 30)</literal>, creating a string
      with 30 consecutive <literal moreinfo="none">*</literal> characters.
      Calling <literal moreinfo="none">StringUtils.center(title, width,
      "*")</literal> creates a middle line with the header title centered and
      surrounded by <literal moreinfo="none">*</literal> characters. <literal
      moreinfo="none">StringUtils.join()</literal> joins the lines together
      with the newline characters, and out pops a header.</para>
    </sect2>
  </sect1>

  <sect1 id="manipulate-text-sect-reverse" label="2.9" role="Recipe">
    <title>Reversing a String</title>

    <sect2>
      <title>Problem</title>

      <para>You need to reverse<indexterm id="manipulate-text-ITERM-2035"
          significance="normal">
          <primary>text</primary>

          <secondary>StringUtils class</secondary>

          <tertiary>reversing strings</tertiary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2036"
          significance="normal">
          <primary>StringUtils class</primary>

          <secondary>text</secondary>

          <tertiary>reversing strings</tertiary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2037"
          significance="normal">
          <primary>reversing</primary>

          <secondary>strings</secondary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2038"
          significance="normal">
          <primary>strings</primary>

          <secondary>reversing</secondary>
        </indexterm> a string.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use<indexterm id="manipulate-text-ITERM-2039"
          significance="normal">
          <primary>StringUtils.reverse( ) method</primary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2040"
          significance="normal">
          <primary>methods</primary>

          <secondary>StringUtils.reverse( )</secondary>
        </indexterm> <literal moreinfo="none">StringUtils.reverse(
      )</literal>. Supply a string parameter to this method, and it will
      return a reversed copy. The following example reverses two
      strings:</para>

      <programlisting language="java" format="linespecific" id="I_2_tt81">String original = "In time, I grew tired of his babbling nonsense.";
String reverse = StringUtils.reverse( original );
String originalGenes = "AACGTCCCTTGGTTTCCCAAAGTTTCCCTTTGAAATATATGCCCGCG";
String reverseGenes = StringUtils.reverse( originalGenes );

System.out.println( "Original: " + original );
System.out.println( "Reverse: " + reverse );
System.out.println( "\n\nOriginal: " + originalGenes );
System.out.println( "Reverse: " + reverseGenes );</programlisting>

      <para>The output contains a reversed string along with an original
      string:</para>

      <programlisting format="linespecific" id="I_2_tt82">Original: In time, I grew tired of his babbling nonsense.
Reverse: .esnesnon gnilbbab sih fo derit werg I ,emit nI

Original: AACGTCCCTTGGTTTCCCAAAGTTTCCCTTTGAAATATATGCCCGCG
Reverse: GCGCCCGTATATAAAGTTTCCCTTTGAAACCCTTTGGTTCCCTGCAA</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>Reversing a <literal moreinfo="none">String</literal> is easy, but
      how would you rearrange the words in a sentence? <literal
      moreinfo="none">StringUtils.reverseDelimited( )</literal> can reverse a
      string of tokens delimited by a character, and a sentence is nothing
      more than a series of tokens separated by whitespace and punctuation. To
      reverse a simple sentence, chop off the final punctuation mark, and then
      reverse the order of words delimited by spaces. The following example
      reverses an unrealistically simple English sentence:</para>

      <programlisting language="java" format="linespecific" id="I_2_tt83">public Sentence reverseSentence(String sentence) {
    String reversed = StringUtils.chomp( sentence, "." );
    reversed = StringUtils.reverseDelimited( reversed, ' ' );
    reversed = reversed + ".";
    return reversed;
} 

....

String sentence = "I am Susan."
String reversed = reverseSentence( sentence ) );
System.out.println( sentence );
System.out.println( reversed );</programlisting>

      <para>The sentence is reversed and printed alongside the
      original:</para>

      <programlisting format="linespecific" id="I_2_tt84">I am Susan.
Susan am I.</programlisting>

      <para>Here, the order of the characters within each delimited token is
      preserved. Notice that this example includes <literal
      moreinfo="none">StringUtils.chomp( )</literal> with two parameters, the
      last specifying the character to chomp from the string. Instead of
      chomping a newline, in this example, the period is chomped off of the
      sentence before performing the delimited reversal.</para>
    </sect2>
  </sect1>

  <sect1 id="manipulate-text-sect-wrapping" label="2.10" role="Recipe">
    <title>Wrapping Words</title>

    <sect2>
      <title>Problem</title>

      <para>You want to wrap <indexterm id="manipulate-text-ITERM-2041"
          significance="normal">
          <primary>text</primary>

          <secondary>wrapping</secondary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2042"
          significance="normal">
          <primary>WordUtils class</primary>

          <secondary>text, wrapping</secondary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2043"
          significance="normal">
          <primary>wrapping</primary>

          <secondary>words</secondary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2044"
          significance="normal">
          <primary>words</primary>

          <secondary>wrapping</secondary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2045"
          significance="normal">
          <primary>lines, formatting</primary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2046"
          significance="normal">
          <primary>formatting</primary>

          <secondary>lines</secondary>
        </indexterm>lines of text using different line widths and various line
      termination sequences.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use <literal moreinfo="none">WordUtils</literal> to wrap words.
      Supply the number of columns and a line termination string, and <literal
      moreinfo="none">WordUtils</literal> will wrap text. The following
      example wraps a small string to 20 columns:</para>

      <programlisting language="java" format="linespecific" id="I_2_tt85">// Define original String
String message = "One Two Three Four Five";

// Wrap the text.
String wrappedString = 
    WordUtils.wrapText( message, 20, "\n", false );

System.out.println( "Wrapped Message:\n\n" + wrappedString );</programlisting>

      <para>This produces the following output:</para>

      <programlisting format="linespecific" id="I_2_tt86">Wrapped Message:

One Two Three Four 
Five</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>When <literal moreinfo="none">WordUtils</literal> wraps a string,
      it takes a user-supplied line termination sequence like <literal
      moreinfo="none">\n</literal> or <literal moreinfo="none">\r\n</literal>
      and inserts this line termination sequence after a specified number of
      characters, without splitting a word. In the next example, if the user
      is using a hand-held device, the number of columns in the display is 40,
      and a new line is represented by the sequence <literal
      moreinfo="none">\r\n</literal>. On a workstation, the number of
      available columns is 80, and a new line is a single <literal
      moreinfo="none">\n</literal> character. The platform is available as the
      System property <literal
      moreinfo="none">application.platform</literal>:</para>

      <programlisting language="java" format="linespecific" id="I_2_tt87">String message = "Four score and seven years ago, our fathers " +
                 "brought forth upon this continent a new nation: " +
                 "conceived in liberty, and dedicated to the proposition " +
                 "that all men are created equal. ";

// Define variables to hold two parameters to word wrapping 
int cols; 
String lineSeparator = "";

// Retrieve the platform property from System 
String platform = System.getProperty("application.platform");
if( platform.equals( "Handheld" ) ) {
    cols = 40;
    lineSeparator = "\r\n";
} else if( platform.equals( "Workstation" ) {
    cols = 80;
    lineSeparator = "\n";
}

// Wrap the text.
String wrappedString = 
    WordUtils.wrapText( message, cols, lineSeparator, true );</programlisting>

      <para>Depending on the platform, the <literal
      moreinfo="none">wrappedString</literal> variable now holds the initial
      paragraph of the Gettysburg Address wrapped to fit either a 40-column
      handheld device or an application running on a workstation with an
      80-column display.</para>

      <para>To wrap text for presentation on the Web, use the line termination
      sequence <literal moreinfo="none">&lt;br/&gt;</literal> to add an HMTL
      line break. The following example wraps text with <literal
      moreinfo="none">&lt;br/&gt;</literal>, and introduces an option to
      prevent <literal moreinfo="none">WordUtils</literal> from wrapping
      larger words:</para>

      <programlisting language="java" format="linespecific" id="I_2_tt88">String message = "Four score and seven years ago, our fathers " +
                 "brought forth upon this continent a new nation: conceived " +
                 "in liberty, and dedicated to the proposition that all men " +
                 "are created equal. <userinput moreinfo="none">http://www.oreilly.com/Gettysburg</userinput> ";

// Wrap the text.
String wrappedString = WordUtils.wrap( message, 40, "&lt;br/&gt;", false );</programlisting>

      <para>In this example, the Gettysburg Address is formatted to fit into
      40 columns in an HTML document. The final parameter to the <literal
      moreinfo="none">WordUtils.wrap( )</literal> method tells the wrapping
      algorithm not to bother wrapping large words, such as the long URL at
      the end of the text. Wrapping a long word would prevent people from
      being able to copy this URL correctly.</para>
    </sect2>
  </sect1>

  <sect1 id="manipulate-text-sect-testing-contents" label="2.11" role="Recipe">
    <title>Testing the Contents of a String</title>

    <sect2>
      <title>Problem</title>

      <para>You need to make sure a string<indexterm
          id="manipulate-text-ITERM-2047" significance="normal">
          <primary>text</primary>

          <secondary>StringUtils class</secondary>

          <tertiary>testing strings</tertiary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2048"
          significance="normal">
          <primary>StringUtils class</primary>

          <secondary>text</secondary>

          <tertiary>testing strings</tertiary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2049"
          significance="normal">
          <primary>testing</primary>

          <secondary>strings</secondary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2050"
          significance="normal">
          <primary>strings</primary>

          <secondary>testing</secondary>
        </indexterm> contains only numbers, letters, or a combination of
      both.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use the various <literal moreinfo="none">StringUtils</literal>
      methods to validate user input; <literal moreinfo="none">isNumeric(
      )</literal> <indexterm id="manipulate-text-ITERM-2051"
          significance="normal">
          <primary>isNumeric( ) method</primary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2052"
          significance="normal">
          <primary>methods</primary>

          <secondary>isNumeric( )</secondary>
        </indexterm>, <literal moreinfo="none">isAlpha()</literal> <indexterm
          id="manipulate-text-ITERM-2053" significance="normal">
          <primary>isAlpha( ) method</primary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2054"
          significance="normal">
          <primary>methods</primary>

          <secondary>isAlpha( )</secondary>
        </indexterm>, <literal moreinfo="none">isAlphanumeric()</literal>
      <indexterm id="manipulate-text-ITERM-2055" significance="normal">
          <primary>isAlphanumeric( ) method</primary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2056"
          significance="normal">
          <primary>methods</primary>

          <secondary>isAlphanumeric( )</secondary>
        </indexterm>, and <literal moreinfo="none">isAlphaSpace()</literal>
      <indexterm id="manipulate-text-ITERM-2057" significance="normal">
          <primary>isAlphaSpace( ) method</primary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2058"
          significance="normal">
          <primary>methods</primary>

          <secondary>isAlphaSpace( )</secondary>
        </indexterm> verify that a string does not contain any undesired
      characters:</para>

      <programlisting language="java" format="linespecific" id="I_2_tt89">String state = "Virginia"

System.out.println( "Is state number? " + 
                    StringUtils.isNumeric( state ) );
System.out.println( "Is state alpha? " + 
                    StringUtils.isAlpha( state ) );
System.out.println( "Is state alphanumeric? " + 
                    StringUtils.isAlphanumeric( state ) );
System.out.println( "Is state alphaspace? " + 
                    StringUtils.isAlphaspace( state ) );</programlisting>

      <para>This code tests the string "Virginia" against four validation
      methods, producing the following output:</para>

      <programlisting format="linespecific" id="I_2_tt90">Is state a number? false
Is state alpha? true
Is state alphanumeric? true
Is state alphaspace? true</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para><literal moreinfo="none">StringUtils.isNumeric( )</literal>
      returns true if the string being tested contains only digits from 0 to
      9. If you are asking a user to input a numerical value, such as year or
      age, you need to have a way to ensure that the input supplied is, in
      fact, a numeric value:</para>

      <programlisting language="java" format="linespecific" id="I_2_tt91">String test1 = "1976";
String test2 = "Mozart";

boolean t1val = StringUtils.isNumeric( test1 );
boolean t2val = StringUtils.isNumeric( test2 ); 

System.out.println( "Is " + test1 + " a number? " + t1val );
System.out.println( "Is " + test2 + " a number? " + t2val );</programlisting>

      <para>This code tests two strings and produces the following
      output:</para>

      <programlisting format="linespecific" id="I_2_tt92">Is 1976 a number? true
Is Mozart a number? false</programlisting>

      <para>You can use the following code to see if a string contains only
      letters or a combination of letters and numbers:</para>

      <programlisting language="java" format="linespecific" id="I_2_tt93">String test1 = "ORANGE";
String test2 = "ICE9";
String test3 = "ICE CREAM";
String test4 = "820B Judson Avenue";

boolean t1val = StringUtils.isAlpha( test1 ); // returns true
boolean t2val = StringUtils.isAlphanumeric( test2 ); // returns true
boolean t3val = StringUtils.isAlphaSpace( test3 ); // returns true
boolean t4val = 
    StringUtils.isAlphanumericSpace( test4 ); // returns true</programlisting>

      <para>User supplied input can rarely be trusted. If you have asked the
      user to supply an age, a year, or a day of the week, you will need to
      then validate that input. Or, if you have asked the user to type in a
      name, you will want to make sure that the supplied name contains only
      letters and acceptable punctuation. An application with inadequate input
      validation will frequently fail, and produce unsightly stack traces
      caused by either <literal
      moreinfo="none">NumberFormatException</literal>s or <literal
      moreinfo="none">NullPointerException</literal>s. An application should
      be able to gracefully handle the most nonsensical input without missing
      a beat, and prompt the user for a valid input. Tools such as Commons
      Validator provide a framework to validate the contents of a JavaBean,
      but at a much lower level, the <literal
      moreinfo="none">StringUtils</literal> class in Commons Lang provides
      some useful utilities for examining the contents of a string.</para>

      <para>Input forms frequently need to validate a user's name. In this
      case, it is important to remember that certain names have apostrophes
      and dashes. If you are validating a name, always make sure that you
      allow for names with punctuation. Here is an example that validates a
      name with a dash, an apostrophe, and a period:</para>

      <programlisting language="java" format="linespecific" id="I_2_tt94">String name1 = "Tim O'Reilly";
String name2 = "Mr. Mason-Dixon!";

String punctuation = ".-'";
String name1Temp = StringUtils.replaceChars( name1, punctuation, "");
String name2Temp = StringUtils.replaceChars( name1, punctuation, "");

boolean t1val = StringUtils.isAlpha( name1Temp ); // returns true
boolean t2val = StringUtils.isAlpha( name2Temp ); // returns false</programlisting>

      <para>"Tim O'Reilly" is a valid name, but you need to use the <literal
      moreinfo="none">StringUtils.replaceChars( )</literal> method to throw
      out punctuation before you can pass both of the names to the <literal
      moreinfo="none">StringUtils.isAlpha( )</literal> method. "Mr.
      Mason-Dixon!" is not a valid name, because an exclamation point is not
      on the list of valid name punctuation. As an Irishman, I encourage you
      to always check your name validation with names like "O'Toole" or
      "O'Brien," and, as the world continues to shrink, more exceptions to the
      rule, like "Al-Sa'ud," will become more prevalent; your system should
      not force someone to change their name. Speaking from personal
      experience, it is insulting when a web site or an application forces you
      to change your name, and it is a quick way to alienate your customers. I
      cannot begin to tell you how many web sites have shown me a nasty Open
      Database Connectivity (ODBC) error page or stack trace after I've told
      them my last name—it is frustrating.</para>
    </sect2>
  </sect1>

  <sect1 id="manipulate-text-sect-measuring-frequency" label="2.12"
         role="Recipe">
    <title>Measuring the Frequency of a String</title>

    <sect2>
      <title>Problem</title>

      <para>You need to find out how many times a<indexterm
          id="manipulate-text-ITERM-2059" significance="normal">
          <primary>text</primary>

          <secondary>StringUtils class</secondary>

          <tertiary>measuring string frequency</tertiary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2060"
          significance="normal">
          <primary>StringUtils class</primary>

          <secondary>text</secondary>

          <tertiary>measuring string frequency</tertiary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2061"
          significance="normal">
          <primary>strings</primary>

          <secondary>measuring frequency</secondary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2062"
          significance="normal">
          <primary>frequency, measuring strings</primary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2063"
          significance="normal">
          <primary>measuring</primary>

          <secondary>frequency of strings</secondary>
        </indexterm> certain word or piece of text occurs in a string.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para><literal moreinfo="none">StringUtils.countMatches()</literal>
      <indexterm id="manipulate-text-ITERM-2064" significance="normal">
          <primary>StringUtils.countMatches( ) method</primary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2065"
          significance="normal">
          <primary>methods</primary>

          <secondary>StringUtils.countMatches( )</secondary>
        </indexterm> returns the frequency of a piece of text within another
      string:</para>

      <programlisting language="java" format="linespecific" id="I_2_tt95">File manuscriptFile = new File("manuscript.txt");
Reader reader = new FileReader( manuscriptFile );
StringWriter stringWriter = new StringWriter( );
while( reader.ready( ) ) { writer.write( reader.read( ) ); }
String manuscript = stringWriter.toString( );

// Convert string to lowercase
manuscript = StringUtils.lowerCase(manuscript);

// count the occurrences of "futility"
int numFutility = StringUtils.countMatches( manuscript, "futility" );</programlisting>

      <para>Converting the entire string to lowercase ensures that all
      occurrences of the word "futility" are counted, regardless of
      capitalization. This code executes and <literal
      moreinfo="none">numFutility</literal> will contain the number of
      occurrences of the word "futility."</para>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>If the <filename moreinfo="none">manuscript.txt</filename> file is
      large, it makes more sense to search this file one line at a time, and
      sum the number of matches as each line is read. A more efficient
      implementation of the previous example would look like this:</para>

      <programlisting language="java" format="linespecific" id="I_2_tt96">File manuscriptFile = new File("manuscript.txt");
Reader reader = new FileReader( manuscriptFile );
LineNumberReader lineReader = new LineNumberReader( reader );
int numOccurences = 0;

while( lineReader.ready( ) ) { 
    String line = StringUtils.lowerCase( lineReader.readLine( ) );
    numOccurences += StringUtils.countMatches( , "futility" );
}</programlisting>

      <para>Your random access memory will thank you for this implementation.
      Java programmers are often lulled into a sense of false security knowing
      that they do not have to worry about memory management. Poor design
      decisions and inefficient implementation often lead to slow running or
      hard-to-scale applications. Just because you don't have to allocate and
      deallocate memory does not mean that you should stop thinking about
      efficient memory use. If you are trying to search for the frequency of a
      word in a 20 megabyte file, please try not to read the entire file into
      memory before searching. Performing a linear search on a large string is
      an inappropriate way to search a large database of documents. When
      searching large amounts of text, it is more efficient to create an index
      of terms than to perform a linear search over a large string. A method
      for indexing and searching documents using Apache Lucene and Commons
      Digester will be discussed in a later chapter.</para>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para><link linkend="searching-filtering">Chapter 12</link> contains a
      number of recipes devoted to searching and filtering content. If you are
      creating a system that needs to search a large collection of documents,
      consider using Apache Lucene (<ulink
      url="http://lucene.apache.org">http://lucene.apache.org/</ulink>) to
      index your content.</para>
    </sect2>
  </sect1>

  <sect1 id="manipulate-text-sect-parse-formatted" label="2.13" role="Recipe">
    <title>Parsing Formatted Strings</title>

    <sect2>
      <title>Problem</title>

      <para>You need to parse a string containing <indexterm
          class="startofrange" id="manipulate-text-ITERM-2066"
          significance="normal">
          <primary>text</primary>

          <secondary>StringUtils class</secondary>

          <tertiary>parsing strings</tertiary>
        </indexterm> <indexterm class="startofrange"
          id="manipulate-text-ITERM-2067" significance="normal">
          <primary>StringUtils class</primary>

          <secondary>text</secondary>

          <tertiary>parsing strings</tertiary>
        </indexterm> <indexterm class="startofrange"
          id="manipulate-text-ITERM-2068" significance="normal">
          <primary>parsing</primary>

          <secondary>strings</secondary>
        </indexterm> <indexterm class="startofrange"
          id="manipulate-text-ITERM-2069" significance="normal">
          <primary>strings</primary>

          <secondary>parsing</secondary>
        </indexterm> <indexterm class="startofrange"
          id="manipulate-text-ITERM-2070" significance="normal">
          <primary>formatting</primary>

          <secondary>strings, parsing</secondary>
        </indexterm>control characters and the delimiters <literal
      moreinfo="none">(</literal>, <literal moreinfo="none">[</literal>,
      <literal moreinfo="none">)</literal>, <literal
      moreinfo="none">]</literal>, and ,.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use variations of <literal moreinfo="none">substring()</literal>
      <indexterm id="manipulate-text-ITERM-2071" significance="normal">
          <primary>substring( ) method</primary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2072"
          significance="normal">
          <primary>methods</primary>

          <secondary>substring( )</secondary>
        </indexterm> from <literal moreinfo="none">StringUtils</literal>. This
      next example parses a string that contains five numbers delimited by
      parentheses, brackets, and a pipe symbol (<replaceable>N0</replaceable>
      * (<replaceable>N1</replaceable>,<replaceable>N2</replaceable>)
      [<replaceable>N3</replaceable>,<replaceable>N4</replaceable>] |
      <replaceable>N5</replaceable>):</para>

      <programlisting language="java" format="linespecific" id="I_2_tt97">String formatted = " 25 * (30,40) [50,60] | 30"

PrintWriter out = System.out;
out.print("N0: " + StringUtils.substringBeforeLast( formatted, "*" ) );
out.print(", N1: " + StringUtils.substringBetween( formatted, "(", "," ) );
out.print(", N2: " + StringUtils.substringBetween( formatted, ",", ")" ) );
out.print(", N3: " + StringUtils.substringBetween( formatted, "[", "," ) );
out.print(", N4: " + StringUtils.substringBetween( formatted, ",", "]" ) );
out.print(", N5: " + StringUtils.substringAfterLast( formatted, "|" ) );</programlisting>

      <para>This parses the formatted text and prints the following
      output:</para>

      <programlisting format="linespecific" id="I_2_tt98">N0: 25, N1: 30, N2: 40, N3: 50, N4: 60, N5: 30</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>The following public static methods come in handy when trying to
      extract information from a formatted string:</para>

      <variablelist>
        <varlistentry>
          <term><literal moreinfo="none">StringUtils.substringBetween(
          )</literal></term>

          <listitem>
            <para>Captures content between two strings</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal moreinfo="none">StringUtils.substringAfter(
          )</literal></term>

          <listitem>
            <para>Captures content that occurs after the specified
            string</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal moreinfo="none">StringUtils.substringBefore(
          )</literal></term>

          <listitem>
            <para>Captures content that occurs before a specified
            string</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal moreinfo="none">StringUtils.substringBeforeLast(
          )</literal></term>

          <listitem>
            <para>Captures content after the last occurrence of a specified
            string</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal moreinfo="none">StringUtils.substringAfterLast(
          )</literal></term>

          <listitem>
            <para>Captures content before the last occurrence of a specified
            string</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>To illustrate the use of these methods, here is an example of a
      feed of sports scores. Each record in the feed has a defined format,
      which resembles this feed description:</para>

      <programlisting format="linespecific" id="I_2_tt99">\(SOT)&lt;sport&gt;[&lt;team1&gt;,&lt;team2&gt;] (&lt;score1&gt;,&lt;score2&gt;)\(ETX) 

Notes:
 \(SOT) is ASCII character 2 "Start of Text",
 \(ETX) is ASCII character 4 "End of Transmission". 

Example:
 \(SOT)Baseball[BOS,SEA] (24,22)\(ETX)
 \(SOT)Basketball[CHI,NYC] (29,5)\(ETX)</programlisting>

      <para>The following example parses this feed using <literal
      moreinfo="none">StringUtils</literal> methods <literal
      moreinfo="none">trim( )</literal>, <literal
      moreinfo="none">substringBetween( )</literal>, and <literal
      moreinfo="none">substringBefore( )</literal>. The <literal
      moreinfo="none">boxScore</literal> variable holds a test string to
      parse, and, once parsed, this code prints out the game score:</para>

      <programlisting language="java" format="linespecific" id="I_2_tt100">// Create a formatted string to parse - get this from a feed
char SOT = '\u0002';
char ETX = '\u0004';
String boxScore = SOT + "Basketball[CHI,BOS](69,75)\r\n" + ETX;

// Get rid of the archaic control characters
boxScore = StringUtils.trim( boxScore ); 

// Parse the score into component parts 
String sport = StringUtils.substringBefore( boxScore, "[" );
String team1 = StringUtils.substringBetween( boxScore, "[", "," );
String team2 = StringUtils.substringBetween( boxScore, ",", "]" );
String score1 = StringUtils.substringBetween( boxScore, "(", "," );
String score2 = StringUtils.substringBetween( boxScore, ",", ")" );

PrintWriter out = System.out
out.println( "**** " + sport + " Score" );
out.println( "\t" + team1 + "\t" + score1 );
out.println( "\t" + team2 + "\t" + score2 );</programlisting>

      <para>This code parses a score, and prints the following output:</para>

      <programlisting format="linespecific" id="I_2_tt101">**** Basketball
 CHI 69
 BOS 75</programlisting>

      <para>In the previous example, <literal
      moreinfo="none">StringUtils.trim( )</literal> rids the text of the
      <literal moreinfo="none">SOT</literal> and <literal
      moreinfo="none">ETX</literal> control characters. <literal
      moreinfo="none">StringUtils.substringBefore( )</literal> then reads the
      sport name—"Basketball"—and <literal moreinfo="none">substringBetween(
      )</literal> is used to retrieve the teams and scores.</para>

      <para>At first glance, the value of these <literal
      moreinfo="none">substring( )</literal> variations is not obvious. The
      previous example parsed this simple formatted string using three static
      methods on <literal moreinfo="none">StringUtils</literal>, but how
      difficult would it have been to implement this parsing without the aid
      of Commons Lang? The following example parses the same string using only
      methods available in the Java 1.4 J2SE:</para>

      <programlisting language="java" format="linespecific" id="I_2_tt102">// Find the sport name without using StringUtils
boxScore = boxScore.trim( );

int firstBracket = boxScore.indexOf( "[" );
String sport = boxScore.substring( 0, firstBracket );

int firstComma = boxScore.indexOf( "," );
String team1 = boxScore.substring( firstBracket + 1, firstComma );

int secondBracket = boxScore.indexOf( "]" );
String team2 = boxScore.substring( firstComma + 1, secondBracket );

int firstParen = boxScore.indexOf( "(" );
int secondComma = boxScore.indexOf( ",", firstParen );
String score1 = boxScore.substring( firstParen + 1, secondComma );

int secondParen = boxScore.indexOf( ")" );
String score2 = boxScore.substring( secondComma + 1, secondParen );</programlisting>

      <para>This parses the string in a similar number of lines, but the code
      is less straightforward and much more difficult to maintain. Instead of
      simply calling a <literal moreinfo="none">substringBetween( )</literal>
      method, the previous example calls <literal
      moreinfo="none">String.indexOf( )</literal> and performs arithmetic with
      an index while calling <literal moreinfo="none">String.substring(
      )</literal>. Additionally, the <literal moreinfo="none">substring(
      )</literal> methods on <literal moreinfo="none">StringUtils</literal>
      are <literal moreinfo="none">null</literal>-safe; the Java 1.4 example
      could throw a <literal moreinfo="none">NullPointerException</literal> if
      <literal moreinfo="none">boxScore</literal> was <literal
      moreinfo="none">null</literal>.</para>

      <para><literal moreinfo="none">String.trim( )</literal> has the same
      behavior as <literal moreinfo="none">StringUtils.trim( )</literal>,
      stripping the string of all whitespace and ASCII control characters.
      <literal moreinfo="none">StringUtils.trim()</literal> is simply a
      wrapper for the <literal moreinfo="none">String.trim( )</literal>
      method, but the <literal moreinfo="none">StringUtils.trim( )</literal>
      method can gracefully handle a <literal moreinfo="none">null</literal>
      input. If a <literal moreinfo="none">null</literal> value is passed to
      <indexterm class="endofrange" id="manipulate-text-ITERM-2073"
      significance="normal" startref="manipulate-text-ITERM-2066"></indexterm>
      <indexterm class="endofrange" id="manipulate-text-ITERM-2074"
      significance="normal" startref="manipulate-text-ITERM-2067"></indexterm>
      <indexterm class="endofrange" id="manipulate-text-ITERM-2075"
      significance="normal" startref="manipulate-text-ITERM-2068"></indexterm>
      <indexterm class="endofrange" id="manipulate-text-ITERM-2076"
      significance="normal" startref="manipulate-text-ITERM-2069"></indexterm>
      <indexterm class="endofrange" id="manipulate-text-ITERM-2077"
      significance="normal" startref="manipulate-text-ITERM-2070"></indexterm>
      <literal moreinfo="none">StringUtils.trim()</literal>, a <literal
      moreinfo="none">null</literal> value is returned.</para>
    </sect2>
  </sect1>

  <sect1 id="manipulate-text-sect-string-diff" label="2.14" role="Recipe">
    <title>Calculating String Difference</title>

    <sect2>
      <title>Problem</title>

      <para>Your application needs to compare<indexterm
          id="manipulate-text-ITERM-2078" significance="normal">
          <primary>text</primary>

          <secondary>StringUtils class</secondary>

          <tertiary>comparing strings</tertiary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2079"
          significance="normal">
          <primary>StringUtils class</primary>

          <secondary>text</secondary>

          <tertiary>comparing strings</tertiary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2080"
          significance="normal">
          <primary>comparing</primary>

          <secondary>strings</secondary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2081"
          significance="normal">
          <primary>strings</primary>

          <secondary>comparing</secondary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2082"
          significance="normal">
          <primary>printing</primary>

          <secondary>strings</secondary>
        </indexterm> two strings and print out the difference.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use <literal moreinfo="none">StringUtils.difference( )</literal>,
      <literal moreinfo="none">StringUtils.indexOfDifference( )</literal>, and
      <literal moreinfo="none">StringUtils.getLevenshteinDistance(
      )</literal>. <literal moreinfo="none">StringUtils.difference(
      )</literal> prints out the difference between two strings, <literal
      moreinfo="none">StringUtils.indexOfDifference( )</literal> returns the
      index at which two strings begin to differ, and <literal
      moreinfo="none">StringUtils.getLevenshteinDistance( )</literal> returns
      the "edit distance" between two strings. The following example
      demonstrates all three of these methods:</para>

      <programlisting language="java" format="linespecific" id="I_2_tt103">int dist = StringUtils.getLevenshteinDistance( "Word", "World" );
String diff = StringUtils.difference( "Word", "World" );
int index = StringUtils.indexOfDifference( "Word", "World" );

System.out.println( "Edit Distance: " + dist );
System.out.println( "Difference: " + diff );
System.out.println( "Diff Index: " + index );</programlisting>

      <para>This code compares the strings "Word" and "World," producing the
      following output:</para>

      <programlisting format="linespecific" id="I_2_tt104">Edit Distance: 2
Difference: ld
Diff Index: 3</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para><literal moreinfo="none">StringUtils.difference()</literal>
      <indexterm id="manipulate-text-ITERM-2083" significance="normal">
          <primary>StringUtils.difference( ) method</primary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2084"
          significance="normal">
          <primary>methods</primary>

          <secondary>StringUtils.difference( )</secondary>
        </indexterm> returns the difference between two strings, returning the
      portion of the second string, which starts to differ from the first.
      <literal moreinfo="none">StringUtils.indexOfDifference()</literal>
      <indexterm id="manipulate-text-ITERM-2085" significance="normal">
          <primary>StringUtils.indexOfDifference( ) method</primary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2086"
          significance="normal">
          <primary>methods</primary>

          <secondary>StringUtils.indexOfDifference( )</secondary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2087"
          significance="normal">
          <primary>indexes</primary>

          <secondary>comparing</secondary>
        </indexterm> returns the index at which the second string starts to
      diverge from the first. The difference between "ABC" and "ABE" is "E,"
      and the index of the difference is 2. Here's a more complex
      example:</para>

      <programlisting language="java" format="linespecific" id="I_2_tt105">String a = "Strategy";
String b = "Strategic";

String difference = StringUtils.difference( a, b );
int differenceIndex = StringUtils.indexOfDifference( a, b );

System.out.println( "difference(Strategy, Strategic) = " +
                    difference );
System.out.println( "index(Strategy, Strategic) = " +
                    differenceIndex );

a = "The Secretary of the UN is Kofi Annan."
b = "The Secretary of State is Colin Powell."

difference = StringUtils.difference( a, b );
differenceIndex = StringUtils.indexOfDifference( a, b );

System.out.println( "difference(..., ...) = " +
                    difference );
System.out.println( "index(..., ...) = " +
                    differenceIndex );</programlisting>

      <para>This produces the following output, showing the differences
      between two strings:</para>

      <programlisting format="linespecific" id="I_2_tt106">difference(Strategy, Strategic) = ic
index(Strategy, Strategic) = 7
difference(...,...) = State is Colin Powell.
index(...,...) = 17</programlisting>

      <para>The Levenshtein distance is calculated as the number of
      insertions, deletions, and replacements it takes to get from one string
      to another. The distance between "Boat" and "Coat" is a one letter
      replacement, and the distance between "Remember" and "Alamo" is 8—five
      letter replacements and three deletions. Levenshtein distance is also
      known as the <filename moreinfo="none">edit distance</filename>, which
      is the number of changes one needs to make to a string to get from
      string A to string B. The following example demonstrates the <literal
      moreinfo="none">getLevenshteinDistance( )</literal> method:</para>

      <programlisting language="java" format="linespecific" id="I_2_tt107">int distance1 = 
    StringUtils.getLevenshteinDistance( "Boat", "Coat" );
int distance2 = 
    StringUtils.getLevenshteinDistance( "Remember", "Alamo" );
int distance3 = 
    StringUtils.getLevenshteinDistance( "Steve", "Stereo" );

System.out.println( "distance(Boat, Coat): " + distance1 );
System.out.println( "distance(Remember, Alamo): " + distance2 );
System.out.println( "distance(Steve, Stereo): " + distance3 );</programlisting>

      <para>This produces the following output, showing the Levenshtein (or
      edit) distance between various strings:</para>

      <programlisting format="linespecific" id="I_2_tt108">distance(Boat, Coat): 1
distance(Remember, Alamo): 8
distance(Steve, Stereo): 3</programlisting>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>The Levenshtein distance has a number of different applications,
      including pattern recognition and correcting spelling mistakes. For more
      information about the Levenshtein distance, see <ulink
      url="http://www.merriampark.com/ld.htm">http://www.merriampark.com/ld.htm</ulink>,
      which explains the algorithm and provides links to implementations of
      this algorithm in 15 different languages.</para>
    </sect2>
  </sect1>

  <sect1 id="manipulate-text-sect-using-codec" label="2.15" role="Recipe">
    <title>Using Commons Codec</title>

    <sect2>
      <title>Problem</title>

      <para>You want to use <indexterm id="manipulate-text-ITERM-2088"
          significance="normal">
          <primary>Commons Codec</primary>
        </indexterm>Commons Codec.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>To use Commons Codec in a Maven 2 project, add the following
      dependency to your project's <filename>pom.xml</filename>:</para>

      <example id="manipulate-text-ex-add-depend-codec">
        <title>Adding a Dependency on Commons Codec</title>

        <programlisting language="xml">&lt;dependency&gt;
  &lt;groupId&gt;commons-codec&lt;/groupId&gt;
  &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;
  &lt;version&gt;1.3&lt;/version&gt;
&lt;/dependency&gt;  </programlisting>
      </example>

      <para>If you are not sure what this means, I'd suggest reading <ulink
      url="http://www.sonatype.com/books/maven-book">Maven: The Complete Reference</ulink>. When you depend on a library in Maven 2, all you need to
      do is add the dependency <varname>groupId</varname>,
      <varname>artifactId</varname>, and <varname>version</varname> to your
      project's dependencies. Once you do this, Maven 2 will download the
      dependency and make it available on your project's classpath.</para>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>The <indexterm id="manipulate-text-ITERM-2089"
          significance="normal">
          <primary>libraries</primary>

          <secondary>Commons Codec</secondary>
        </indexterm>Commons Codec library is a small library, which includes
      encoders and decoders for common encoding algorithms, such as <literal
      moreinfo="none">Hex</literal>, <literal
      moreinfo="none">Base64</literal>; and phonetic encoders, such as
      <literal moreinfo="none">Metaphone</literal>, <literal
      moreinfo="none">DoubleMetaphone</literal>, and <literal
      moreinfo="none">Soundex</literal>. This tiny component was created to
      provide a definitive implementation of <literal
      moreinfo="none">Base64</literal> and <literal
      moreinfo="none">Hex</literal>, encouraging reuse and reducing the amount
      of code duplication between various Apache projects.</para>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>To learn more about Commons Codec, visit the Commons Codec project
      at <ulink
      url="http://commons.apache.org/codec/">http://commons.apache.org/codec/</ulink>.</para>
    </sect2>
  </sect1>

  <sect1 id="manipulate-text-sect-soundex" label="2.17" role="Recipe">
    <title>Calculating Soundex</title>

    <sect2>
      <title>Problem</title>

      <para>You need the<indexterm id="manipulate-text-ITERM-2095"
          significance="normal">
          <primary>Commons Codec</primary>

          <secondary>Soundex</secondary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2096"
          significance="normal">
          <primary>Soundex</primary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2097"
          significance="normal">
          <primary>code</primary>

          <secondary>Soundex</secondary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2098"
          significance="normal">
          <primary>source code</primary>

          <secondary>Soundex</secondary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2099"
          significance="normal">
          <primary>programming</primary>

          <secondary>Soundex</secondary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2100"
          significance="normal">
          <primary>calculations</primary>

          <secondary>Soundex</secondary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2101"
          significance="normal">
          <primary>names</primary>

          <secondary>Soundex</secondary>
        </indexterm> <indexterm id="manipulate-text-ITERM-2102"
          significance="normal">
          <primary>words</primary>

          <secondary>Soundex</secondary>
        </indexterm> <literal moreinfo="none">Soundex</literal> code of a word
      or a name.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use Commons Codec's <literal moreinfo="none">Soundex</literal>.
      Supply a surname or a word, and <literal
      moreinfo="none">Soundex</literal> will produce a phonetic
      encoding:</para>

      <programlisting language="java" format="linespecific" id="I_2_tt110">// Required import declaration
import org.apache.commons.codec.language.Soundex;

// Code body
Soundex soundex = new Soundex( );
String obrienSoundex = soundex.soundex( "O'Brien" );
String obrianSoundex = soundex.soundex( "O'Brian" );
String obryanSoundex = soundex.soundex( "O'Bryan" );

System.out.println( "O'Brien soundex: " + obrienSoundex );
System.out.println( "O'Brian soundex: " + obrianSoundex );
System.out.println( "O'Bryan soundex: " + obryanSoundex );</programlisting>

      <para>This will produce the following output for three similar
      surnames:</para>

      <programlisting format="linespecific" id="I_2_tt111">O'Brien soundex: O165
O'Brian soundex: O165
O'Bryan soundex: O165</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para><literal moreinfo="none">Soundex.soundex( )</literal> takes a
      string, preserves the first letter as a letter code, and proceeds to
      calculate a code based on consonants contained in a string. So, names
      such as "O'Bryan," "O'Brien," and "O'Brian," all being common variants
      of the Irish surname, are given the same encoding: "O165." The 1
      corresponds to the B, the 6 corresponds to the R, and the 5 corresponds
      to the N; vowels are discarded from a string before the <literal
      moreinfo="none">Soundex</literal> code is generated.</para>

      <para>The <literal moreinfo="none">Soundex</literal> algorithm can be
      used in a number of situations, but <literal
      moreinfo="none">Soundex</literal> is usually associated with surnames,
      as the United States historical census records are indexed using
      <literal moreinfo="none">Soundex</literal>. In addition to the role
      <literal moreinfo="none">Soundex</literal> plays in the census, <literal
      moreinfo="none">Soundex</literal> is also used in the health care
      industry to index medical records and report statistics to the
      government. A system to access individual records should allow a user to
      search for a person by the <literal moreinfo="none">Soundex</literal>
      code of a surname. If a user types in the name "Boswell" to search for a
      patient in a hospital, the search result should include patients named
      "Buswell" and "Baswol;" you can use <literal
      moreinfo="none">Soundex</literal> to provide this capability if an
      application needs to locate individuals by the sound of a
      surname.</para>

      <para>The <literal moreinfo="none">Soundex</literal> of a word or name
      can also be used as a primitive method to find out if two small words
      rhyme. Commons Codec contains other phonetic encodings, such as <literal
      moreinfo="none">RefinedSoundex</literal>, <literal
      moreinfo="none">Metaphone</literal>, and <literal
      moreinfo="none">DoubleMetaphone</literal>. All of these alternatives
      solve similar problems—capturing the <firstterm>phonemes</firstterm> or
      sounds contained in a word.</para>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>For more information on the <literal
      moreinfo="none">Soundex</literal> encoding, take a look at the
      Dictionary of Algorithms and Data Structures at the National Institute
      of Standards and Technology (NIST), <ulink
      url="http://www.nist.gov/dads/HTML/soundex.html">http://www.nist.gov/dads/HTML/soundex.html</ulink>.
      There you will find links to a C implementation of the <literal
      moreinfo="none">Soundex</literal> algorithm.</para>

      <para>For more information about alternatives to <literal
      moreinfo="none">Soundex</literal> encoding, read "The Double Metaphone
      Search Algorithm" by Lawrence Philips (<ulink
      url="http://www.cuj.com/documents/s=8038/cuj0006philips/">http://www.cuj.com/documents/s=8038/cuj0006philips/</ulink>).
      Or take a look at one of Lawrence Philips's original Metaphone algorithm
      implementations at <ulink
      url="http://aspell.sourceforge.net/metaphone/">http://aspell.sourceforge.net/metaphone/</ulink>.
      Both the Metaphone and Double Metaphone algorithms capture the sound of
      an English word; implementations of these algorithms are available in
      Commons Codec as <literal moreinfo="none">Metaphone</literal> and
      <literal moreinfo="none">DoubleMetaphone</literal>.</para>
    </sect2>
  </sect1>
</chapter>
