<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="xml" label="6">
  <title>XML</title>

  <sect1 id="xml-sect-intro">
    <title>Introduction</title>

    <para>Extensible Markup Language (XML) went from a risky buzzword to a
    ubiquitous data format in a few short years, bringing with it an
    overwhelming array of tools, standards, APIs, and technologies. World Wide
    Web Consortium's (W3C) publication of the initial XML recommendation in
    1998 redefined the way information is represented, stored, and exchanged,
    and it seems that a new standard involving XML is created every month:
    XSL, XML Query, XPointer, XPath, XLink, XHTML, SVG, MathML, XForms, XML
    Encryption, SOAP, XML-RPC, WSDL, XML Schema, RelaxNG, and the list
    continues. Such standards are accompanied by an almost endless series of
    standard APIs, such as SAX and DOM. To further complicate matters, Sun
    Microsystems has created a number of Java APIs to handle most everything
    XML, including JAXP, TrAX, JAXB, JAXM, JAX-RPC, JAXR, and SAAJ. It would
    take years to become an expert in each of these standards, tools, and
    APIs, and, because of this, most programmers focus on the tip of the
    iceberg: SAX, DOM, a little XPath, DTD, and XML Schema. This chapter
    focuses on parsing and data binding; reading a XML document and creating
    an XML document from a set of objects.</para>

    <para>More than a few developers have noted that parsing a simple XML
    document with SAX or DOM can be an unreasonably complex task, especially
    if one is simply attempting to create a prototype. With SAX, you need to
    write a series of callback methods like <literal
    moreinfo="none">startElement( )</literal> and <literal
    moreinfo="none">endElement()</literal>, and in DOM, you need to write a
    not-trivial amount of code to traverse a <literal
    moreinfo="none">Document</literal> object. It isn't the case that you
    should never write a DOM or SAX parser; there are some systems that call
    for this level of control and complexity, and a thorough knowledge of SAX,
    DOM, and JDOM is essential knowledge for any developer. This chapter isn't
    looking to unseat the reigning standards; instead, this chapter simply
    introduces you to some tools that sit on top of standard parsers and do
    some parsing dirty work in specific situations. A very common task in any
    Java program is reading in an XML document and creating a set of objects,
    and Commons Digester and Commons Betwixt make this task as simple as it
    should be.</para>

    <para>With almost a trillion different ways to parse or create a simple
    XML document, you can easily overlook a tool that might save days of
    programming time. Commons Digester, Commons Betwixt, Zeus, Quick, Apache
    XMLBeans, JAXB, XStream, JiBX, and others are all projects and products
    that deal with the simple task of serializing objects to XML and
    unmarshalling XML to objects. This field is crowded, and a number of these
    technologies have great promises and great flaws. Just as this chapter was
    not written to convince you to abandon SAX and DOM, this chapter was also
    not written to sell Digester or Betwixt over all other options. If you
    don't like what you see in this chapter, there are a variety of options,
    and while the abundance of choice is overwhelming, open source is about
    having options and choices. This chapter introduces you to two
    battle-tested options from Apache Commons—Commons Digester and Commons
    Betwixt.</para>

    <para>Commons Digester makes the task of parsing XML exceedingly
    straightforward; with the Digester in hand, you can map an XML document to
    a series of objects using a simple set of rules and a small amount of Java
    code. If you use Digester with an XML rule set, it is possible to write a
    system that parses an XML document with three or four lines of compiled
    code and no hardcoded logic dealing with document structure. Commons
    Betwixt maps beans to XML documents and vice versa. The <literal
    moreinfo="none">BeanWriter</literal> class can be used to serialize an
    object as an XML document, and the <literal
    moreinfo="none">BeanReader</literal> can be used to read an XML document.
    The XML produced by Betwixt can be customized with an XML document that
    controls such things as whether properties are to be serialized as
    attributes or elements, how Collections are handled, or how property names
    are converted to element or attribute names.</para>

    <para>For more information about XML data binding, pick up a copy of Brett
    McLaughlin's <emphasis>Java &amp; XML Data Binding</emphasis> (O'Reilly)
    or <emphasis>Java &amp; XML</emphasis> (O'Reilly). For more information
    about XML, see the W3C at <ulink
    url="http://www.w3c.org">http://www.w3c.org</ulink>. For a list of
    technologies, take a look at Ronald Bourret's <emphasis>XML Data Binding
    Resources</emphasis> (<ulink
    url="http://www.rpbourret.com/xml/XMLDataBinding.htm">http://www.rpbourret.com/xml/XMLDataBinding.htm</ulink>).</para>
  </sect1>

  <sect1 id="xml-sect-obtaining-digester" label="6.1" role="Recipe">
    <title>Obtaining Commons Digester</title>

    <sect2>
      <title>Problem</title>

      <para>You need to use <indexterm id="xml-ITERM-2690"
          significance="normal">
          <primary>Commons Digester</primary>

          <secondary>downloading</secondary>
        </indexterm> <indexterm id="xml-ITERM-2691" significance="normal">
          <primary>downloading</primary>

          <secondary>Commons Digester</secondary>
        </indexterm> <indexterm id="xml-ITERM-2692" significance="normal">
          <primary>XML (Extensible Markup Language)</primary>

          <secondary>Commons Digester, downloading</secondary>
        </indexterm>Commons Digester to quickly parse an XML document into a
      set of objects.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>To use Commons Digester in a Maven 2 project, add the following
      dependency to your project's <filename>pom.xml</filename>:</para>

      <example>
        <title>Adding a Dependency on Commons Digester</title>

        <programlisting>    &lt;dependency&gt;
      &lt;groupId&gt;commons-digester&lt;/groupId&gt;
      &lt;artifactId&gt;commons-digester&lt;/artifactId&gt;
      &lt;version&gt;1.8&lt;/version&gt;
    &lt;/dependency&gt;
</programlisting>
      </example>

      <para>If you are not sure what this means, I'd suggest reading <ulink
      url="http://www.sonatype.com/books/maven-book">Maven: The Definitive
      Guide</ulink>. When you depend on a library in Maven 2, all you need to
      do is add the dependency <varname>groupId</varname>,
      <varname>artifactId</varname>, and <varname>version</varname> to your
      project's dependencies. Once you do this, Maven 2 will download the
      dependency and make it available on your project's classpath.</para>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>Commons Digester started as a part of Struts, and it was moved to
      the Commons project by way of the Commons Sandbox in early 2001.
      Digester is the mechanism Struts uses to read XML configuration;
      <filename moreinfo="none">struts-config.xml</filename> is the main
      configuration point for Struts, and it is converted to a set of objects
      using the Digester. The Digester's most straightforward application is
      the mapping of an XML document to a set of Java objects, but, as shown
      in this chapter and <link linkend="searching-filtering">Chapter
      12</link>, Digester can also be used to create a simple XML command
      language and search index. Digester is a shortcut for creating a SAX
      parser. Almost anything you can do with a SAX parser can be done with
      Commons Digester.</para>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>For more information about Commons Digester, see the Commons
      Digester project page at <ulink
      url="http://jakarta.apache.org/commons/digester">http://commons.apache.org/digester</ulink>.
      For information about using the Digester to create a Lucene index, see
      <link linkend="searching-filtering">Chapter 12</link>.</para>
    </sect2>
  </sect1>

  <sect1 id="xml-sect-xml-doc-obj" label="6.2" role="Recipe">
    <title>Turning XML Documents into Objects</title>

    <sect2>
      <title>Problem</title>

      <para>You need to parse an XML <indexterm class="startofrange"
          id="xml-ITERM-2693" significance="normal">
          <primary>XML (Extensible Markup Language)</primary>

          <secondary>documents</secondary>

          <tertiary>converting to objects</tertiary>
        </indexterm> <indexterm class="startofrange" id="xml-ITERM-2694"
          significance="normal">
          <primary>documents</primary>

          <secondary>XML</secondary>

          <tertiary>converting to objects</tertiary>
        </indexterm> <indexterm class="startofrange" id="xml-ITERM-2695"
          significance="normal">
          <primary>objects</primary>

          <secondary>XML</secondary>

          <tertiary>converting to</tertiary>
        </indexterm> <indexterm class="startofrange" id="xml-ITERM-2696"
          significance="normal">
          <primary>conversion</primary>

          <secondary>XML</secondary>

          <tertiary>documents to objects</tertiary>
        </indexterm>document into an object graph, and you would like to avoid
      using either the DOM or SAX APIs directly.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use the Commons Digester to transform an XML document into an
      object graph. The Digester allows you to map an XML document structure
      to an object model in an external XML file containing a set of rules
      telling the Digester what to do when specific elements are encountered.
      In this recipe, the following XML document containing a description of a
      play will be parsed into an object graph:</para>

      <programlisting format="linespecific" id="I_6_tt259">&lt;?xml version="1.0"?&gt;

&lt;plays&gt;
  &lt;play genre="tragedy" year="1603" language="english"&gt;
    &lt;name&gt;Hamlet&lt;/name&gt;
    &lt;author&gt;William Shakespeare&lt;/author&gt;
    &lt;summary&gt;
      Prince of Denmark freaks out, talks to ghost, gets into a
      crazy nihilistic funk, and dies in a duel.
    &lt;/summary&gt;
    &lt;characters&gt;
      &lt;character protagonist="false"&gt;
        &lt;name&gt;Claudius&lt;/name&gt;
        &lt;description&gt;King of Denmark&lt;/description&gt;
      &lt;/character&gt;
      &lt;character protagonist="true"&gt;
        &lt;name&gt;Hamlet&lt;/name&gt;
        &lt;descr&gt;
          Son to the late, and nephew of the present king
        &lt;/descr&gt;
      &lt;/character&gt;
      &lt;character protagonist="false"&gt;
        &lt;name&gt;Horatio&lt;/name&gt;
        &lt;descr&gt;
          friend to Hamlet
        &lt;/descr&gt;
      &lt;/character&gt;
    &lt;/characters&gt;
  &lt;/play&gt;
&lt;/plays&gt;</programlisting>

      <para>This XML document contains a list of <literal
      moreinfo="none">play</literal> elements describing plays by William
      Shakespeare. One play element describes "Hamlet"; it includes a <literal
      moreinfo="none">name</literal>, <literal
      moreinfo="none">author</literal>, and <literal
      moreinfo="none">summary</literal> element as well as a <literal
      moreinfo="none">characters</literal> element containing <literal
      moreinfo="none">character</literal> elements describing characters in
      the play. After parsing a document with Digester, each <literal
      moreinfo="none">play</literal> element will be represented by a <literal
      moreinfo="none">Play</literal> object with a set of properties and a
      <literal moreinfo="none">List</literal> of <literal
      moreinfo="none">Character</literal> objects:</para>

      <programlisting format="linespecific" id="I_6_tt260">public class Play {
    private String genre;
    private String year;
    private String language;
    private String name;
    private String author;
    private String summary;
    private List characters = new ArrayList( );

    // accessors omitted for brevity

    // Add method to support adding elements to characters.
    public void addCharacter(Character character) {
        characters.add( character );
    }
}

public class Character {
    private String name;
    private String description;
    private boolean protagonist;

    // accessors omitted for brevity
}</programlisting>

      <para>The Digester maps XML to objects using a set of rules, which can
      be defined either in an XML file, or they can be constructed
      programmatically by creating instances of <literal
      moreinfo="none">Rule</literal> and adding them to an instance of
      <literal moreinfo="none">Digester</literal>. This recipe uses an XML
      file to create a set of rules that tell the Digester how to translate an
      XML document to a <literal moreinfo="none">List</literal> of <literal
      moreinfo="none">Play</literal> objects:</para>

      <programlisting format="linespecific" id="I_6_tt261">&lt;?xml version="1.0"?&gt;

&lt;digester-rules&gt;
  &lt;pattern value="plays/play"&gt;
    &lt;object-create-rule classname="xml.digester.Play"/&gt;
    &lt;set-next-rule methodname="add" paramtype="java.lang.Object"/&gt;
    &lt;set-properties-rule/&gt;
    &lt;bean-property-setter-rule pattern="name"/&gt;
    &lt;bean-property-setter-rule pattern="summary"/&gt;
    &lt;bean-property-setter-rule pattern="author"/&gt;
    
    &lt;!-- Nested Pattern for Characters --&gt;
    &lt;pattern value="characters/character"&gt;
      &lt;object-create-rule classname="xml.digester.Character"/&gt;
      &lt;set-next-rule methodname="addCharacter" 
                     paramtype="xml.digester.Character"/&gt;
      &lt;set-properties-rule/&gt;
      &lt;bean-property-setter-rule pattern="name"/&gt;
      &lt;bean-property-setter-rule pattern="descr" 
                                 propertyname="description"/&gt;
    &lt;/pattern&gt;
  
  &lt;/pattern&gt;
&lt;/digester-rules&gt;</programlisting>

      <para>This mapping document (or rule sets) can be explained in very
      straightforward language. It is telling Digester how to deal with the
      document, "When you see an element matching the pattern <filename
      moreinfo="none">plays/play</filename>, create an instance of <literal
      moreinfo="none">xml.digester.Play</literal>, set some properties, and
      push it on to a <literal moreinfo="none">Stack</literal> (<literal
      moreinfo="none">object-create-rule</literal>). If you encounter an
      element within a <literal moreinfo="none">play</literal> element that
      matches <filename moreinfo="none">characters/character</filename>,
      create an instance of <literal
      moreinfo="none">xml.digester.Character</literal>, set some properties,
      and add it to the <literal moreinfo="none">Play</literal> object." The
      following code creates an instance of <literal
      moreinfo="none">Digester</literal> from the XML rule sets shown
      previously, producing a <literal moreinfo="none">plays List</literal>,
      which contains one <literal moreinfo="none">Play</literal>
      object:</para>

      <programlisting format="linespecific" id="I_6_tt262">import org.apache.commons.digester.Digester;
import org.apache.commons.digester.xmlrules.DigesterLoader;

List plays = new ArrayList( );

// Create an instance of the Digester from the XML rule set
URL rules = getClass( ).getResource("./play-rules.xml");
Digester digester = DigesterLoader.createDigester(rules);

// Push a reference to the plays List on to the Stack
digester.push(plays);

// Parse the XML document
InputStream input = getClass( ).getResourceAsStream("./plays.xml");
Object root = digester.parse(input);

// The XML document contained one play "Hamlet"
Play hamlet = (Play) plays.get(0);
List characters = (List) hamlet.getCharacters( );</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>Digester is simple, but there is one concept you need to
      understand: Digester uses a <literal moreinfo="none">Stack</literal> to
      relate objects to one another. In the previous example, <literal
      moreinfo="none">set-next-rule</literal> tells the Digester to relate the
      top of the <literal moreinfo="none">Stack</literal> to the next-to-top
      of the <literal moreinfo="none">Stack</literal>. Before the XML document
      is parsed, a <literal moreinfo="none">List</literal> is pushed onto the
      <literal moreinfo="none">Stack</literal>. Every time the Digester
      encounters a <literal moreinfo="none">play</literal> element, it will
      create an instance of <literal moreinfo="none">Play</literal>, push it
      onto the top of the <literal moreinfo="none">Stack</literal>, and call
      <literal moreinfo="none">add( )</literal> with <literal
      moreinfo="none">Play</literal> as an argument on the object next to the
      top of the stack. Since the <literal moreinfo="none">List</literal> is
      next to the top of the <literal moreinfo="none">Stack</literal>, the
      Digester is simply adding the <literal moreinfo="none">Play</literal> to
      the <literal moreinfo="none">playList</literal>. Within the pattern
      element matching <filename moreinfo="none">plays/play</filename>, there
      is another pattern element matching <filename
      moreinfo="none">characters/character</filename>. When an element
      matching <filename moreinfo="none">characters/character</filename> is
      encountered, a <literal moreinfo="none">Character</literal> object is
      created, pushed onto the top of the <literal
      moreinfo="none">Stack</literal>, and the <literal
      moreinfo="none">addCharacter( )</literal> method is called on the next
      to top of the <literal moreinfo="none">Stack</literal>. When the
      <literal moreinfo="none">Character</literal> object is pushed onto the
      top of the <literal moreinfo="none">Stack</literal>, the <literal
      moreinfo="none">Play</literal> object is next to the top of the <literal
      moreinfo="none">Stack</literal>; therefore, the call to <literal
      moreinfo="none">addCharacter( )</literal> adds a <literal
      moreinfo="none">Character</literal> to the <literal
      moreinfo="none">List</literal> of <literal
      moreinfo="none">Character</literal> objects in the <literal
      moreinfo="none">Play</literal> object.</para>

      <para>Digester can be summed up as follows: define patterns to be
      matched and a sequence of actions (rules) to take when these patterns
      are encountered. Digester is essentially short-hand for your own SAX
      parser, letting you accomplish the same task without having to deal with
      the complexity of the SAX API. If you look at the source for the
      <literal moreinfo="none">org.apache.commons.digester.Digester</literal>
      class, you see that it implements <literal
      moreinfo="none">org.xml.sax.helpers.DefaultHandler</literal> and that a
      call to <literal moreinfo="none">parse( )</literal> causes <literal
      moreinfo="none">Digester</literal> to register itself as a content
      handler on an instance of <literal
      moreinfo="none">org.xml.sax.XMLReader</literal>. Digester is simply a
      lightweight shell around SAX, and, because of this, you can parse XML
      just as fast with the Digester as with a system written to the SAX
      API.</para>

      <para>Digester rule sets can be defined in an external XML document, or
      programmatically in compiled Java code, but the general rules are the
      same. The following code recreates the rule set defined in the previous
      <indexterm id="xml-ITERM-2697" significance="normal">
          <primary>rules, XML</primary>
        </indexterm> <indexterm id="xml-ITERM-2698" significance="normal">
          <primary>XML (Extensible Markup Language)</primary>

          <secondary>rules</secondary>
        </indexterm>XML rule set:</para>

      <programlisting format="linespecific" id="I_6_tt263">import org.apache.commons.digester.BeanPropertySetterRule;
import org.apache.commons.digester.Digester;
import org.apache.commons.digester.ObjectCreateRule;
import org.apache.commons.digester.Rules;
import org.apache.commons.digester.SetNextRule;
import org.apache.commons.digester.SetPropertiesRule;

Digester digester = new Digester( );

Rules rules = digester.getRules( );

// Add Rules to parse a play element
rules.add( "plays/play", new ObjectCreateRule("xml.digester.Play"));
rules.add( "plays/play", new SetNextRule("add", "java.lang.Object") );
rules.add( "plays/play", new SetPropertiesRule( ) );
rules.add( "plays/play/name", new BeanPropertySetterRule("name") );
rules.add( "plays/play/summary", new BeanPropertySetterRule("summary") );
rules.add( "plays/play/author", new BeanPropertySetterRule("author") );

// Add Rules to parse a character element
rules.add( "plays/play/characters/character", new 
           ObjectCreateRule("xml.digester.Character"));
rules.add( "plays/play/characters/character", 
           new SetNextRule("addCharacter", "xml.digester.Character"));
rules.add( "plays/play/characters/character", new SetPropertiesRule( ) );
rules.add( "plays/play/characters/character/name", 
           new BeanPropertySetterRule("name") );
rules.add( "plays/play/characters/character/description", 
           new BeanPropertySetterRule("description") );</programlisting>

      <para>While this is perfectly acceptable, think twice about defining
      Digester rule sets programmatically. Defining rule sets in an XML
      document provides a very clear separation between the framework used to
      parse XML and the configuration of the Digester. When your rule sets are
      separate from compiled code, it will be easier to update and maintain
      logic involved in parsing; a change in the XML document structure would
      not involve changing code that deals with parsing. Instead, you would
      change the model and the mapping document. Defining Digester rule sets
      in an XML document is a relatively new Digester feature, and, because of
      this, you may find that some of the more advanced capabilities of
      Digester demonstrated later in this chapter are not available when
      defining rule sets in XML.</para>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>More information about Digester<indexterm class="endofrange"
      id="xml-ITERM-2699" significance="normal"
      startref="xml-ITERM-2693"></indexterm> <indexterm class="endofrange"
      id="xml-ITERM-2700" significance="normal"
      startref="xml-ITERM-2694"></indexterm> <indexterm class="endofrange"
      id="xml-ITERM-2701" significance="normal"
      startref="xml-ITERM-2695"></indexterm> <indexterm class="endofrange"
      id="xml-ITERM-2702" significance="normal"
      startref="xml-ITERM-2696"></indexterm> XML rule sets can be found in the
      package document for <literal
      moreinfo="none">org.apache.commons.digester.xmlrules</literal> (<ulink
      url="http://commons.apache.org/digester/apidocs/index.html">http://commons.apache.org/digester/apidocs/index.html</ulink>).</para>
    </sect2>
  </sect1>

  <sect1 id="xml-sect-namespace-aware" label="6.3" role="Recipe">
    <title>Namespace-Aware Parsing</title>

    <sect2>
      <title>Problem</title>

      <para>You need to parse an XML document with multiple namespaces.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use Digester to parse<indexterm class="startofrange"
          id="xml-ITERM-2703" significance="normal">
          <primary>XML (Extensible Markup Language)</primary>

          <secondary>documents</secondary>

          <tertiary>namespace-aware parsing</tertiary>
        </indexterm> <indexterm class="startofrange" id="xml-ITERM-2704"
          significance="normal">
          <primary>documents</primary>

          <secondary>XML</secondary>

          <tertiary>namespace-aware parsing</tertiary>
        </indexterm> <indexterm class="startofrange" id="xml-ITERM-2705"
          significance="normal">
          <primary>namespace-aware parsing</primary>
        </indexterm> <indexterm class="startofrange" id="xml-ITERM-2706"
          significance="normal">
          <primary>parsing</primary>

          <secondary>namespace-aware</secondary>
        </indexterm> XML with multiple namespaces, using <literal
      moreinfo="none">digester.setNamespaceAware(true)</literal>, and
      supplying two <literal moreinfo="none">RuleSet</literal> objects to
      parse elements in each namespace. Consider the following document, which
      contains elements from two namespaces: <filename
      moreinfo="none">http://discursive.com/page</filename> and <filename
      moreinfo="none">http://discursive.com/person</filename>:</para>

      <programlisting format="linespecific" id="I_6_tt264">&lt;?xml version="1.0"?&gt;

&lt;pages xmlns="http://discursive.com/page"
       xmlns:person="http://discursive.com/person"&gt;
  &lt;page type="standard"&gt;
    &lt;person:person firstName="Al" lastName="Gore"&gt;
      &lt;person:role&gt;Co-author&lt;/person:role&gt; 
    &lt;/person:person&gt;
    &lt;person:person firstName="George" lastName="Bush"&gt;
      &lt;person:role&gt;Co-author&lt;/person:role&gt; 
    &lt;/person:person&gt;
  &lt;/page&gt;
&lt;/pages&gt;</programlisting>

      <para>To parse this XML document with the Digester, you need to create
      two separate sets of rules for each namespace, adding each <literal
      moreinfo="none">RuleSet</literal> object to <literal
      moreinfo="none">Digester</literal> with <literal
      moreinfo="none">addRuleSet( )</literal>. A <literal
      moreinfo="none">RuleSet</literal> adds <literal
      moreinfo="none">Rule</literal> objects to an instance of <literal
      moreinfo="none">Digester</literal>. By extending the <literal
      moreinfo="none">RuleSetBase</literal> class, and setting the <literal
      moreinfo="none">namespaceURI</literal> in the default constructor, the
      following class, <literal moreinfo="none">PersonRuleSet</literal>,
      defines rules to parse the <filename
      moreinfo="none">http://discursive.com/person</filename>
      namespace:</para>

      <programlisting format="linespecific" id="I_6_tt265">import org.apache.commons.digester.Digester;
import org.apache.commons.digester.RuleSetBase;

public class PersonRuleSet extends RuleSetBase {
    public PersonRuleSet( ) {
        this.namespaceURI = "http://discursive.com/person";
    }

    public void addRuleInstances(Digester digester) {
        digester.addObjectCreate("*/person", Person.class);
        digester.addSetNext("*/person", "addPerson");
        digester.addSetProperties("*/person");
        digester.addBeanPropertySetter("*/person/role", "role");
    }
}</programlisting>

      <para><literal moreinfo="none">PersonRuleSet</literal> extends <literal
      moreinfo="none">RuleSetBase</literal> <indexterm id="xml-ITERM-2707"
          significance="normal">
          <primary>RuleSetBase</primary>
        </indexterm>, which is an implementation of the <literal
      moreinfo="none">RuleSet</literal> <indexterm id="xml-ITERM-2708"
          significance="normal">
          <primary>interfaces</primary>

          <secondary>RuleSet</secondary>
        </indexterm> interface. <literal moreinfo="none">RuleSetBase</literal>
      adds support for namespaces with a protected field <literal
      moreinfo="none">namespaceURI</literal>. The constructor of <literal
      moreinfo="none">PersonRuleSet</literal> <indexterm id="xml-ITERM-2709"
          significance="normal">
          <primary>PersonRuleSet</primary>
        </indexterm> sets the <literal moreinfo="none">namespaceURI</literal>
      field to <filename
      moreinfo="none">http://discursive.com/person</filename>, which tells the
      <literal moreinfo="none">Digester</literal> to apply these rules only to
      elements and attributes in the <filename
      moreinfo="none">http://discursive.com/person</filename> namespace.
      <literal moreinfo="none">PageRuleSet</literal> extends <literal
      moreinfo="none">RuleSetBase</literal> and provides a set of rules for
      the <filename moreinfo="none">http://discursive.com/page</filename>
      namespace:</para>

      <programlisting format="linespecific" id="I_6_tt266">import org.apache.commons.digester.Digester;
import org.apache.commons.digester.RuleSetBase;

public class PageRuleSet extends RuleSetBase {
    public PageRuleSet( ) {
        this.namespaceURI = "http://discursive.com/page";
    }

    public void addRuleInstances(Digester digester) {
        digester.addObjectCreate("*/page", Page.class);
        digester.addSetNext("*/page", "addPage");
        digester.addSetProperties("*/page");
        digester.addBeanPropertySetter("*/page/summary", "summary");
    }
}</programlisting>

      <para>Both <literal moreinfo="none">RuleSet</literal> implementations
      instruct the Digester to create a <literal
      moreinfo="none">Page</literal> or a <literal
      moreinfo="none">Person</literal> object whenever either element is
      encountered. The <literal moreinfo="none">PageRuleSet</literal>
      instructs the Digester to create a <literal
      moreinfo="none">Page</literal> object when a <literal
      moreinfo="none">page</literal> element is encountered by using a
      wildcard pattern—<filename moreinfo="none">*/page</filename>. Both
      <literal moreinfo="none">PageRuleSet</literal> and <literal
      moreinfo="none">PersonRuleSet</literal> use <literal
      moreinfo="none">digester.addSetNext( )</literal> to add the objects just
      created to the next object in the <literal
      moreinfo="none">Stack</literal>. In the following code, an instance of
      <literal moreinfo="none">Pages</literal> is pushed onto the Digester
      <literal moreinfo="none">Stack</literal>, and both <literal
      moreinfo="none">RuleSet</literal> implementations are added to a
      <literal moreinfo="none">Digester</literal> using <literal
      moreinfo="none">addRuleSet()</literal> <indexterm id="xml-ITERM-2710"
          significance="normal">
          <primary>addRuleSet( ) method</primary>
        </indexterm> <indexterm id="xml-ITERM-2711" significance="normal">
          <primary>methods</primary>

          <secondary>addRuleSet( )</secondary>
        </indexterm>:</para>

      <programlisting format="linespecific" id="I_6_tt267">import org.apache.commons.digester.Digester;
import org.apache.commons.digester.ObjectCreateRule;
import org.apache.commons.digester.RuleSetBase;
import org.apache.commons.digester.Rules;
import org.apache.commons.digester.SetNextRule;

Pages pages = new Pages( );
        
Digester digester = new Digester( );
digester.setNamespaceAware(true);
digester.addRuleSet( new PageRuleSet( ) );
digester.addRuleSet( new PersonRuleSet( ) );
        
digester.push(pages);

InputStream input = getClass( ).getResourceAsStream("./content.xml");
digester.parse(input);

Page page = (Page) pages.getPages( ).get(0);
System.out.println(page);</programlisting>

      <para>Because the <literal moreinfo="none">PageRuleSet</literal> adds
      each <literal moreinfo="none">Page</literal> object to the next object
      on the <literal moreinfo="none">Stack</literal>, the <literal
      moreinfo="none">Pages</literal> object has an <literal
      moreinfo="none">addPage( )</literal> method that accepts a <literal
      moreinfo="none">Page</literal> object.</para>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>Each of the <literal moreinfo="none">RuleSet</literal>
      implementations defined a set of rules in compiled Java code. If you
      prefer to define each set of rules in an XML file, you may use the
      <literal moreinfo="none">FromXmlRuleSet</literal> instead of the
      <literal moreinfo="none">RuleSetBase</literal>, as follows:</para>

      <programlisting format="linespecific" id="I_6_tt268">import org.apache.commons.digester.Digester;
import org.apache.commons.digester.xmlrules.FromXmlRuleSet;

Pages pages = new Pages( );
        
Digester digester = new Digester( );
digester.setNamespaceAware(true);

// Add page namespace
digester.setRuleNamespaceURI("http://discursive.com/page");
URL pageRules = getClass( ).getResource("./page-rules.xml");
digester.addRuleSet( new FromXmlRuleSet( pageRules ) );
    
// Add person namespace
digester.setRuleNamespaceURI("http://discursive.com/person");
URL personRules = getClass( ).getResource("./person-rules.xml");
digester.addRuleSet( new FromXmlRuleSet( personRules ) );
        
digester.push(pages);

InputStream input = getClass( ).getResourceAsStream("./content.xml");
digester.parse(input);

Page page = (Page) pages.getPages( ).get(0);
System.out.println(page);</programlisting>

      <para>Calling <literal moreinfo="none">digester.setRuleNamespaceURI(
      )</literal> associates the <literal moreinfo="none">Rule</literal>s
      contained in each <literal moreinfo="none">FromXmlRuleSet</literal> with
      a specific namespace. In the Solution, the <literal
      moreinfo="none">RuleSetBase</literal> protected field <literal
      moreinfo="none">namespaceURI</literal> was used to associate <literal
      moreinfo="none">RuleSet</literal> objects with namespaces. In the
      previous example, the namespace is specified by calling <literal
      moreinfo="none">setRuleNamespaceURI( )</literal> before each <literal
      moreinfo="none">FromXmlRuleSet</literal> is added to the <literal
      moreinfo="none">digester</literal> because there is no access to the
      protected member variable, <literal
      moreinfo="none">namespaceURI</literal>, which <literal
      moreinfo="none">FromXmlRuleSet</literal> inherits from <literal
      moreinfo="none">RuleSetBase</literal>. <filename
      moreinfo="none">person-rules.xml</filename> contains an XML rule set for
      parsing the <filename
      moreinfo="none">http://discursive.com/person</filename>
      namespace:</para>

      <programlisting format="linespecific" id="I_6_tt269">&lt;?xml version="1.0"?&gt;

&lt;!DOCTYPE digester-rules PUBLIC 
        "-//Jakarta Apache //DTD digester-rules XML V1.0//EN" 
        "http://commons.apache.org/digester/dtds/digester-rules.dtd"&gt;

&lt;digester-rules&gt;
  &lt;pattern value="*/page"&gt;
    &lt;object-create-rule classname="com.discursive.jccook.xml.bean.Page"/&gt;
    &lt;set-next-rule methodname="addPage"/&gt;
    &lt;set-properties-rule/&gt;
    &lt;bean-property-setter-rule pattern="summary" name="summary"/&gt;
  &lt;/pattern&gt;
&lt;/digester-rules&gt;</programlisting>

      <para><literal moreinfo="none">page-rules.xml</literal> contains an XML
      rule set for parsing the <filename
      moreinfo="none">http://discursive.com/page</filename> namespace:</para>

      <programlisting format="linespecific" id="I_6_tt270">&lt;?xml version="1.0"?&gt;

&lt;!DOCTYPE digester-rules PUBLIC 
        "-//Jakarta Apache //DTD digester-rules XML V1.0//EN" 
        "http://commons.apache.org/digester/dtds/digester-rules.dtd"&gt;

&lt;digester-rules&gt;
  &lt;pattern value="*/person"&gt;
    &lt;object-create-rule classname="com.discursive.jccook.xml.bean.Person"/&gt;
    &lt;set-next-rule methodname="addPerson"/&gt;
    &lt;set-properties-rule/&gt;
    &lt;bean-property-setter-rule pattern="role"/&gt;
  &lt;/pattern&gt;
&lt;/digester-rules&gt;</programlisting>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>For more information relating to the use<indexterm
      class="endofrange" id="xml-ITERM-2712" significance="normal"
      startref="xml-ITERM-2703"></indexterm> <indexterm class="endofrange"
      id="xml-ITERM-2713" significance="normal"
      startref="xml-ITERM-2704"></indexterm> <indexterm class="endofrange"
      id="xml-ITERM-2714" significance="normal"
      startref="xml-ITERM-2705"></indexterm> <indexterm class="endofrange"
      id="xml-ITERM-2715" significance="normal"
      startref="xml-ITERM-2706"></indexterm> of namespaces in the <literal
      moreinfo="none">Digester</literal>, refer to the Javadoc for the
      <literal moreinfo="none">org.apache.commons.digester</literal> package
      at <ulink
      url="http://jakarta.apache.org/commons/digester/apidocs">http://commons.apache.org/digester/apidocs</ulink>.</para>
    </sect2>
  </sect1>

  <sect1 id="xml-sect-creating-simple-cmd-lang" label="6.4" role="Recipe">
    <title>Creating a Simple XML Command Language</title>

    <sect2>
      <title>Problem</title>

      <para>You would like to capture <indexterm class="startofrange"
          id="xml-ITERM-2716" significance="normal">
          <primary>XML (Extensible Markup Language)</primary>

          <secondary>documents</secondary>

          <tertiary>commands</tertiary>
        </indexterm> <indexterm class="startofrange" id="xml-ITERM-2717"
          significance="normal">
          <primary>documents</primary>

          <secondary>XML</secondary>

          <tertiary>commands</tertiary>
        </indexterm> <indexterm class="startofrange" id="xml-ITERM-2718"
          significance="normal">
          <primary>commands, XML</primary>
        </indexterm> <indexterm class="startofrange" id="xml-ITERM-2719"
          significance="normal">
          <primary>capturing</primary>

          <secondary>XML commands</secondary>
        </indexterm>commands in an XML document, and create a framework to
      execute these commands.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Write a custom implementation of <literal
      moreinfo="none">Rule</literal>, and create a rule set that instructs
      Commons Digester to invoke these rules when specific elements are
      parsed. Consider the example of a system that sends an encrypted email.
      The following XML document contains instructions for the primitive
      encryption of an email:</para>

      <programlisting format="linespecific" id="I_6_tt271">&lt;?xml version="1.0"?&gt;

&lt;operations xmlns="http://discursive.com/textmanip"&gt;
  &lt;email to="tobrien@discursive.com"
         from="root@discursive.com"&gt;
    &lt;replace search="o" replace="q"/&gt;
    &lt;replace search="d" replace="z"/&gt;
    &lt;lower/&gt;
    &lt;reverse/&gt;
  &lt;/email&gt;
&lt;/operations&gt;</programlisting>

      <para>The<indexterm id="xml-ITERM-2720" significance="normal">
          <primary>email</primary>

          <secondary>tags</secondary>
        </indexterm> <indexterm id="xml-ITERM-2721" significance="normal">
          <primary>tags</primary>

          <secondary>email</secondary>
        </indexterm> <literal moreinfo="none">email</literal> tag surrounds
      three elements—<literal moreinfo="none">replace</literal>, <literal
      moreinfo="none">lower</literal>, and <literal
      moreinfo="none">reverse</literal>. The system that executes these
      commands receives a message as a <literal
      moreinfo="none">String</literal> and runs this <literal
      moreinfo="none">String</literal> through three stages before sending an
      email to <filename moreinfo="none">tobrien@discursive.com</filename>.
      When the parser encounters the <literal
      moreinfo="none">replace</literal> element, it replaces all occurrences
      of the contents of the <literal moreinfo="none">search</literal>
      attribute with the contents of the <literal
      moreinfo="none">replace</literal> attribute. When the parser encounters
      a <literal moreinfo="none">lower</literal> element, it translates all
      characters to lowercase; and when the parser encounters a <literal
      moreinfo="none">reverse</literal> element, it reverses the <literal
      moreinfo="none">String</literal>. When the parser encounters the end of
      the <literal moreinfo="none">email</literal> element, the result of
      these four operations is sent to the recipient specified in the <literal
      moreinfo="none">to</literal> attribute of the <literal
      moreinfo="none">email</literal> element.</para>

      <programlisting format="linespecific" id="I_6_tt272">import org.apache.commons.digester.Digester;

// Message object that holds text to manipulate
Message message = new Message( );
message.setText( "Hello World!" );
        
System.out.println( "Initial Message: " + message.getText( ) );

// XML Document with set of commands            
InputStream encrypt = getClass( ).getResourceAsStream("./encrypt.xml");

// Create Custom Rules (or Commands)
Digester digester = new Digester( );
digester.addRule( "*/email", new EmailRule( ) );
digester.addRule( "*/lower", new LowerRule( ) );
digester.addRule( "*/reverse", new ReverseRule( ) );
digester.addRule( "*/replace", new ReplaceRule( ) );
digester.push( message );
      
// Parse the XML document - execute commands
digester.parse( encrypt );

System.out.println("Resulting Message: " + message.getText( ) );</programlisting>

      <para>The <literal moreinfo="none">Message</literal> object is a bean
      with one <literal moreinfo="none">String</literal> property: <literal
      moreinfo="none">text</literal>. This <literal
      moreinfo="none">Message</literal> object is pushed onto the <literal
      moreinfo="none">Digester</literal>'s <literal
      moreinfo="none">Stack</literal> and is acted upon by each of the
      commands in the XML document <filename
      moreinfo="none">encrypt.xml</filename>, shown previously. This code is
      executed, and the following output is produced showing that the original
      message has been passed through two replace commands, a lowercase
      command, and a reverse command:</para>

      <programlisting format="linespecific" id="I_6_tt273">Intial Message: Hello World!
Resulting Message: !zlrqw qlleh</programlisting>

      <para>This example defines three new extensions of <literal
      moreinfo="none">Rule</literal>: <literal
      moreinfo="none">EmailRule</literal>, <literal
      moreinfo="none">LowerRule</literal>, <literal
      moreinfo="none">ReverseRule</literal>, and <literal
      moreinfo="none">ReplaceRule</literal>. Each of these rules will retrieve
      and operate upon the root object from the <literal
      moreinfo="none">Digester</literal>; this "root" object is the bottom of
      the <literal moreinfo="none">Stack</literal>, and, in this case, the
      <literal moreinfo="none">Message</literal> object pushed onto the
      <literal moreinfo="none">Digester</literal> before parsing. These rules
      are assigned to patterns; for example, the previous code associates the
      <literal moreinfo="none">EmailRule</literal> with the <filename
      moreinfo="none">*/email</filename> pattern and the <literal
      moreinfo="none">LowerRule</literal> with the <filename
      moreinfo="none">*/lower</filename> pattern. The <literal
      moreinfo="none">Rule</literal> object defines a series of callback
      methods to handle different stages of parsing an element—<literal
      moreinfo="none">begin( )</literal>, <literal moreinfo="none">body(
      )</literal>, <literal moreinfo="none">end( )</literal>, and <literal
      moreinfo="none">finish( )</literal>. The <literal
      moreinfo="none">LowerRule</literal> from the previous example overrides
      one method, and manipulates the <literal
      moreinfo="none">Message</literal> that which is on the top of the
      <indexterm id="xml-ITERM-2722" significance="normal">
          <primary>Commons Digester</primary>

          <secondary>Stack</secondary>
        </indexterm> <literal moreinfo="none">Digester</literal> <literal
      moreinfo="none">Stack</literal>:</para>

      <programlisting format="linespecific" id="I_6_tt274">package com.discursive.jccook.xml.bean;

import org.apache.commons.digester.Rule;
import org.apache.commons.lang.StringUtils;


public class LowerRule extends Rule {
    public LowerRule( ) { super( ); }

    public void body(String namespace, String name, String text)
            throws Exception {
        Message message = (Message) digester.getRoot( );
        String lower = StringUtils.lowerCase( message.getText( ) );
        message.setText( lower );
    }
}</programlisting>

      <para><literal moreinfo="none">LowerRule</literal> uses <literal
      moreinfo="none">StringUtils</literal> from Commons Lang to translate the
      <literal moreinfo="none">text</literal> property of the <literal
      moreinfo="none">Message</literal> object to lowercase. If you need to
      write a <literal moreinfo="none">Rule</literal> that can access
      attributes, you would override the <literal moreinfo="none">begin(
      )</literal> method. The following class, <literal
      moreinfo="none">ReplaceRule</literal>, extends <literal
      moreinfo="none">Rule</literal> and overrides the <literal
      moreinfo="none">begin( )</literal> <indexterm id="xml-ITERM-2723"
          significance="normal">
          <primary>begin( ) method</primary>
        </indexterm> <indexterm id="xml-ITERM-2724" significance="normal">
          <primary>methods</primary>

          <secondary>begin( )</secondary>
        </indexterm> method:</para>

      <programlisting format="linespecific" id="I_6_tt275">package com.discursive.jccook.xml.bean;

import org.apache.commons.digester.Rule;
import org.apache.commons.lang.StringUtils;
import org.xml.sax.Attributes;

public class ReplaceRule extends Rule {
    public ReplaceRule( ) { super( ); }

    public void begin(Attributes attributes) throws Exception {
        Message message = (Message) digester.getRoot( );
        
        String repl = attributes.getValue("search");
        String with = attributes.getValue("replace");
        String text = message.getText( );
        
        String translated = 
            StringUtils.replace( text, repl, with );
        message.setText( translated );
    }
}</programlisting>

      <para><literal moreinfo="none">ReplaceRule</literal> reads the <literal
      moreinfo="none">search</literal> and <literal
      moreinfo="none">replace</literal> attributes, using <literal
      moreinfo="none">StringUtils</literal> to replace all occurrences of the
      search <literal moreinfo="none">String</literal> in the <literal
      moreinfo="none">text</literal> property of <literal
      moreinfo="none">Message</literal> with the replace <literal
      moreinfo="none">String</literal>. The <literal
      moreinfo="none">EmailRule</literal> demonstrates a more complex
      extension of the <literal moreinfo="none">Rule</literal> object by
      overriding <literal moreinfo="none">begin( )</literal> and <literal
      moreinfo="none">end( )</literal>:</para>

      <programlisting format="linespecific" id="I_6_tt276">import org.apache.commons.digester.Rule;
import org.apache.commons.net.smtp.SMTPClient;
import org.xml.sax.Attributes;

public class EmailRule extends Rule {
    private String to;
    private String from;
    
    public EmailRule( ) { super( ); }
    
    public void begin(Attributes attributes) throws Exception {
        to = attributes.getValue( "to" );
        from = attributes.getValue( "from" );
    }

    public void end( ) throws Exception {
        Message message = (Message) digester.getRoot( );
        
        SMTPClient client = new SMTPClient( );
        client.connect("www.discursive.com");
        client.sendSimpleMessage(from, to, message.getText( ) );
    }
}</programlisting>

      <para>The <literal moreinfo="none">email</literal> element encloses the
      four elements that control the primitive message encryption, and the end
      of this element tells this rule to send an email to the address
      specified in the <literal moreinfo="none">to</literal> attribute
      recorded in <literal moreinfo="none">begin()</literal>. <literal
      moreinfo="none">EmailRule</literal> uses the <literal
      moreinfo="none">SMTPClient</literal> from Commons Net to send a simple
      email in <literal moreinfo="none">end( )</literal>.</para>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>The <literal moreinfo="none">Rule</literal> class defines four
      methods that you can override to execute code when XML is
      parsed—<literal moreinfo="none">begin( )</literal>, <literal
      moreinfo="none">body( )</literal>, <literal moreinfo="none">end(
      )</literal>, and <literal moreinfo="none">finish( )</literal>. <literal
      moreinfo="none">begin( )</literal> provides access to an element's
      attributes; <literal moreinfo="none">body( )</literal> provides access
      to the element's namespace, local name, and body text; <literal
      moreinfo="none">end( )</literal> is called when the end of an element is
      encountered; and <literal moreinfo="none">finish( )</literal> is called
      after <literal moreinfo="none">end( )</literal> and can be used to clean
      up data or release resources, such as open network connections or files.
      When using the Digester in this manner, you are using a technique much
      closer to writing a SAX parser; instead of dealing with a single
      <literal moreinfo="none">startElement</literal>, <literal
      moreinfo="none">Digester</literal> registers itself as a content handler
      with an <literal moreinfo="none">XMLReader</literal> and delegates to
      <literal moreinfo="none">Rule</literal> objects associated with a given
      pattern. If you are simply dealing with attributes, elements, and text
      nodes, Commons Digester can be a very straightforward alternative to
      writing a <indexterm id="xml-ITERM-2725" significance="normal">
          <primary>parsing</primary>

          <secondary>SAX</secondary>
        </indexterm> <indexterm id="xml-ITERM-2726" significance="normal">
          <primary>SAX parsers</primary>
        </indexterm>SAX parser.</para>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>This recipe uses <literal moreinfo="none">StringUtils</literal> to
      manipulate<indexterm class="endofrange" id="xml-ITERM-2727"
      significance="normal" startref="xml-ITERM-2716"></indexterm> <indexterm
      class="endofrange" id="xml-ITERM-2728" significance="normal"
      startref="xml-ITERM-2717"></indexterm> <indexterm class="endofrange"
      id="xml-ITERM-2729" significance="normal"
      startref="xml-ITERM-2718"></indexterm> <indexterm class="endofrange"
      id="xml-ITERM-2730" significance="normal"
      startref="xml-ITERM-2719"></indexterm> text. For more information about
      <literal moreinfo="none">StringUtils</literal>, see <link
      linkend="manipulate-text">Chapter 2</link>. An email message is sent
      from the <literal moreinfo="none">EmailRule</literal> using the <literal
      moreinfo="none">SMTPClient</literal> from Commons Net. For more
      information about Commons Net, see <link linkend="io-network">Chapter
      10</link>.</para>
    </sect2>
  </sect1>

  <sect1 id="xml-sect-var-sub" label="6.5" role="Recipe">
    <title>Variable Substitution and XML Parsing</title>

    <sect2>
      <title>Problem</title>

      <para>You need to parse XML that <indexterm class="startofrange"
          id="xml-ITERM-2731" significance="normal">
          <primary>XML (Extensible Markup Language)</primary>

          <secondary>parsing</secondary>
        </indexterm> <indexterm class="startofrange" id="xml-ITERM-2732"
          significance="normal">
          <primary>documents</primary>

          <secondary>XML</secondary>

          <tertiary>parsing</tertiary>
        </indexterm> <indexterm class="startofrange" id="xml-ITERM-2733"
          significance="normal">
          <primary>parsing</primary>

          <secondary>XML, variable substitutions</secondary>
        </indexterm> <indexterm class="startofrange" id="xml-ITERM-2734"
          significance="normal">
          <primary>variables</primary>

          <secondary>substitution (XML)</secondary>
        </indexterm> <indexterm class="startofrange" id="xml-ITERM-2735"
          significance="normal">
          <primary>references, variable substitution (XML)</primary>
        </indexterm>contains references to variables, and you need to replace
      these references with variable values at parse time.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use Commons Digester's <literal
      moreinfo="none">MultiVariableExpander</literal> <indexterm
          id="xml-ITERM-2736" significance="normal">
          <primary>MultiVariableExpander</primary>
        </indexterm> and the <literal
      moreinfo="none">VariableSubstitutor</literal> <indexterm
          id="xml-ITERM-2737" significance="normal">
          <primary>VariableSubstitutor</primary>
        </indexterm> to expand variable references in an XML document during a
      parse.</para>

      <para>The following XML document contains four variable
      references—<filename moreinfo="none">${email.to}</filename>, <filename
      moreinfo="none">${order.id}</filename>, <filename
      moreinfo="none">${user.name}</filename>, and <filename
      moreinfo="none">${product.name}—</filename>all of which need to be
      replaced with values before the XML is parsed by the <literal
      moreinfo="none">Digester</literal>:</para>

      <programlisting format="linespecific" id="I_6_tt277">&lt;?xml version="1.0"?&gt;

&lt;email to="${email.to}" from="ceo@xyzblah.com"&gt;
  &lt;subject&gt;Purchase Confirmation: ${order.id}&lt;/subject&gt;
  &lt;priority&gt;High&lt;/priority&gt;
  &lt;message&gt;
    Dear ${user.name}, we appreciate your business. As CEO
    of Big Software Company, Inc., I would like to
    personally thank you for helping us become filthy rich.
    Your purchase of ${product.name} helped me purchase an 
    even larger boat for myself.  Thanks again.
  &lt;/message&gt;
&lt;/email&gt;</programlisting>

      <para>This document represents a purchase confirmation message, and your
      system needs to unmarshall the above message to the following class,
      <literal moreinfo="none">Email</literal>:</para>

      <programlisting format="linespecific" id="I_6_tt278">public class Email {
    private String to;
    private String from;
    private String subject;
    private String priority;

    // accessors omitted for brevity.
}</programlisting>

      <para>The following XML rule set is similar to the rule set defined in
      <link linkend="xml-sect-xml-doc-obj">Recipe 6.2</link>. When the parser
      hits an <literal moreinfo="none">email</literal> element, an instance of
      <literal moreinfo="none">Email</literal> is created and properties are
      populated:</para>

      <programlisting format="linespecific" id="I_6_tt279">&lt;?xml version="1.0"?&gt;

&lt;digester-rules&gt;
  &lt;pattern value="email"&gt;
    &lt;object-create-rule classname="com.discursive.jccook.xml.bean.Email"/&gt;
    &lt;set-next-rule methodname="add" paramtype="java.lang.Object"/&gt;
    &lt;set-properties-rule/&gt;
    &lt;bean-property-setter-rule pattern="subject"/&gt;
    &lt;bean-property-setter-rule pattern="priority"/&gt;
    &lt;bean-property-setter-rule pattern="message"/&gt;
  &lt;/pattern&gt;
&lt;/digester-rules&gt;</programlisting>

      <para>This difference between this recipe and <link
      linkend="xml-sect-xml-doc-obj">Recipe 6.2</link> is that our XML
      document contains variables to be replaced at parse time. The following
      code creates a <literal moreinfo="none">Map</literal> that contains
      variables referenced in the XML document being parsed. This code creates
      the variable <literal moreinfo="none">Map</literal>, reads the XML rule
      set from <filename moreinfo="none">email-rules.xml</filename>, and
      parses the XML document <filename
      moreinfo="none">email.xml</filename>:</para>

      <programlisting format="linespecific" id="I_6_tt280">import org.apache.commons.digester.Digester;
import org.apache.commons.digester.Substitutor;
import org.apache.commons.digester.substitution.MultiVariableExpander;
import org.apache.commons.digester.substitution.VariableSubstitutor;
import org.apache.commons.digester.xmlrules.DigesterLoader;

// Read the Digester XML rule set and create Digester
URL rules = getClass( ).getResource("./email-rules.xml");
Digester digester = DigesterLoader.createDigester(rules);

// Create object to push onto Digester Stack
List emails = new ArrayList( );
digester.push( emails );

<userinput moreinfo="none">// Create Map of variables</userinput>
               <userinput moreinfo="none">Map vars = new HashMap( );</userinput>
               <userinput moreinfo="none">vars.put("email.to", "ldavid@hbo.com");</userinput>
               <userinput moreinfo="none">vars.put("user.name", "Tim");</userinput>
               <userinput moreinfo="none">vars.put("order.id", "1RR2E223WVVS" );</userinput>
               <userinput moreinfo="none">vars.put("product.name", "Foundation" );</userinput>
               <userinput moreinfo="none">        </userinput>
               <userinput moreinfo="none">// Create an expander with the Map that matches ${var}</userinput>
               <userinput moreinfo="none">MultiVariableExpander expander = new MultiVariableExpander( );</userinput>
               <userinput moreinfo="none">expander.addSource("$", vars);</userinput>

               <userinput moreinfo="none">// Create a substitutor with the expander</userinput>
               <userinput moreinfo="none">Substitutor substitutor = new VariableSubstitutor(expander);</userinput>
               <userinput moreinfo="none">digester.setSubstitutor(substitutor);</userinput>
        
// Parse XML document
InputStream input = getClass( ).getResourceAsStream("./email.xml");
digester.parse( input );

// Retrieve Email object
Email email = (Email) emails.get(0);
System.out.println( "Email Subject: " + email.getSubject( ) );
System.out.println( "Email To: " + email.getTo( ) );</programlisting>

      <para>Variable substitution is performed by a <literal
      moreinfo="none">VariableSubstitutor</literal> that has been configured
      with a <literal moreinfo="none">MultiVariableExpander</literal>. The
      <literal moreinfo="none">MultiVariableExpander</literal> retrieves
      variables from a <literal moreinfo="none">Map</literal>, and, in this
      example, the <literal moreinfo="none">addSource( )</literal> method is
      called with a <literal moreinfo="none">$</literal> marker. This means
      that variables are referenced by surrounding a variable name with
      <literal moreinfo="none">${</literal> and <literal
      moreinfo="none">}--${variable}</literal>. The previous example produces
      the following output, which demonstrates the substitution of
      variables:</para>

      <programlisting format="linespecific" id="I_6_tt281">Email Subject: Purchase Confirmation: 1RR2E223WVVS
Email To: ldavid@hbo.com</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>Variable substitution is part parsing, part templating, and can be
      valuable when you need to specify a set of default properties on a bean
      that need to be parameterized for different situations. The example in
      this recipe was an email message confirming a purchase from an
      e-commerce system, but there are other situations where an object may
      need to be personalized with a user identifier or a username.</para>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>For more information about other new features planned for Digester
      1.6, see the current development Javadoc <indexterm class="endofrange"
      id="xml-ITERM-2738" significance="normal"
      startref="xml-ITERM-2731"></indexterm> <indexterm class="endofrange"
      id="xml-ITERM-2739" significance="normal"
      startref="xml-ITERM-2732"></indexterm> <indexterm class="endofrange"
      id="xml-ITERM-2740" significance="normal"
      startref="xml-ITERM-2733"></indexterm> <indexterm class="endofrange"
      id="xml-ITERM-2741" significance="normal"
      startref="xml-ITERM-2734"></indexterm> <indexterm class="endofrange"
      id="xml-ITERM-2742" significance="normal"
      startref="xml-ITERM-2735"></indexterm>for the Digester at <ulink
      url="http://jakarta.apache.org/commons/digester/apidocs/index.html">http://commons.apache.org/digester/apidocs/index.html</ulink>.</para>
    </sect2>
  </sect1>

  <sect1 id="xml-sect-obtaining-betwixt" label="6.6" role="Recipe">
    <title>Obtaining Commons Betwixt</title>

    <sect2>
      <title>Problem</title>

      <para>You need to use <indexterm id="xml-ITERM-2743"
          significance="normal">
          <primary>XML (Extensible Markup Language)</primary>

          <secondary>Commons Betwixt</secondary>
        </indexterm> <indexterm id="xml-ITERM-2744" significance="normal">
          <primary>documents</primary>

          <secondary>XML</secondary>

          <tertiary>Commons Betwixt</tertiary>
        </indexterm> <indexterm id="xml-ITERM-2745" significance="normal">
          <primary>downloading</primary>

          <secondary>Commons Betwixt</secondary>
        </indexterm> <indexterm id="xml-ITERM-2746" significance="normal">
          <primary>Commons Betwixt, downloading</primary>
        </indexterm> <indexterm id="xml-ITERM-2747" significance="normal">
          <primary>beans</primary>

          <secondary>Commons Betwixt</secondary>
        </indexterm> Commons Betwixt to serialize and deserialize beans to and
      from XML documents.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>To use Commons Betwixt in a Maven 2 project, add the following
      dependency to your project's <filename>pom.xml</filename>:</para>

      <example>
        <title>Adding a Dependency on Commons Betwixt</title>

        <programlisting>    &lt;dependency&gt;
        &lt;groupId&gt;commons-betwixt&lt;/groupId&gt;
        &lt;artifactId&gt;commons-betwixt&lt;/artifactId&gt;
        &lt;version&gt;0.8&lt;/version&gt;
    &lt;/dependency&gt;
</programlisting>
      </example>

      <para>If you are not sure what this means, I'd suggest reading <ulink
      url="http://www.sonatype.com/books/maven-book">Maven: The Definitive
      Guide</ulink>. When you depend on a library in Maven 2, all you need to
      do is add the dependency <varname>groupId</varname>,
      <varname>artifactId</varname>, and <varname>version</varname> to your
      project's dependencies. Once you do this, Maven 2 will download the
      dependency and make it available on your project's classpath.</para>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>Betwixt allows you to translate from beans to XML and vice versa.
      Beans are serialized to XML documents using a <literal
      moreinfo="none">BeanWriter</literal>, and they are read from XML using a
      <literal moreinfo="none">BeanReader</literal>. The structure of the XML
      can be automatically generated or customized using an XML document to
      bind properties to elements or attributes.</para>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>For more information about Commons Betwixt, see the Commons
      Betwixt project page at <ulink
      url="http://jakarta.apache.org/commons/betwixt">http://jcommons.apache.org/betwixt</ulink>.</para>
    </sect2>
  </sect1>

  <sect1 id="xml-sect-beans-xml" label="6.7" role="Recipe">
    <title>Turning Beans into XML Documents</title>

    <sect2>
      <title>Problem</title>

      <para>You need to create an XML<indexterm class="startofrange"
          id="xml-ITERM-2748" significance="normal">
          <primary>XML (Extensible Markup Language)</primary>

          <secondary>beans</secondary>
        </indexterm> <indexterm class="startofrange" id="xml-ITERM-2749"
          significance="normal">
          <primary>documents</primary>

          <secondary>XML</secondary>

          <tertiary>bean conversion</tertiary>
        </indexterm> <indexterm class="startofrange" id="xml-ITERM-2750"
          significance="normal">
          <primary>beans</primary>

          <secondary>XML</secondary>
        </indexterm> <indexterm class="startofrange" id="xml-ITERM-2751"
          significance="normal">
          <primary>conversion</primary>
        </indexterm> <indexterm class="startofrange" id="xml-ITERM-2752"
          significance="normal">
          <primary>conversion</primary>

          <secondary>XML</secondary>

          <tertiary>beans</tertiary>
        </indexterm> document from a bean.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use Commons Betwixt <literal moreinfo="none">BeanWriter</literal>
      to <indexterm id="xml-ITERM-2753" significance="normal">
          <primary>transformation</primary>

          <secondary>beans</secondary>
        </indexterm>transform a bean to an XML document. The following code
      turns an instance of the <literal moreinfo="none">Play</literal> object
      from <link linkend="xml-sect-xml-doc-obj">Recipe 6.2</link> into an XML
      document:</para>

      <programlisting format="linespecific" id="I_6_tt283">import org.apache.commons.betwixt.io.BeanWriter;

Play play = new Play( );

// populatePlay populates all properties and nested Character objects
populatePlay( play );

// Write XML document
BeanWriter beanWriter = <emphasis role="bold">new</emphasis> BeanWriter( );
beanWriter.enablePrettyPrint( );
beanWriter.write( play );

System.out.println( beanWriter.toString( ) );</programlisting>

      <para>A <literal moreinfo="none">BeanWriter</literal> instance is
      created, indentation is enabled with a call to <literal
      moreinfo="none">enablePrettyPrint( )</literal>, and the <literal
      moreinfo="none">Play</literal> object is written to an XML document with
      <literal moreinfo="none">beanWriter.write( )</literal>. The previous
      example prints an XML document with structure similar to the XML
      document parsed in <link linkend="xml-sect-xml-doc-obj">Recipe
      6.2</link> with the exception of the <literal
      moreinfo="none">genre</literal>, <literal
      moreinfo="none">year</literal>, and <literal
      moreinfo="none">language</literal> elements. The following XML document
      is produced by the call to <literal
      moreinfo="none">beanWriter.write()</literal> <indexterm
          id="xml-ITERM-2754" significance="normal">
          <primary>beanWriter.write( ) method</primary>
        </indexterm> <indexterm id="xml-ITERM-2755" significance="normal">
          <primary>methods</primary>

          <secondary>beanWriter.write( )</secondary>
        </indexterm>:</para>

      <programlisting format="linespecific" id="I_6_tt284">&lt;Play&gt;
  &lt;author&gt;William Shakespeare&lt;/author&gt;
  &lt;characters&gt;
    &lt;character&gt;
      &lt;description&gt;King of Denmark&lt;/description&gt;
      &lt;name&gt;Claudius&lt;/name&gt;
      &lt;protagonist&gt;false&lt;/protagonist&gt;
    &lt;/character&gt;
    &lt;character&gt;
      &lt;description&gt;
        Son to the late, and nephew of the present                
        king
      &lt;/description&gt;
      &lt;name&gt;Hamlet&lt;/name&gt;
      &lt;protagonist&gt;true&lt;/protagonist&gt;
    &lt;/character&gt;
    &lt;character&gt;
      &lt;description&gt;friend to Hamlet&lt;/description&gt;
      &lt;name&gt;Horatio&lt;/name&gt;
      &lt;protagonist&gt;false&lt;/protagonist&gt;
    &lt;/character&gt;
  &lt;/characters&gt;
  &lt;genre&gt;tragedy&lt;/genre&gt;
  &lt;language&gt;english&lt;/language&gt;
  &lt;name&gt;Hamlet&lt;/name&gt;
  &lt;summary&gt;
    Prince of Denmark (Hamlet) freaks out, talks to 
    father's ghost, and finally dies in a duel.
  &lt;/summary&gt;
  &lt;year&gt;1603&lt;/year&gt;
&lt;/Play&gt;</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>Using the <literal moreinfo="none">BeanWriter</literal> is an easy
      way to create XML documents from beans, and if you don't have a
      preference for the layout of the resulting XML document, it is the
      easiest way to serialize an object to XML. The <literal
      moreinfo="none">BeanWriter</literal> offers some control over the
      appearance of the XML it generates. <literal
      moreinfo="none">setEndOfLine( )</literal> takes a <literal
      moreinfo="none">String</literal> that is used as a line termination
      sequence. <literal moreinfo="none">setWriteEmptyElements( )</literal>
      controls the way in which an empty element is written by Betwixt. If
      <literal moreinfo="none">setWriteEmptyElements( )</literal> is passed
      <literal moreinfo="none">true</literal>, an element will be written to
      the XML document even if there are no child nodes or attributes.
      <literal moreinfo="none">setIndent( )</literal> takes a <literal
      moreinfo="none">String</literal> that is used as an indentation string
      when pretty printing—indented output—is enabled using the <literal
      moreinfo="none">enablePrettyPrint( )</literal> method on <literal
      moreinfo="none">BeanWriter</literal>.</para>

      <para>When Betwixt encounters the <literal
      moreinfo="none">List</literal> of <literal
      moreinfo="none">Character</literal> objects, it creates an element
      <literal moreinfo="none">characters</literal>, which holds individual
      <literal moreinfo="none">character</literal> elements created by using
      introspection on the <literal moreinfo="none">Character</literal> class.
      This behavior is configurable, and you can instruct <literal
      moreinfo="none">Betwixt</literal> to omit the <literal
      moreinfo="none">characters</literal> elements in favor of multiple
      <literal moreinfo="none">character</literal> child elements. Such a
      customization is demonstrated in the Discussion of <link
      linkend="xml-sect-customizing-xml">Recipe 6.8</link>.</para>

      <para><literal moreinfo="none">BeanWriter</literal> can also be used to
      write an XML document to an <literal
      moreinfo="none">OutputStream</literal> or a <literal
      moreinfo="none">Writer</literal> by passing a <literal
      moreinfo="none">Writer</literal> or an <literal
      moreinfo="none">OutputStream</literal> to the <literal
      moreinfo="none">BeanWriter</literal> constructor. The following code
      uses a <literal moreinfo="none">BeanWriter</literal> to write an XML
      document to <filename moreinfo="none">test.dat</filename>:</para>

      <programlisting format="linespecific" id="I_6_tt285">import org.apache.commons.betwixt.io.BeanWriter;

Play play = new Play( );
populatePlay( play );

// Open a File Writer
Writer outputWriter = new FileWriter("test.dat");

// Pass FileWriter to BeanWriter
BeanWriter beanWriter = <emphasis role="bold">new</emphasis> BeanWriter( outputWriter );
beanWriter.setEndOfLine( "\r\n" );
beanWriter.setIndent( "\t" );
beanWriter.enablePrettyPrint( );
beanWriter.write( play );

// Close FileWriter
outputWriter.close( );</programlisting>

      <para>Since the previous example contains a call to <literal
      moreinfo="none">setEndOfLine()</literal>, <literal
      moreinfo="none">enablePrettyPrint( )</literal>, and <literal
      moreinfo="none">setIndent( )</literal>, <filename
      moreinfo="none">test.dat</filename> will have DOS-style line termination
      and Betwixt will use the tab character for indentation.</para>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>By default, <literal moreinfo="none">BeanWriter</literal> writes
      every bean <indexterm class="endofrange" id="xml-ITERM-2756"
      significance="normal" startref="xml-ITERM-2748"></indexterm> <indexterm
      class="endofrange" id="xml-ITERM-2757" significance="normal"
      startref="xml-ITERM-2749"></indexterm> <indexterm class="endofrange"
      id="xml-ITERM-2758" significance="normal"
      startref="xml-ITERM-2750"></indexterm> <indexterm class="endofrange"
      id="xml-ITERM-2759" significance="normal"
      startref="xml-ITERM-2751"></indexterm> <indexterm class="endofrange"
      id="xml-ITERM-2760" significance="normal"
      startref="xml-ITERM-2752"></indexterm>property of <literal
      moreinfo="none">Play</literal> as an element. <link
      linkend="xml-sect-customizing-xml">Recipe 6.8</link> shows you how to
      customize the XML generated by Betwixt.</para>
    </sect2>
  </sect1>

  <sect1 id="xml-sect-customizing-xml" label="6.8" role="Recipe">
    <title>Customizing XML Generated from an Object</title>

    <sect2>
      <title>Problem</title>

      <para>You are trying to create an XML<indexterm class="startofrange"
          id="xml-ITERM-2761" significance="normal">
          <primary>XML (Extensible Markup Language)</primary>

          <secondary>object customization</secondary>
        </indexterm> <indexterm class="startofrange" id="xml-ITERM-2762"
          significance="normal">
          <primary>documents</primary>

          <secondary>XML</secondary>

          <tertiary>object customization</tertiary>
        </indexterm> <indexterm class="startofrange" id="xml-ITERM-2763"
          significance="normal">
          <primary>beans</primary>

          <secondary>XML</secondary>
        </indexterm> <indexterm class="startofrange" id="xml-ITERM-2764"
          significance="normal">
          <primary>objects</primary>

          <secondary>customization</secondary>
        </indexterm> <indexterm class="startofrange" id="xml-ITERM-2765"
          significance="normal">
          <primary>objects</primary>

          <secondary>XML</secondary>

          <tertiary>customization</tertiary>
        </indexterm> <indexterm class="startofrange" id="xml-ITERM-2766"
          significance="normal">
          <primary>customization</primary>

          <secondary>objects</secondary>
        </indexterm> <indexterm class="startofrange" id="xml-ITERM-2767"
          significance="normal">
          <primary>BeanWriter, customization</primary>
        </indexterm> document from a Java object, and you want to customize
      the layout and structure of the generated XML document.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use a Betwixt mapping file to customize the output of the <literal
      moreinfo="none">BeanWriter</literal>. Below is an example of a mapping
      file for the <literal moreinfo="none">Play</literal> class, which was
      introduced in <link linkend="xml-sect-xml-doc-obj">Recipe 6.2</link>.
      When Betwixt serializes or deserializes an object to or from XML, it
      will search for a resource, <filename
      moreinfo="none">&lt;classname&gt;.betwixt</filename>, in the same
      package as the class to be written or read. The following XML
      document—<filename moreinfo="none">Play.betwixt—</filename>is stored in
      the same package as the <literal moreinfo="none">Play</literal> class,
      and it customizes the XML output from Betwixt:</para>

      <programlisting format="linespecific" id="I_6_tt286">&lt;info primitiveTypes="element"&gt;
  &lt;element name="play"&gt;
    &lt;attribute name="genre" property="genre"/&gt;
    &lt;attribute name="year" property="year"/&gt;
    &lt;attribute name="language" property="language"/&gt;
    &lt;addDefaults/&gt;
  &lt;/element&gt;
&lt;/info&gt;</programlisting>

      <para>This file tells Betwixt that <literal
      moreinfo="none">genre</literal>, <literal
      moreinfo="none">year</literal>, and <literal
      moreinfo="none">language</literal> shall be stored as XML attributes,
      and that the remaining bean properties are to be written as XML
      elements. The following code is used to create a customized XML document
      from an instance of <literal moreinfo="none">Play</literal>:</para>

      <programlisting format="linespecific" id="I_6_tt287">import org.apache.commons.betwixt.io;

Play play = (Play) plays.get(0);
        
BeanWriter beanWriter = <userinput moreinfo="none">new</userinput> BeanWriter( );
beanWriter.enablePrettyPrint( );
beanWriter.write( play );
        
logger.debug( beanWriter.toString( ) );</programlisting>

      <para>Betwixt creates the following XML document, which stores the
      <literal moreinfo="none">genre</literal>, <literal
      moreinfo="none">year</literal>, and <literal
      moreinfo="none">language</literal> properties as attributes of the
      <literal moreinfo="none">play</literal> element. The differences between
      this XML document and the XML document in <link
      linkend="xml-sect-beans-xml">Recipe 6.7</link> are emphasized:</para>

      <programlisting format="linespecific" id="I_6_tt288">
               <userinput moreinfo="none">&lt;play genre="tragedy" year="1603" language="english"&gt;</userinput>
  &lt;author&gt;William Shakespeare&lt;/author&gt;
  &lt;characters&gt;
<userinput moreinfo="none">    &lt;character protagonist="false"&gt;</userinput>
      &lt;description&gt;King of Denmark&lt;/description&gt;
      &lt;name&gt;Claudius&lt;/name&gt;
    &lt;/character&gt;
<userinput moreinfo="none">    &lt;character protagonist="true"&gt;</userinput>
      &lt;description&gt;Son to the late, and nephew of the present king&lt;/description&gt;
      &lt;name&gt;Hamlet&lt;/name&gt;
    &lt;/character&gt;
<userinput moreinfo="none">    &lt;character protagonist="false"&gt;</userinput>
      &lt;description&gt;friend to Hamlet&lt;/description&gt;
      &lt;name&gt;Horatio&lt;/name&gt;
    &lt;/character&gt;
  &lt;/characters&gt;
  &lt;name&gt;Hamlet&lt;/name&gt;
  &lt;summary&gt;Prince of Denmark (Hamlet) freaks out, talks to father's ghost, and
    finally dies in a duel.&lt;/summary&gt;
&lt;/play&gt;</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>The previous example wrote the <literal
      moreinfo="none">protagonist</literal> property of the <literal
      moreinfo="none">Character</literal> class as an attribute of the
      <literal moreinfo="none">character</literal> element. This customization
      was accomplished by putting a <filename
      moreinfo="none">Character.betwixt</filename> resource in the same
      package as the <literal moreinfo="none">Character</literal> class.
      <filename moreinfo="none">Character.betwixt</filename> is shown
      here:</para>

      <programlisting format="linespecific" id="I_6_tt289">&lt;info primitiveTypes="element"&gt;
  &lt;element name="character"&gt;
    &lt;attribute name="protagonist" property="protagonist"/&gt;
    &lt;addDefaults/&gt;
  &lt;/element&gt;
&lt;/info&gt;</programlisting>

      <para>In addition to customizing the structure on an XML document, a
      Betwixt mapping file can also be used to change the names of elements
      and attributes in an XML document. The following mapping file—another
      version of <filename moreinfo="none">Character.betwixt—</filename>writes
      the <literal moreinfo="none">description</literal> property of <literal
      moreinfo="none">Character</literal> as a <literal
      moreinfo="none">bio</literal> element:</para>

      <programlisting format="linespecific" id="I_6_tt290">&lt;info primitiveTypes="element"&gt;
  &lt;element name="character"&gt;
    &lt;attribute name="protagonist" property="protagonist"/&gt;
<userinput moreinfo="none">    &lt;element name="bio" property="description"/&gt;</userinput>
    &lt;addDefaults/&gt;
  &lt;/element&gt;
&lt;/info&gt;</programlisting>

      <para>In this recipe, Betwixt has wrapped all <literal
      moreinfo="none">character</literal> elements in a <literal
      moreinfo="none">characters</literal> element. If you prefer <literal
      moreinfo="none">character</literal> elements to be child elements of
      <literal moreinfo="none">play</literal>, you can tell the <literal
      moreinfo="none">XMLIntrospector</literal> used by <literal
      moreinfo="none">BeanWriter</literal> to omit elements wrapping
      collections with the following code:</para>

      <programlisting format="linespecific" id="I_6_tt291">import org.apache.commons.betwixt.io.BeanWriter;
import org.apache.commons.betwixt.XMLIntrospector;

Play play = (Play) plays.get(0);
        
BeanWriter beanWriter = <userinput moreinfo="none">new</userinput> BeanWriter( );
beanWriter.enablePrettyPrint( );

<userinput moreinfo="none">// Configure XML Introspector to omit collection elements</userinput>
               <userinput moreinfo="none">XMLIntrospector introspector = beanWriter.getXMLIntrospector( );</userinput>
               <userinput moreinfo="none">introspector.setWrapCollectionsInElement(false);</userinput>

beanWriter.write( play );
        
logger.debug( beanWriter.toString( ) );</programlisting>

      <para>The previous code creates an XML document without the <literal
      moreinfo="none">characters</literal> element:</para>

      <programlisting format="linespecific" id="I_6_tt292">&lt;play genre="tragedy" year="1603" language="english"&gt;
  &lt;author&gt;William Shakespeare&lt;/author&gt;
  &lt;character protagonist="false"&gt;
    &lt;description&gt;King of Denmark&lt;/description&gt;
    &lt;name&gt;Claudius&lt;/name&gt;
  &lt;/character&gt;
  &lt;character protagonist="true"&gt;
    &lt;description&gt;Son to the late, and nephew of the present king&lt;/description&gt;
    &lt;name&gt;Hamlet&lt;/name&gt;
  &lt;/character&gt;
  &lt;character protagonist="false"&gt;
    &lt;description&gt;friend to Hamlet&lt;/description&gt;
    &lt;name&gt;Horatio&lt;/name&gt;
  &lt;/character&gt;
  &lt;name&gt;Hamlet&lt;/name&gt;
  &lt;summary&gt;Prince of Denmark (Hamlet) freaks out, talks to father's ghost, and
    finally dies in a duel.&lt;/summary&gt;
&lt;/play&gt;</programlisting>

      <para>Betwixt also allows for the customization of element and attribute
      names; for example, if your class contains the property <literal
      moreinfo="none">maximumSpeed</literal>, it can be written as an
      attribute named <literal moreinfo="none">maximum-speed</literal> or
      <literal moreinfo="none">MAXIMUM_SPEED</literal>, using the <literal
      moreinfo="none">HyphenatedNameMapper</literal> strategy. The same
      property could also be written as an element named <literal
      moreinfo="none">MaximumSpeed</literal>, using the <literal
      moreinfo="none">CapitalizeNameMapper</literal> strategy. Different
      naming strategies can be used for elements and attributes by passing
      instances of <literal moreinfo="none">NameMapper</literal> to <literal
      moreinfo="none">setElementNameMapper( )</literal> and <literal
      moreinfo="none">setAttributeNameMapper( )</literal> on an <literal
      moreinfo="none">XMLIntrospector</literal>. The following code
      demonstrates the setting of both the attribute and element <literal
      moreinfo="none">NameMapper</literal> on a <literal
      moreinfo="none">BeanWriter</literal>'s <literal
      moreinfo="none">XMLIntrospector</literal>:</para>

      <programlisting format="linespecific" id="I_6_tt293">import org.apache.commons.betwixt.io.BeanWriter;
import org.apache.commons.betwixt.XMLIntrospector;
import org.apache.commons.betwixt.strategy.CapitalizeNameMapper;
import org.apache.commons.betwixt.strategy.HyphenatedNameMapper;

BeanWriter beanWriter = <userinput moreinfo="none">new</userinput> BeanWriter( );

// Set NameMappers on XMLIntrospector
XMLIntrospector introspector = beanWriter.getXMLIntrospector( );
introspector.setElementNameMapper( new CapitalizeNameMapper( ) );
introspector.setAttributeNameMapper( new HyphenatedNameMapper( ) );

beanWriter.write( object );</programlisting>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>For more information about possible <indexterm class="endofrange"
      id="xml-ITERM-2768" significance="normal"
      startref="xml-ITERM-2761"></indexterm> <indexterm class="endofrange"
      id="xml-ITERM-2769" significance="normal"
      startref="xml-ITERM-2762"></indexterm> <indexterm class="endofrange"
      id="xml-ITERM-2770" significance="normal"
      startref="xml-ITERM-2763"></indexterm> <indexterm class="endofrange"
      id="xml-ITERM-2771" significance="normal"
      startref="xml-ITERM-2764"></indexterm> <indexterm class="endofrange"
      id="xml-ITERM-2772" significance="normal"
      startref="xml-ITERM-2765"></indexterm> <indexterm class="endofrange"
      id="xml-ITERM-2773" significance="normal"
      startref="xml-ITERM-2766"></indexterm> <indexterm class="endofrange"
      id="xml-ITERM-2774" significance="normal"
      startref="xml-ITERM-2767"></indexterm>customizations in Betwixt, see the
      "Binding Beans" section of the user guide at <ulink
      url="http://jakarta.apache.org/commons/betwixt/guide/binding.html">http://commons.apache.org/betwixt/guide/binding.html</ulink>.</para>
    </sect2>
  </sect1>

  <sect1 id="xml-sect-turning-xml-into-beans" label="6.9" role="Recipe">
    <title>Turning XML Documents into Beans</title>

    <sect2>
      <title>Problem</title>

      <para>You need to convert an XML <indexterm id="xml-ITERM-2775"
          significance="normal">
          <primary>XML (Extensible Markup Language)</primary>

          <secondary>beans</secondary>
        </indexterm> <indexterm id="xml-ITERM-2776" significance="normal">
          <primary>conversion</primary>
        </indexterm> <indexterm id="xml-ITERM-2777" significance="normal">
          <primary>documents</primary>

          <secondary>XML</secondary>

          <tertiary>bean conversion</tertiary>
        </indexterm> <indexterm id="xml-ITERM-2778" significance="normal">
          <primary>beans</primary>

          <secondary>XML</secondary>
        </indexterm> <indexterm id="xml-ITERM-2779" significance="normal">
          <primary>conversion</primary>
        </indexterm> <indexterm id="xml-ITERM-2780" significance="normal">
          <primary>conversion</primary>

          <secondary>XML</secondary>

          <tertiary>beans</tertiary>
        </indexterm>document into a Bean.</para>
    </sect2>

    <sect2>
      <title>Solution</title>

      <para>Use Betwixt's <literal moreinfo="none">BeanReader</literal> to
      parse an XML document and create an instance of the appropriate bean.
      Register bean classes with the <literal
      moreinfo="none">BeanReader</literal>, and parse an XML document loaded
      from an <literal moreinfo="none">InputStream</literal>, <literal
      moreinfo="none">InputSource</literal>, or <literal
      moreinfo="none">Reader</literal>. The following XML document will be
      parsed into the <literal moreinfo="none">Play</literal> and <literal
      moreinfo="none">Character</literal> beans introduced in <link
      linkend="xml-sect-xml-doc-obj">Recipe 6.2</link>:</para>

      <programlisting format="linespecific" id="I_6_tt294">&lt;play genre="tragedy" year="1603" language="english"&gt;
  &lt;author&gt;William Shakespeare&lt;/author&gt;
  &lt;character protagonist="false"&gt;
    &lt;description&gt;King of Denmark&lt;/description&gt;
    &lt;name&gt;Claudius&lt;/name&gt;
  &lt;/character&gt;
  &lt;character protagonist="true"&gt;
    &lt;description&gt;Son to the late, and nephew of the present king&lt;/description&gt;
    &lt;name&gt;Hamlet&lt;/name&gt;
  &lt;/character&gt;
  &lt;character protagonist="false"&gt;
    &lt;description&gt;friend to Hamlet&lt;/description&gt;
    &lt;name&gt;Horatio&lt;/name&gt;
  &lt;/character&gt;
  &lt;name&gt;Hamlet&lt;/name&gt;
  &lt;summary&gt;Prince of Denmark (Hamlet) freaks out, talks to father's ghost, and
    finally dies in a duel.&lt;/summary&gt;
&lt;/play&gt;</programlisting>

      <para>This XML document was created with <literal
      moreinfo="none">BeanWriter</literal>, using the customized format from
      <link linkend="xml-sect-customizing-xml">Recipe 6.8</link>. To read this
      XML document with <literal moreinfo="none">BeanReader</literal>, the
      <literal moreinfo="none">Play</literal> class will need to be registered
      with <literal moreinfo="none">BeanReader</literal> and the <literal
      moreinfo="none">XMLIntrospector</literal> must have the same settings as
      the <literal moreinfo="none">XMLIntrospector</literal> used when writing
      the document with <literal moreinfo="none">BeanWriter</literal>. The
      following code instantiates and configures a <literal
      moreinfo="none">BeanReader</literal> to read this customized XML for the
      <literal moreinfo="none">Play</literal> object:</para>

      <programlisting format="linespecific" id="I_6_tt295">import org.apache.commons.betwixt.io.BeanReader;

InputStream customPlay = 
    getClass( ).getResourceAsStream("./customized-play.xml");
BeanReader beanReader = new BeanReader( );
beanReader.getXMLIntrospector( ).setWrapCollectionsInElement(false);
beanReader.registerBeanClass(Play.class);

Play play = (Play) beanReader.parse( customPlay );</programlisting>
    </sect2>

    <sect2>
      <title>Discussion</title>

      <para>Betwixt uses Commons Digester to parse XML, and the <literal
      moreinfo="none">BeanReader</literal> object is an extension of the
      <literal moreinfo="none">Digester</literal>. <literal
      moreinfo="none">BeanReader</literal> creates a Digester rule set using
      introspection and the Betwixt mapping files available on the classpath.
      Digester, as introduced in the first half of this chapter, is a quick
      way to parse an XML document; all that is required to parse XML with the
      Digester is a rule set and a little bit of code. Betwixt is built-upon
      Digester, and the <literal moreinfo="none">BeanReader</literal> further
      reduces the amount of work required to parse XML to a bean. Instead of
      completing the process demonstrated in <link
      linkend="xml-sect-xml-doc-obj">Recipe 6.2</link>, you can simply write a
      few, very manageable, <filename moreinfo="none">.betwixt</filename>
      files using <literal moreinfo="none">BeanReader</literal> to read the
      XML documents and <literal moreinfo="none">BeanWriter</literal> to write
      the XML documents.</para>

      <para>When Betwixt is adding <literal
      moreinfo="none">Character</literal> objects to the characters <literal
      moreinfo="none">List</literal> on a <literal
      moreinfo="none">Play</literal> object, it's calling the <literal
      moreinfo="none">addCharacter()</literal> method on the <literal
      moreinfo="none">Play</literal> object. Without this <literal
      moreinfo="none">addCharacter( )</literal> object, Betwixt would not be
      able to populate this <literal moreinfo="none">List</literal>. Betwixt
      automatically recognizes a plural property name such as <literal
      moreinfo="none">characters</literal>, <literal
      moreinfo="none">characterList</literal>, or <literal
      moreinfo="none">characterSet</literal>, and it attempts to call the
      corresponding <literal moreinfo="none">addCharacter( )</literal> method.
      For more information about the algorithm Betwixt uses to recognize
      composite properties, see "Using Adder Methods for Composite Properties"
      in the Betwixt user guide (<ulink
      url="http://jakarta.apache.org/commons/betwixt/guide/binding.html">http://commons.apache.org/betwixt/guide/binding.html</ulink>).</para>
    </sect2>

    <sect2>
      <title>See Also</title>

      <para>For more information about reading beans with Betwixt, see
      "Reading Beans" in the Betwixt user guide (<ulink
      url="http://jakarta.apache.org/commons/betwixt/guide/reading.html">http://commons.apache.org/betwixt/guide/reading.html</ulink>).</para>
    </sect2>
  </sect1>
</chapter>
